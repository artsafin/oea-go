// Package codaschema provides primitives to interact with entities of a coda document.
//
// Code generated by github.com/artsafin/coda-schema-generator DO NOT EDIT.

package codaschema

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/artsafin/coda-go-client/codaapi"
	"net/http"
	"strconv"
	"strings"
	"sync"
	"time"
)

//region Basic types

type _schema struct {
	Table   _tableSchema
	Formula _formulaSchema
	Control _controlSchema
}

type _codaEntity struct {
	ID   string
	Name string
}

func (e _codaEntity) String() string {
	return e.ID
}

type _tableSchema struct {
	AllEmployees                      _allEmployeesTable                      // All employees
	Invoice                           _invoiceTable                           // Invoice
	Months                            _monthsTable                            // Months
	Entries                           _entriesTable                           // Entries
	WorkingEmployees                  _workingEmployeesTable                  // Working Employees
	WorkingEmployeesNames             _workingEmployeesNamesTable             // Working employees names
	InvoicesOverview                  _invoicesOverviewTable                  // Invoices overview
	PatentCompensation                _patentCompensationTable                // Patent compensation
	EntryType                         _entryTypeTable                         // Entry Type
	PatentsOverview                   _patentsOverviewTable                   // Patents overview
	LegalEntity                       _legalEntityTable                       // Legal entity
	SalariesReport                    _salariesReportTable                    // Salaries report
	TaxYears                          _taxYearsTable                          // Tax years
	EmployeePatents                   _employeePatentsTable                   // Employee Patents
	FullPayrollReport                 _fullPayrollReportTable                 // Full payroll report
	EmptyActualRates                  _emptyActualRatesTable                  // Empty actual rates
	CorrectionsByType                 _correctionsByTypeTable                 // Corrections by type
	PayrollReportToAdd                _payrollReportToAddTable                // Payroll report to add
	BankTariffs                       _bankTariffsTable                       // Bank tariffs
	PHCorrections                     _pHCorrectionsTable                     // PH corrections
	PHMonthlyReport                   _pHMonthlyReportTable                   // PH Monthly Report
	Location                          _locationTable                          // Location
	CompanyRates                      _companyRatesTable                      // Company rates
	SummaryForCurrentPeriod3          _summaryForCurrentPeriod3Table          // Summary for current period 3
	CurrentPayrollV2                  _currentPayrollV2Table                  // Current payroll v2
	HeadcountPerLocation              _headcountPerLocationTable              // Headcount per location
	SuspiciousRates                   _suspiciousRatesTable                   // Suspicious rates
	WorkDays                          _workDaysTable                          // Work days
	CorrectionsByEmployee             _correctionsByEmployeeTable             // Corrections by employee
	EnterCompanyRatesForSelectedMonth _enterCompanyRatesForSelectedMonthTable // Enter company rates for selected month
	TemplateEntries                   _templateEntriesTable                   // Template Entries
	AllEmployeesNames                 _allEmployeesNamesTable                 // All employees names
	BankDetails                       _bankDetailsTable                       // Bank details
	BeneficiaryBank                   _beneficiaryBankTable                   // Beneficiary Bank
	PayrollSchedule                   _payrollScheduleTable                   // Payroll Schedule
	PensionFundFixed                  _pensionFundFixedTable                  // Pension Fund fixed
	SocialInsurance                   _socialInsuranceTable                   // Social Insurance
	PensionFundPercent                _pensionFundPercentTable                // Pension fund percent
	PerDayCalculations                _perDayCalculationsTable                // Per Day Calculations
	PerDayPolicies                    _perDayPoliciesTable                    // Per Day Policies
	Salaries                          _salariesTable                          // Salaries
	PayableEmployees                  _payableEmployeesTable                  // Payable employees
	QuickManualEntry                  _quickManualEntryTable                  // Quick Manual Entry
	NewInvoiceEntriesPerType          _newInvoiceEntriesPerTypeTable          // New invoice entries per type
	EntriesPerDateAndType             _entriesPerDateAndTypeTable             // Entries per date and type
	AddNewEmployee                    _addNewEmployeeTable                    // Add new employee
	CurrentTemplateEntries            _currentTemplateEntriesTable            // Current template entries
	TemplateEntriesMonthsFiltering    _templateEntriesMonthsFilteringTable    // Template entries months filtering
	TemplateEntriesTypeFiltering      _templateEntriesTypeFilteringTable      // Template entries type filtering
	EntriesMonthsFiltering            _entriesMonthsFilteringTable            // Entries months filtering
	EntriesTypeFiltering              _entriesTypeFilteringTable              // Entries type filtering
	FilteredEntries                   _filteredEntriesTable                   // Filtered Entries
	AddCompanyRate                    _addCompanyRateTable                    // Add company rate
	TESTTABLE                         _tESTTABLETable                         // TEST TABLE
}
type _formulaSchema struct {
	CurrentMonth               _codaEntity // currentMonth
	PayrollReportCurRate       _codaEntity // payrollReportCurRate
	InvoiceAddingRate          _codaEntity // invoiceAddingRate
	NewInvoiceValidation       _codaEntity // newInvoiceValidation
	NewInvoiceValidationIcon   _codaEntity // newInvoiceValidationIcon
	NewInvoiceErrors           _codaEntity // newInvoiceErrors
	NewInvoicePayableEmployees _codaEntity // newInvoicePayableEmployees
	NewInvoiceWarns            _codaEntity // newInvoiceWarns
}
type _controlSchema struct {
	SelectOverviewMonth             _codaEntity // selectOverviewMonth
	SelectOverviewEmployee          _codaEntity // selectOverviewEmployee
	InvoiceAddingMonth              _codaEntity // invoiceAddingMonth
	PayrollReportCurPeriod          _codaEntity // payrollReportCurPeriod
	PayrollReportAddReport          _codaEntity // payrollReportAddReport
	FillRatesShowFilled             _codaEntity // fillRatesShowFilled
	NewInvoiceBtn                   _codaEntity // newInvoiceBtn
	NewInvoiceMonth                 _codaEntity // newInvoiceMonth
	Button1                         _codaEntity // button 1
	Button2                         _codaEntity // button 2
	Button3                         _codaEntity // button 3
	BtnTemplateEntriesShowAllTypes  _codaEntity // btnTemplateEntriesShowAllTypes
	BtnTemplateEntriesShowAllDates  _codaEntity // btnTemplateEntriesShowAllDates
	BtnTemplateEntriesShowAllDates2 _codaEntity // btnTemplateEntriesShowAllDates 2
	BtnTemplateEntriesShowAllTypes2 _codaEntity // btnTemplateEntriesShowAllTypes 2
}

// Table All employees
type _allEmployeesTable struct {
	_codaEntity
	Cols _allEmployeesTableColumns
}
type _allEmployeesTableColumns struct {
	Name                 _codaEntity /* text [Name] */
	StartDate            _codaEntity /* date [Start date] */
	EndDate              _codaEntity /* date [End date] */
	ContractHourRate     _codaEntity /* number [Contract hour rate] */
	OpeningDateIP        _codaEntity /* date [Opening date IP] */
	WorkingNow           _codaEntity /* checkbox [Working now?] = NOT([End date]) OR [End date] >= Today() */
	EnglishFullName      _codaEntity /* text [English full name] */
	LegalEntity          _codaEntity /* lookup [Legal entity] */
	Location             _codaEntity /* lookup [Location] */
	FinanceSD            _codaEntity /* text [Finance SD] */
	GeneralSD            _codaEntity /* text [General SD] */
	ContractNumber       _codaEntity /* text [Contract Number] */
	ContractDate         _codaEntity /* text [Contract Date] */
	LegalForm            _codaEntity /* select [Legal form] */
	BankTariff           _codaEntity /* lookup [Bank tariff] */
	Rounding             _codaEntity /* number [Rounding] */
	BankDetails          _codaEntity /* lookup [Bank details] */
	SpecialPaymentPolicy _codaEntity /* checkbox [Special payment policy] */
	RequiredFields       _codaEntity /* text [Required fields] = List(
	  List([Bank tariff].IsNotBlank(), "Bank tariff"),
	  List([Bank details].IsNotBlank(), "Bank details"),
	  List([Contract hour rate] > 0, "Contract hour rate"),
	  List(Rounding > 0, "Rounding"),
	  List(
	    [English full name].IsNotBlank(),
	    "English full name"
	  ),
	  List([Legal entity].IsNotBlank(), "Legal entity"),
	  List(Location.IsNotBlank(), "Location"),
	  List([Contract Date].IsNotBlank(), "Contract Date"),
	  List(
	    [Contract Number].IsNotBlank(), "Contract Number"
	  ),
	  List([Legal form].IsNotBlank(), "Legal form")
	) */
	Valid         _codaEntity /* checkbox [Valid?] = AND([Required fields].FormulaMap(CurrentValue.First())) */
	InvalidFields _codaEntity /* text [Invalid fields] = [Required fields].Filter(If(Not(CurrentValue.First()), CurrentValue.Last(), false())).FormulaMap(CurrentValue.Last()) */
}

// Table Invoice
type _invoiceTable struct {
	_codaEntity
	Cols _invoiceTableColumns
}
type _invoiceTableColumns struct {
	ID              _codaEntity /* text [ID] = ToText(Month) + " " + ToText(Employee) */
	InvoiceHash     _codaEntity /* text [Invoice #] = Format("{1}{2:00}", Month.Month.Year(), Month.Month.Month()) */
	Month           _codaEntity /* lookup [Month] */
	Employee        _codaEntity /* lookup [Employee] */
	PreviousInvoice _codaEntity /* lookup [Previous invoice] = thisTable
	.Filter(
	  AND(
	    Employee = Employee,
	    Month = Month.[Previous month Link]
	  )
	)
	.First() */
	EURRUBExpected      _codaEntity /* number [EURRUB expected] */
	EURSubtotal         _codaEntity /* number [EUR Subtotal] = [RUB Entries]/[EURRUB expected]+[EUR Entries] */
	EURRounding         _codaEntity /* number [EUR Rounding] = [EUR Total]-[EUR Subtotal] */
	EUREntries          _codaEntity /* number [EUR Entries] = [Invoice Entries].[EUR Amount].Sum() */
	Hours               _codaEntity /* number [Hours] = [EUR Total]/Rounding */
	EURRUBActual        _codaEntity /* number [EURRUB actual] */
	RUBActual           _codaEntity /* number [RUB Actual] = [EURRUB actual]*[EUR Total] */
	RUBRateError        _codaEntity /* number [RUB Rate Error] = If([EURRUB actual], [RUB Total]-[RUB Actual], 0) */
	InvoiceEntries      _codaEntity /* lookup [Invoice Entries] = Entries.Filter(Invoice.Contains(thisRow)) */
	RUBEntries          _codaEntity /* number [RUB Entries] = [Invoice Entries].[RUB Amount].Sum() */
	PaymentChecksPassed _codaEntity /* checkbox [Payment Checks Passed] = Checks.Filter(Not(CurrentValue.First())).Count()=0 OR [Approved manually?] */
	TemplatesRefs       _codaEntity /* lookup [Templates Refs] = [Template Entries]
	.Filter(
	  Employee = Employee AND
	    If(
	      IsBlank([Month from]),
	      True(),
	      Month.Month >=
	        [Month from].Month
	    ) AND
	    If(
	      IsBlank([Month to]),
	      True(),
	      Month.Month <=
	        [Month to].Month
	    )
	) */
	RecipientDetails _codaEntity /* lookup [Recipient details] */
	EURTotal         _codaEntity /* number [EUR Total] = Ceiling([EUR Subtotal], Rounding) */
	ApprovedManually _codaEntity /* checkbox [Approved manually?] */
	SenderDetails    _codaEntity /* lookup [Sender details] */
	RUBTotal         _codaEntity /* number [RUB Total] = [EUR Total]*[EURRUB expected] */
	HourRate         _codaEntity /* number [Hour Rate] */
	WorkDays         _codaEntity /* number [Work days] */
	ContractDate     _codaEntity /* text [Contract Date] */
	ContractNumber   _codaEntity /* text [Contract Number] */
	Checks           _codaEntity /* text [Checks] = List(
	  WithName(Employee.[Special payment policy], v, List(not(v), If(v, "Special payment policy", ""))),

	  WithName(1.10, threshold, WithName([Invoice Entries].Filter(Type=[Base salary]).First(), sal, WithName(
	    [EUR Subtotal]/(sal.[EUR Amount]+sal.[RUB Amount in EUR]), ratio, List(ratio<=threshold, If(ratio>threshold, "Salary ratio " + RoundDown(100*threshold)+"%", "") ))
	  ))
	) */
	Alerts _codaEntity /* text [Alerts] = Checks.Filter(not(CurrentValue.First())).FormulaMap(CurrentValue.Last()).BulletedList() */
}

// Table Months
type _monthsTable struct {
	_codaEntity
	Cols _monthsTableColumns
}
type _monthsTableColumns struct {
	Month             _codaEntity /* date [Month] */
	Year              _codaEntity /* number [Year] = Year(Month) */
	ID                _codaEntity /* text [ID] = Format("{1}-{2:00}",Month.Year(), Month.Month()) */
	PreviousMonthLink _codaEntity /* lookup [Previous month Link] = Months
	.Filter(
	  ID =
	    Format(
	      "{1}-{2:00}",
	      [Previous month].Year(),
	      [Previous month].Month()
	    )
	)
	.First() */
	PreviousMonth _codaEntity /* date [Previous month] = Month.EndOfMonth(-1) */
	Current       _codaEntity /* checkbox [Current?] = Today() > [Previous month] AND Today() <= Month */
	Near          _codaEntity /* checkbox [Near?] = Month>= Today() - Days(90) AND Month <= Today() + Days(120) */
	Future        _codaEntity /* checkbox [Future?] = Month > Today() */
	Upcoming      _codaEntity /* checkbox [Upcoming?] = [Future?] AND NOT([Current?]) */
}

// Table Entries
type _entriesTable struct {
	_codaEntity
	Cols _entriesTableColumns
}
type _entriesTableColumns struct {
	Comment   _codaEntity /* text [Comment] */
	EURAmount _codaEntity /* number [EUR Amount] */
	RUBAmount _codaEntity /* number [RUB Amount] */
	Invoice   _codaEntity /* lookup [Invoice] */
	Display   _codaEntity /* text [Display] = List(
	  IF([RUB Amount], concatenate("₽", [RUB Amount]), ""),
	  IF([EUR Amount], concatenate("€", [EUR Amount]), ""),
	  Category.ToText()
	).Filter(CurrentValue.IsNotBlank()).Join(" ") */
	Type           _codaEntity /* lookup [Type] */
	ModifiedOn     _codaEntity /* dateTime [Modified on] = thisRow.Modified() */
	CreatedOn      _codaEntity /* dateTime [Created on] = thisRow.Created() */
	Origin         _codaEntity /* text [Origin] */
	ModifiedBy     _codaEntity /* person [Modified by] = thisRow.ModifiedBy() */
	Sort           _codaEntity /* number [Sort] = Type.Sort */
	RUBAmountInEUR _codaEntity /* number [RUB Amount in EUR] = [RUB Amount]/Invoice.[EURRUB expected] */
	Month          _codaEntity /* lookup [Month] = Invoice.Month */
}

// Table Working Employees
type _workingEmployeesTable struct {
	_codaEntity
	Cols _workingEmployeesTableColumns
}
type _workingEmployeesTableColumns struct {
	Name                 _codaEntity /* text [Name] */
	StartDate            _codaEntity /* date [Start date] */
	GeneralSD            _codaEntity /* text [General SD] */
	FinanceSD            _codaEntity /* text [Finance SD] */
	Location             _codaEntity /* lookup [Location] */
	LegalEntity          _codaEntity /* lookup [Legal entity] */
	LegalForm            _codaEntity /* select [Legal form] */
	BankTariff           _codaEntity /* lookup [Bank tariff] */
	SpecialPaymentPolicy _codaEntity /* checkbox [Special payment policy] */
	EnglishFullName      _codaEntity /* text [English full name] */
	ContractNumber       _codaEntity /* text [Contract Number] */
	ContractDate         _codaEntity /* text [Contract Date] */
	BankDetails          _codaEntity /* lookup [Bank details] */
}

// Table Working employees names
type _workingEmployeesNamesTable struct {
	_codaEntity
	Cols _workingEmployeesNamesTableColumns
}
type _workingEmployeesNamesTableColumns struct {
	Name      _codaEntity /* text [Name] */
	StartDate _codaEntity /* date [Start date] */
	Location  _codaEntity /* lookup [Location] */
}

// Table Invoices overview
type _invoicesOverviewTable struct {
	_codaEntity
	Cols _invoicesOverviewTableColumns
}
type _invoicesOverviewTableColumns struct {
	Employee            _codaEntity /* lookup [Employee] */
	Month               _codaEntity /* lookup [Month] */
	PaymentChecksPassed _codaEntity /* checkbox [Payment Checks Passed] = Checks.Filter(Not(CurrentValue.First())).Count()=0 OR [Approved manually?] */
	RUBEntries          _codaEntity /* number [RUB Entries] = [Invoice Entries].[RUB Amount].Sum() */
	InvoiceEntries      _codaEntity /* lookup [Invoice Entries] = Entries.Filter(Invoice.Contains(thisRow)) */
	EURRUBExpected      _codaEntity /* number [EURRUB expected] */
	EURRUBActual        _codaEntity /* number [EURRUB actual] */
	EURSubtotal         _codaEntity /* number [EUR Subtotal] = [RUB Entries]/[EURRUB expected]+[EUR Entries] */
	EURRounding         _codaEntity /* number [EUR Rounding] = [EUR Total]-[EUR Subtotal] */
	EUREntries          _codaEntity /* number [EUR Entries] = [Invoice Entries].[EUR Amount].Sum() */
	RUBRateError        _codaEntity /* number [RUB Rate Error] = If([EURRUB actual], [RUB Total]-[RUB Actual], 0) */
	RecipientDetails    _codaEntity /* lookup [Recipient details] */
}

// Table Patent compensation
type _patentCompensationTable struct {
	_codaEntity
	Cols _patentCompensationTableColumns
}
type _patentCompensationTableColumns struct {
	PaymentInvoice     _codaEntity /* lookup [Payment Invoice] */
	PeriodCost         _codaEntity /* number [Period cost] = IF([Period cost manual], [Period cost manual], Switch(Period, "First", [Employee patent ref].[Date 1 Payment], "Second", [Employee patent ref].[Date 2 Payment], 0)) */
	Period             _codaEntity /* select [Period] */
	PeriodCostOverride _codaEntity /* number [Period cost override] */
	EmployeePatentRef  _codaEntity /* lookup [Employee patent ref] */
	Apply              _codaEntity /* button [Apply] */
}

// Table Entry Type
type _entryTypeTable struct {
	_codaEntity
	Cols _entryTypeTableColumns
}
type _entryTypeTableColumns struct {
	Type      _codaEntity /* text [Type] */
	Comment   _codaEntity /* text [Comment] */
	Archetype _codaEntity /* select [Archetype] */
	Sort      _codaEntity /* number [Sort] */
}

// Table Patents overview
type _patentsOverviewTable struct {
	_codaEntity
	Cols _patentsOverviewTableColumns
}
type _patentsOverviewTableColumns struct {
	PaymentInvoice _codaEntity /* lookup [Payment Invoice] */
	PeriodCost     _codaEntity /* number [Period cost] = IF([Period cost manual], [Period cost manual], Switch(Period, "First", [Employee patent ref].[Date 1 Payment], "Second", [Employee patent ref].[Date 2 Payment], 0)) */
	Period         _codaEntity /* select [Period] */
}

// Table Legal entity
type _legalEntityTable struct {
	_codaEntity
	Cols _legalEntityTableColumns
}
type _legalEntityTableColumns struct {
	EntityName    _codaEntity /* text [Entity name] */
	Requisites    _codaEntity /* text [Requisites] */
	Taxable       _codaEntity /* checkbox [Taxable] */
	OfficialName  _codaEntity /* text [Official name] */
	AccountNumber _codaEntity /* text [Account number] */
}

// Table Salaries report
type _salariesReportTable struct {
	_codaEntity
	Cols _salariesReportTableColumns
}
type _salariesReportTableColumns struct {
	Name      _codaEntity /* text [Name] */
	StartDate _codaEntity /* date [Start date] */
}

// Table Tax years
type _taxYearsTable struct {
	_codaEntity
	Cols _taxYearsTableColumns
}
type _taxYearsTableColumns struct {
	Year                   _codaEntity /* number [Year] */
	PensionFundFixedPart   _codaEntity /* number [Pension fund fixed part] */
	SocialInsurance        _codaEntity /* number [Social Insurance] */
	IsCurrent              _codaEntity /* checkbox [Is Current] = Year=Year(Today()) */
	PensionFundPercentPart _codaEntity /* number [Pension fund percent part] */
	CalendarDaysInYear     _codaEntity /* number [Calendar days in year] */
}

// Table Employee Patents
type _employeePatentsTable struct {
	_codaEntity
	Cols _employeePatentsTableColumns
}
type _employeePatentsTableColumns struct {
	Employee     _codaEntity /* lookup [Employee] */
	Year         _codaEntity /* lookup [Year] */
	Cost         _codaEntity /* number [Cost] = [Date 1 Payment]+[Date 2 Payment] */
	Scan         _codaEntity /* image [Scan] */
	Date1        _codaEntity /* date [Date 1] */
	Date1Payment _codaEntity /* number [Date 1 Payment] */
	Date2        _codaEntity /* date [Date 2] */
	Date2Payment _codaEntity /* number [Date 2 Payment] */
	Display      _codaEntity /* text [Display] = Employee.Name + " " + Year.Year */
}

// Table Full payroll report
type _fullPayrollReportTable struct {
	_codaEntity
	Cols _fullPayrollReportTableColumns
}
type _fullPayrollReportTableColumns struct {
	SalaryNet             _codaEntity /* number [Salary Net] = [Invoice Ref].[Base Salary, RUB] */
	InvoiceRef            _codaEntity /* lookup [Invoice Ref] */
	OvertimesRefs         _codaEntity /* lookup [Overtimes Refs] = [Invoice Ref].[Invoice Entries].Filter(Type.Type="Overtime") */
	OvertimesRUB          _codaEntity /* number [Overtimes, RUB] = [Overtimes Refs].[Total Correction, RUB].Sum() */
	BonusesRefs           _codaEntity /* text [Bonuses Refs] = [Invoice Ref].[Invoice Entries].Filter(Type.Type.Contains("Performance bonus", "FO benefits", "Personal benefits")) */
	BonusesRUB            _codaEntity /* number [Bonuses, RUB] = [Bonuses Refs].[Total Correction, RUB].Sum() */
	PublicHolidaysRefs    _codaEntity /* lookup [Public Holidays Refs] = [Invoice Ref].[Invoice Entries].Filter(Type.Type="Overtime Public Holiday") */
	PublicHolidaysRUB     _codaEntity /* number [Public holidays, RUB] = [Public Holidays Refs].[Total Correction, RUB].Sum() */
	RestCorrectionRefs    _codaEntity /* lookup [Rest correction Refs] = [Invoice Ref].[Invoice Entries].Filter(NOT(ListCombine([Public Holidays Refs], [Overtimes Refs], [Bonuses Refs], [Loans Refs], [Salary changes Refs], [Start day Refs], [Quit compensations Refs], [Paid annual leaves Refs]).Contains(CurrentValue))) */
	RestCorrectionsRUB    _codaEntity /* number [Rest corrections, RUB] = [Rest correction Refs].[Total Correction, RUB].Sum() */
	AnnualContribsRUB     _codaEntity /* number [Annual Contribs, RUB] = [Invoice Ref].[Patent, RUB] + [Invoice Ref].[Taxes, RUB] */
	StartDayRefs          _codaEntity /* lookup [Start day Refs] = [Invoice Ref].[Invoice Entries].Filter(Type.Type="Start day") */
	StartDayRUB           _codaEntity /* number [Start day, RUB] = [Start day Refs].[Total Correction, RUB].Sum() */
	SalaryChangesRefs     _codaEntity /* lookup [Salary changes Refs] = [Invoice Ref].[Invoice Entries].Filter(Type.Type="Salary change") */
	SalaryChangesRUB      _codaEntity /* number [Salary changes, RUB] = [Salary changes Refs].[Total Correction, RUB].Sum() */
	LoansRefs             _codaEntity /* text [Loans Refs] = [Invoice Ref].[Invoice Entries].Filter(Type.Type="Loan") */
	LoansRUB              _codaEntity /* number [Loans, RUB] = [Loans Refs].[Total Correction, RUB].Sum() */
	RUBServiceFees        _codaEntity /* number [RUB Service fees] = [Invoice Ref].[Bank fees]+[Invoice Ref].[Rate error PM] */
	EURRounding           _codaEntity /* number [EUR Rounding] = [Invoice Ref].[Amount requested, EUR]-[Invoice Ref].[Requested subtotal, EUR] */
	AnnualUnpaidLeavesRUB _codaEntity /* number [Annual/unpaid leaves, RUB] = [Paid annual leaves Refs].[Total Correction, RUB].Sum() */
	MonthlyContribsEUR    _codaEntity /* number [Monthly Contribs, EUR] = 0 */
	QuitCompensationsRefs _codaEntity /* lookup [Quit compensations Refs] = [Invoice Ref].[Invoice Entries].Filter(Type.Type="Quit") */
	QuitCompensationsRUB  _codaEntity /* number [Quit compensations, RUB] = [Quit compensations Refs].[Total Correction, RUB].Sum() */
	PaidAnnualLeavesRefs  _codaEntity /* lookup [Paid annual leaves Refs] = [Invoice Ref].[Invoice Entries].Filter(Type.Type="Annual leave") */
	Location              _codaEntity /* lookup [Location] = [Invoice Ref].Employee.Location */
}

// Table Empty actual rates
type _emptyActualRatesTable struct {
	_codaEntity
	Cols _emptyActualRatesTableColumns
}
type _emptyActualRatesTableColumns struct {
	Month          _codaEntity /* lookup [Month] */
	Employee       _codaEntity /* lookup [Employee] */
	EURRUBExpected _codaEntity /* number [EURRUB expected] */
	EURRUBActual   _codaEntity /* number [EURRUB actual] */
}

// Table Corrections by type
type _correctionsByTypeTable struct {
	_codaEntity
	Cols _correctionsByTypeTableColumns
}
type _correctionsByTypeTableColumns struct {
	Invoice   _codaEntity /* lookup [Invoice] */
	Type      _codaEntity /* lookup [Type] */
	Comment   _codaEntity /* text [Comment] */
	RUBAmount _codaEntity /* number [RUB Amount] */
	EURAmount _codaEntity /* number [EUR Amount] */
}

// Table Payroll report to add
type _payrollReportToAddTable struct {
	_codaEntity
	Cols _payrollReportToAddTableColumns
}
type _payrollReportToAddTableColumns struct {
	Month    _codaEntity /* lookup [Month] */
	Employee _codaEntity /* lookup [Employee] */
}

// Table Bank tariffs
type _bankTariffsTable struct {
	_codaEntity
	Cols _bankTariffsTableColumns
}
type _bankTariffsTableColumns struct {
	Name              _codaEntity /* text [Name] */
	DefaultCCFee      _codaEntity /* number [Default CC Fee] */
	DefaultServiceFee _codaEntity /* number [Default Service Fee] */
}

// Table PH corrections
type _pHCorrectionsTable struct {
	_codaEntity
	Cols _pHCorrectionsTableColumns
}
type _pHCorrectionsTableColumns struct {
	Comment _codaEntity /* text [Comment] */
}

// Table PH Monthly Report
type _pHMonthlyReportTable struct {
	_codaEntity
	Cols _pHMonthlyReportTableColumns
}
type _pHMonthlyReportTableColumns struct {
	Month              _codaEntity /* lookup [Month] */
	TotalCorrectionRUB _codaEntity /* number [Total Correction, RUB] = [PH corrections].Filter(Month=Month.ID).[Total Correction, RUB].Sum() */
	TotalCorrectionEUR _codaEntity /* number [Total Correction, EUR] = [PH corrections].Filter(Month=Month.ID).[Total Correction, EUR].Sum() */
}

// Table Location
type _locationTable struct {
	_codaEntity
	Cols _locationTableColumns
}
type _locationTableColumns struct {
	Location _codaEntity /* text [Location] */
}

// Table Company rates
type _companyRatesTable struct {
	_codaEntity
	Cols _companyRatesTableColumns
}
type _companyRatesTableColumns struct {
	Month  _codaEntity /* lookup [Month] */
	EURRUB _codaEntity /* number [EURRUB] */
}

// Table Summary for current period 3
type _summaryForCurrentPeriod3Table struct {
	_codaEntity
	Cols _summaryForCurrentPeriod3TableColumns
}
type _summaryForCurrentPeriod3TableColumns struct {
	Subject _codaEntity /* text [Subject] */
	RUB     _codaEntity /* number [RUB] = Switch(Subject,
	  "Net Salaries", [Location Refs].[Salary Net].Sum(),
	  "Monthly taxes&contributions", EUR *payrollReportCurRate,
	  "Annual taxes&contributions", [Location Refs].[Annual Contribs, RUB].Sum(),
	  "Public Holidays", [Location Refs].[Public holidays, RUB].Sum(),
	  "Overtimes", [Location Refs].[Overtimes, RUB].Sum(),
	  "Expense Reimbursement", [Location Refs].[Bonuses, RUB].Sum(),
	  "Notices", [Location Refs].[Quit compensations, RUB].Sum(),
	  "Annual/unpaid leaves", [Location Refs].[Annual/unpaid leaves, RUB].Sum(),
	  "Salary Increases", [Location Refs].[Salary changes, RUB].Sum(),
	  "Correction of start day", [Location Refs].[Start day, RUB].Sum(),
	  "Loans", [Location Refs].[Loans, RUB].Sum(),
	  "Service fees & Rounding", [Location Refs].[RUB Service fees].Sum() + [Location Refs].[EUR Rounding].Sum()*payrollReportCurRate,
	  "Other corrections", [Location Refs].[Rest corrections, RUB].Sum(),

	-999999999999999) */
	EUR _codaEntity /* number [EUR] = Switch(Subject,
	  "Monthly taxes&contributions", [Current payroll v2].Filter(Location=Location).[Monthly Contribs, EUR].Sum(),
	RUB/payrollReportCurRate) */
	Location     _codaEntity /* lookup [Location] */
	LocationRefs _codaEntity /* lookup [Location Refs] = [Current payroll v2].Filter(Location=Location) */
}

// Table Current payroll v2
type _currentPayrollV2Table struct {
	_codaEntity
	Cols _currentPayrollV2TableColumns
}
type _currentPayrollV2TableColumns struct {
	InvoiceRef            _codaEntity /* lookup [Invoice Ref] */
	Location              _codaEntity /* lookup [Location] = [Invoice Ref].Employee.Location */
	SalaryNet             _codaEntity /* number [Salary Net] = [Invoice Ref].[Base Salary, RUB] */
	RUBServiceFees        _codaEntity /* number [RUB Service fees] = [Invoice Ref].[Bank fees]+[Invoice Ref].[Rate error PM] */
	EURRounding           _codaEntity /* number [EUR Rounding] = [Invoice Ref].[Amount requested, EUR]-[Invoice Ref].[Requested subtotal, EUR] */
	AnnualUnpaidLeavesRUB _codaEntity /* number [Annual/unpaid leaves, RUB] = [Paid annual leaves Refs].[Total Correction, RUB].Sum() */
	AnnualContribsRUB     _codaEntity /* number [Annual Contribs, RUB] = [Invoice Ref].[Patent, RUB] + [Invoice Ref].[Taxes, RUB] */
	MonthlyContribsEUR    _codaEntity /* number [Monthly Contribs, EUR] = 0 */
	PublicHolidaysRefs    _codaEntity /* lookup [Public Holidays Refs] = [Invoice Ref].[Invoice Entries].Filter(Type.Type="Overtime Public Holiday") */
	PublicHolidaysRUB     _codaEntity /* number [Public holidays, RUB] = [Public Holidays Refs].[Total Correction, RUB].Sum() */
	OvertimesRefs         _codaEntity /* lookup [Overtimes Refs] = [Invoice Ref].[Invoice Entries].Filter(Type.Type="Overtime") */
	OvertimesRUB          _codaEntity /* number [Overtimes, RUB] = [Overtimes Refs].[Total Correction, RUB].Sum() */
	BonusesRefs           _codaEntity /* text [Bonuses Refs] = [Invoice Ref].[Invoice Entries].Filter(Type.Type.Contains("Performance bonus", "FO benefits", "Personal benefits")) */
	BonusesRUB            _codaEntity /* number [Bonuses, RUB] = [Bonuses Refs].[Total Correction, RUB].Sum() */
	LoansRefs             _codaEntity /* text [Loans Refs] = [Invoice Ref].[Invoice Entries].Filter(Type.Type="Loan") */
	LoansRUB              _codaEntity /* number [Loans, RUB] = [Loans Refs].[Total Correction, RUB].Sum() */
	SalaryChangesRefs     _codaEntity /* lookup [Salary changes Refs] = [Invoice Ref].[Invoice Entries].Filter(Type.Type="Salary change") */
	SalaryChangesRUB      _codaEntity /* number [Salary changes, RUB] = [Salary changes Refs].[Total Correction, RUB].Sum() */
	StartDayRefs          _codaEntity /* lookup [Start day Refs] = [Invoice Ref].[Invoice Entries].Filter(Type.Type="Start day") */
	StartDayRUB           _codaEntity /* number [Start day, RUB] = [Start day Refs].[Total Correction, RUB].Sum() */
	QuitCompensationsRefs _codaEntity /* lookup [Quit compensations Refs] = [Invoice Ref].[Invoice Entries].Filter(Type.Type="Quit") */
	QuitCompensationsRUB  _codaEntity /* number [Quit compensations, RUB] = [Quit compensations Refs].[Total Correction, RUB].Sum() */
	PaidAnnualLeavesRefs  _codaEntity /* lookup [Paid annual leaves Refs] = [Invoice Ref].[Invoice Entries].Filter(Type.Type="Annual leave") */
	RestCorrectionRefs    _codaEntity /* lookup [Rest correction Refs] = [Invoice Ref].[Invoice Entries].Filter(NOT(ListCombine([Public Holidays Refs], [Overtimes Refs], [Bonuses Refs], [Loans Refs], [Salary changes Refs], [Start day Refs], [Quit compensations Refs], [Paid annual leaves Refs]).Contains(CurrentValue))) */
	RestCorrectionsRUB    _codaEntity /* number [Rest corrections, RUB] = [Rest correction Refs].[Total Correction, RUB].Sum() */
}

// Table Headcount per location
type _headcountPerLocationTable struct {
	_codaEntity
	Cols _headcountPerLocationTableColumns
}
type _headcountPerLocationTableColumns struct {
	Location  _codaEntity /* lookup [Location] */
	Headcount _codaEntity /* number [Headcount] = [Current payroll v2].Filter(Location=Location).Count() */
}

// Table Suspicious rates
type _suspiciousRatesTable struct {
	_codaEntity
	Cols _suspiciousRatesTableColumns
}
type _suspiciousRatesTableColumns struct {
	Month          _codaEntity /* lookup [Month] */
	Employee       _codaEntity /* lookup [Employee] */
	EURRUBExpected _codaEntity /* number [EURRUB expected] */
	EURRUBActual   _codaEntity /* number [EURRUB actual] */
}

// Table Work days
type _workDaysTable struct {
	_codaEntity
	Cols _workDaysTableColumns
}
type _workDaysTableColumns struct {
	Month    _codaEntity /* lookup [Month] */
	WorkDays _codaEntity /* number [Work days] */
	Location _codaEntity /* lookup [Location] */
}

// Table Corrections by employee
type _correctionsByEmployeeTable struct {
	_codaEntity
	Cols _correctionsByEmployeeTableColumns
}
type _correctionsByEmployeeTableColumns struct {
	Type      _codaEntity /* lookup [Type] */
	Comment   _codaEntity /* text [Comment] */
	RUBAmount _codaEntity /* number [RUB Amount] */
	EURAmount _codaEntity /* number [EUR Amount] */
}

// Table Enter company rates for selected month
type _enterCompanyRatesForSelectedMonthTable struct {
	_codaEntity
	Cols _enterCompanyRatesForSelectedMonthTableColumns
}
type _enterCompanyRatesForSelectedMonthTableColumns struct {
	Month  _codaEntity /* lookup [Month] */
	EURRUB _codaEntity /* number [EURRUB] */
}

// Table Template Entries
type _templateEntriesTable struct {
	_codaEntity
	Cols _templateEntriesTableColumns
}
type _templateEntriesTableColumns struct {
	Employee   _codaEntity /* lookup [Employee] */
	MonthFrom  _codaEntity /* lookup [Month from] */
	MonthTo    _codaEntity /* lookup [Month to] */
	Type       _codaEntity /* lookup [Type] */
	Comment    _codaEntity /* text [Comment] */
	RUBAmount  _codaEntity /* number [RUB Amount] */
	EURAmount  _codaEntity /* number [EUR Amount] */
	ModifiedBy _codaEntity /* person [Modified by] = thisRow.ModifiedBy() */
	CreatedOn  _codaEntity /* dateTime [Created on] = thisRow.Created() */
	ModifiedOn _codaEntity /* dateTime [Modified on] = thisRow.Modified() */
	Display    _codaEntity /* text [Display] = List(
	  IF([RUB Amount], concatenate("₽", [RUB Amount]), ""),
	  IF([EUR Amount], concatenate("€", [EUR Amount]), ""),
	  Category.Type
	).Filter(CurrentValue.IsNotBlank()).Join(" ") */
	IncludedToNewInvoice _codaEntity /* checkbox [Included to new invoice] = ([Month from].IsBlank() OR newInvoiceMonth.Month >= [Month from].Month)
	 AND
	([Month to].IsBlank() OR newInvoiceMonth.Month <= [Month to].Month) */
}

// Table All employees names
type _allEmployeesNamesTable struct {
	_codaEntity
	Cols _allEmployeesNamesTableColumns
}
type _allEmployeesNamesTableColumns struct {
	Name      _codaEntity /* text [Name] */
	StartDate _codaEntity /* date [Start date] */
	Location  _codaEntity /* lookup [Location] */
}

// Table Bank details
type _bankDetailsTable struct {
	_codaEntity
	Cols _bankDetailsTableColumns
}
type _bankDetailsTableColumns struct {
	Employee        _codaEntity /* lookup [Employee] */
	Account         _codaEntity /* text [Account] */
	Address1        _codaEntity /* text [Address 1] */
	Address2        _codaEntity /* text [Address 2] */
	BeneficiaryBank _codaEntity /* lookup [Beneficiary Bank] */
	MonthFrom       _codaEntity /* lookup [Month from] */
	MonthTo         _codaEntity /* lookup [Month to] */
	ID              _codaEntity /* text [ID] = Format("({1:000}) {3} {2}", RowId(thisRow), Employee.Name, [Beneficiary Bank].Name) */
	Text            _codaEntity /* text [Text] = Length([Address 1]) + " / " + length([Address 2]) */
	BankRequisites  _codaEntity /* text [Bank requisites] */
}

// Table Beneficiary Bank
type _beneficiaryBankTable struct {
	_codaEntity
	Cols _beneficiaryBankTableColumns
}
type _beneficiaryBankTableColumns struct {
	Name              _codaEntity /* text [Name] */
	Address1          _codaEntity /* text [Address 1] */
	Address2          _codaEntity /* text [Address 2] */
	Address3          _codaEntity /* text [Address 3] */
	BeneficiarySWIFT  _codaEntity /* text [Beneficiary SWIFT] */
	IntermediarySWIFT _codaEntity /* text [Intermediary SWIFT] */
}

// Table Payroll Schedule
type _payrollScheduleTable struct {
	_codaEntity
	Cols _payrollScheduleTableColumns
}
type _payrollScheduleTableColumns struct {
	Month         _codaEntity /* lookup [Month] */
	ExecutionDate _codaEntity /* date [Execution date] */
}

// Table Pension Fund fixed
type _pensionFundFixedTable struct {
	_codaEntity
	Cols _pensionFundFixedTableColumns
}
type _pensionFundFixedTableColumns struct {
	Invoice               _codaEntity /* lookup [Invoice] */
	OpeningDateIP         _codaEntity /* date [Opening date IP] = Invoice.Employee.[Opening date IP] */
	PeriodStart           _codaEntity /* date [Period Start] = MAX(Date(Invoice.Month.Month.Year(), 1, 1), [Opening date IP]) */
	PeriodEnd             _codaEntity /* date [Period End] */
	AmountIPDays          _codaEntity /* number [Amount IP days] = [Period End]-[Period Start]+Days(1) */
	PensionFundFixedToPay _codaEntity /* number [Pension fund fixed - to pay] = ([Pension Fund fixed - total]/Year.[Calendar days in year])*[Amount IP days] */
	PensionFundFixedTotal _codaEntity /* number [Pension Fund fixed - total] = Year.[Pension fund fixed part] */
	Year                  _codaEntity /* lookup [Year] = [Tax years].Filter(Year=Invoice.Month.Year).First() */
	Apply                 _codaEntity /* button [Apply] */
}

// Table Social Insurance
type _socialInsuranceTable struct {
	_codaEntity
	Cols _socialInsuranceTableColumns
}
type _socialInsuranceTableColumns struct {
	Invoice              _codaEntity /* lookup [Invoice] */
	OpeningDateIP        _codaEntity /* date [Opening date IP] = Invoice.Employee.[Opening date IP] */
	PeriodStart          _codaEntity /* date [Period Start] = MAX(Date(Invoice.Month.Month.Year(), 1, 1), [Opening date IP]) */
	PeriodEnd            _codaEntity /* date [Period End] */
	AmountIPDays         _codaEntity /* number [Amount IP days] = [Period End]-[Period Start]+Days(1) */
	SocialInsuranceToPay _codaEntity /* number [Social Insurance - to pay] = ([Social Insurance - total]/Year.[Calendar days in year])*[Amount IP days] */
	SocialInsuranceTotal _codaEntity /* number [Social Insurance - total] = Year.[Social Insurance] */
	Year                 _codaEntity /* lookup [Year] = [Tax years].Filter(Year=Invoice.Month.Year).First() */
	Apply                _codaEntity /* button [Apply] */
}

// Table Pension fund percent
type _pensionFundPercentTable struct {
	_codaEntity
	Cols _pensionFundPercentTableColumns
}
type _pensionFundPercentTableColumns struct {
	Invoice            _codaEntity /* lookup [Invoice] */
	PensionFundPercent _codaEntity /* number [Pension fund percent] */
	Year               _codaEntity /* lookup [Year] = [Tax years].Filter(Year=Invoice.Month.Year).First() */
	Apply              _codaEntity /* button [Apply] */
}

// Table Per Day Calculations
type _perDayCalculationsTable struct {
	_codaEntity
	Cols _perDayCalculationsTableColumns
}
type _perDayCalculationsTableColumns struct {
	Type               _codaEntity /* lookup [Type] */
	NumberOfDays       _codaEntity /* number [Number of days] */
	CostOfDay          _codaEntity /* number [Cost of day] = Salary.[EUR Amount].IfBlank(Salary.[RUB Amount]) / [Work days].Filter(Location=[Payment invoice].Employee.Location AND Month=[Work period]).First().[Work days] */
	Total              _codaEntity /* number [Total] = RoundDown([Cost of day]*[Number of days]*Type.Coefficient, 2) */
	PaymentInvoice     _codaEntity /* lookup [Payment invoice] */
	SalaryPeriod       _codaEntity /* lookup [Salary period] */
	CalculationInvoice _codaEntity /* lookup [Calculation invoice] = Invoice.Filter(Employee=[Payment invoice].Employee AND Month=[Calculation period]).First() */
	Salary             _codaEntity /* lookup [Salary] = [Calculation invoice].[Invoice Entries].Filter(Type=[Base salary]).First() */
	Apply              _codaEntity /* button [Apply] */
	WorkPeriod         _codaEntity /* lookup [Work period] */
}

// Table Per Day Policies
type _perDayPoliciesTable struct {
	_codaEntity
	Cols _perDayPoliciesTableColumns
}
type _perDayPoliciesTableColumns struct {
	Name        _codaEntity /* text [Name] */
	Coefficient _codaEntity /* number [Coefficient] */
	EntryType   _codaEntity /* lookup [Entry Type] */
}

// Table Salaries
type _salariesTable struct {
	_codaEntity
	Cols _salariesTableColumns
}
type _salariesTableColumns struct {
	Employee  _codaEntity /* lookup [Employee] */
	MonthFrom _codaEntity /* lookup [Month from] */
	MonthTo   _codaEntity /* lookup [Month to] */
	Comment   _codaEntity /* text [Comment] */
	RUBAmount _codaEntity /* number [RUB Amount] */
	EURAmount _codaEntity /* number [EUR Amount] */
}

// Table Payable employees
type _payableEmployeesTable struct {
	_codaEntity
	Cols _payableEmployeesTableColumns
}
type _payableEmployeesTableColumns struct {
	Employee           _codaEntity /* lookup [Employee] */
	BonusQuarter       _codaEntity /* button [Bonus Quarter] */
	TargetInvoice      _codaEntity /* lookup [Target invoice] = Invoice.Filter(Month=newInvoiceMonth AND Employee=Employee).First() */
	AddAny             _codaEntity /* button [Add any] */
	FlexBenefit        _codaEntity /* button [Flex benefit] */
	SelfEmplTax        _codaEntity /* button [Self-Empl Tax] */
	IE6PercentTax      _codaEntity /* button [IE 6% Tax] */
	ManualEntries      _codaEntity /* lookup [Manual Entries] = [Target invoice].[Invoice Entries].Filter(NOT([Excluded Entry Types].Contains(CurrentValue.Type))) */
	ExcludedEntryTypes _codaEntity /* text [Excluded Entry Types] = [Entry Type]
	.Filter(
	  List(
	    "Bank service tariff",
	    "Base salary",
	    "Return of rounding",
	    "Rate error compensation"
	  )
	    .Contains(
	      Type
	    )
	) */
	PayableNow         _codaEntity /* checkbox [Payable now] = Employee.[Working now?] AND NOT([Exclude from payment]) */
	ExcludeFromPayment _codaEntity /* checkbox [Exclude from payment] */
}

// Table Quick Manual Entry
type _quickManualEntryTable struct {
	_codaEntity
	Cols _quickManualEntryTableColumns
}
type _quickManualEntryTableColumns struct {
	TargetInvoice _codaEntity /* lookup [Target invoice] = Invoice.Filter(Month=newInvoiceMonth AND Employee=Employee).First() */
	ManualEntries _codaEntity /* lookup [Manual Entries] = [Target invoice].[Invoice Entries].Filter(NOT([Excluded Entry Types].Contains(CurrentValue.Type))) */
	AddAny        _codaEntity /* button [Add any] */
	BonusQuarter  _codaEntity /* button [Bonus Quarter] */
	FlexBenefit   _codaEntity /* button [Flex benefit] */
	SelfEmplTax   _codaEntity /* button [Self-Empl Tax] */
	IE6PercentTax _codaEntity /* button [IE 6% Tax] */
}

// Table New invoice entries per type
type _newInvoiceEntriesPerTypeTable struct {
	_codaEntity
	Cols _newInvoiceEntriesPerTypeTableColumns
}
type _newInvoiceEntriesPerTypeTableColumns struct {
	Invoice   _codaEntity /* lookup [Invoice] */
	Type      _codaEntity /* lookup [Type] */
	RUBAmount _codaEntity /* number [RUB Amount] */
	EURAmount _codaEntity /* number [EUR Amount] */
	Comment   _codaEntity /* text [Comment] */
}

// Table Entries per date and type
type _entriesPerDateAndTypeTable struct {
	_codaEntity
	Cols _entriesPerDateAndTypeTableColumns
}
type _entriesPerDateAndTypeTableColumns struct {
	Invoice   _codaEntity /* lookup [Invoice] */
	Type      _codaEntity /* lookup [Type] */
	RUBAmount _codaEntity /* number [RUB Amount] */
	EURAmount _codaEntity /* number [EUR Amount] */
	Comment   _codaEntity /* text [Comment] */
	Month     _codaEntity /* lookup [Month] = Invoice.Month */
}

// Table Add new employee
type _addNewEmployeeTable struct {
	_codaEntity
	Cols _addNewEmployeeTableColumns
}
type _addNewEmployeeTableColumns struct {
	Name                 _codaEntity /* text [Name] */
	LegalForm            _codaEntity /* select [Legal form] */
	StartDate            _codaEntity /* date [Start date] */
	EndDate              _codaEntity /* date [End date] */
	ContractDate         _codaEntity /* text [Contract Date] */
	ContractNumber       _codaEntity /* text [Contract Number] */
	Location             _codaEntity /* lookup [Location] */
	LegalEntity          _codaEntity /* lookup [Legal entity] */
	OpeningDateIP        _codaEntity /* date [Opening date IP] */
	BankDetails          _codaEntity /* lookup [Bank details] */
	GeneralSD            _codaEntity /* text [General SD] */
	FinanceSD            _codaEntity /* text [Finance SD] */
	BankTariff           _codaEntity /* lookup [Bank tariff] */
	ContractHourRate     _codaEntity /* number [Contract hour rate] */
	Rounding             _codaEntity /* number [Rounding] */
	EnglishFullName      _codaEntity /* text [English full name] */
	SpecialPaymentPolicy _codaEntity /* checkbox [Special payment policy] */
	WorkingNow           _codaEntity /* checkbox [Working now?] = NOT([End date]) OR [End date] >= Today() */
	Valid                _codaEntity /* checkbox [Valid?] = AND([Required fields].FormulaMap(CurrentValue.First())) */
	InvalidFields        _codaEntity /* text [Invalid fields] = [Required fields].Filter(If(Not(CurrentValue.First()), CurrentValue.Last(), false())).FormulaMap(CurrentValue.Last()) */
}

// Table Current template entries
type _currentTemplateEntriesTable struct {
	_codaEntity
	Cols _currentTemplateEntriesTableColumns
}
type _currentTemplateEntriesTableColumns struct {
	Employee  _codaEntity /* lookup [Employee] */
	MonthFrom _codaEntity /* lookup [Month from] */
	MonthTo   _codaEntity /* lookup [Month to] */
	Type      _codaEntity /* lookup [Type] */
	RUBAmount _codaEntity /* number [RUB Amount] */
	EURAmount _codaEntity /* number [EUR Amount] */
	Comment   _codaEntity /* text [Comment] */
}

// Table Template entries months filtering
type _templateEntriesMonthsFilteringTable struct {
	_codaEntity
	Cols _templateEntriesMonthsFilteringTableColumns
}
type _templateEntriesMonthsFilteringTableColumns struct {
	Month                                                                                                             _codaEntity /* lookup [Month] */
	FormatTypeButtonTextTypeSlateRootChildrenAlignmentLeftChildrenTextFrom202112IdCl0LineLevel0StyleParagraphTypeLine _codaEntity /* button [{"formatType":"button","text":{"type":"slate","root":{"children":[{"alignment":"Left","children":[{"text":"From 2021-12"}],"id":"cl-0","lineLevel":0,"style":"Paragraph","type":"Line"}]}}}] */
	FormatTypeButtonTextTypeSlateRootChildrenAlignmentLeftChildrenTextTo202112IdCl0LineLevel0StyleParagraphTypeLine   _codaEntity /* button [{"formatType":"button","text":{"type":"slate","root":{"children":[{"alignment":"Left","children":[{"text":"To 2021-12"}],"id":"cl-0","lineLevel":0,"style":"Paragraph","type":"Line"}]}}}] */
	FromValue                                                                                                         _codaEntity /* checkbox [From value] */
	ToValue                                                                                                           _codaEntity /* checkbox [To value] */
	Button                                                                                                            _codaEntity /* button [Button] */
}

// Table Template entries type filtering
type _templateEntriesTypeFilteringTable struct {
	_codaEntity
	Cols _templateEntriesTypeFilteringTableColumns
}
type _templateEntriesTypeFilteringTableColumns struct {
	Type          _codaEntity /* lookup [Type] */
	FilteringType _codaEntity /* lookup [Filtering Type] */
	OnlyBtn       _codaEntity /* button [Only Btn] */
	InclBtn       _codaEntity /* button [Incl Btn] */
	ExclBtn       _codaEntity /* button [Excl Btn] */
}

// Table Entries months filtering
type _entriesMonthsFilteringTable struct {
	_codaEntity
	Cols _entriesMonthsFilteringTableColumns
}
type _entriesMonthsFilteringTableColumns struct {
	Month                                                                                                             _codaEntity /* lookup [Month] */
	FormatTypeButtonTextTypeSlateRootChildrenAlignmentLeftChildrenTextFrom202112IdCl0LineLevel0StyleParagraphTypeLine _codaEntity /* button [{"formatType":"button","text":{"type":"slate","root":{"children":[{"alignment":"Left","children":[{"text":"From 2021-12"}],"id":"cl-0","lineLevel":0,"style":"Paragraph","type":"Line"}]}}}] */
	FormatTypeButtonTextTypeSlateRootChildrenAlignmentLeftChildrenTextTo202112IdCl0LineLevel0StyleParagraphTypeLine   _codaEntity /* button [{"formatType":"button","text":{"type":"slate","root":{"children":[{"alignment":"Left","children":[{"text":"To 2021-12"}],"id":"cl-0","lineLevel":0,"style":"Paragraph","type":"Line"}]}}}] */
	FromValue                                                                                                         _codaEntity /* checkbox [From value] */
	ToValue                                                                                                           _codaEntity /* checkbox [To value] */
	Button                                                                                                            _codaEntity /* button [Button] */
}

// Table Entries type filtering
type _entriesTypeFilteringTable struct {
	_codaEntity
	Cols _entriesTypeFilteringTableColumns
}
type _entriesTypeFilteringTableColumns struct {
	Type          _codaEntity /* lookup [Type] */
	FilteringType _codaEntity /* lookup [Filtering Type] */
	OnlyBtn       _codaEntity /* button [Only Btn] */
	InclBtn       _codaEntity /* button [Incl Btn] */
	ExclBtn       _codaEntity /* button [Excl Btn] */
}

// Table Filtered Entries
type _filteredEntriesTable struct {
	_codaEntity
	Cols _filteredEntriesTableColumns
}
type _filteredEntriesTableColumns struct {
	Invoice   _codaEntity /* lookup [Invoice] */
	Type      _codaEntity /* lookup [Type] */
	RUBAmount _codaEntity /* number [RUB Amount] */
	EURAmount _codaEntity /* number [EUR Amount] */
	Comment   _codaEntity /* text [Comment] */
}

// Table Add company rate
type _addCompanyRateTable struct {
	_codaEntity
	Cols _addCompanyRateTableColumns
}
type _addCompanyRateTableColumns struct {
	Month  _codaEntity /* lookup [Month] */
	EURRUB _codaEntity /* number [EURRUB] */
}

// Table TEST TABLE
type _tESTTABLETable struct {
	_codaEntity
	Cols _tESTTABLETableColumns
}
type _tESTTABLETableColumns struct {
	Name     _codaEntity /* number [Name] */
	Column2  _codaEntity /* attachments [Column 2] */
	Column3  _codaEntity /* reaction [Column 3] */
	Duration _codaEntity /* duration [Duration] */
	Currency _codaEntity /* currency [Currency] */
	Email    _codaEntity /* text [email?] */
	Slider   _codaEntity /* slider [Slider] */
	Percent  _codaEntity /* percent [Percent] */
	Scale    _codaEntity /* scale [Scale] */
	People   _codaEntity /* person [People] */
	Date     _codaEntity /* date [Date] */
	DateTime _codaEntity /* dateTime [DateTime] */
	Time     _codaEntity /* time [Time] */
}

//endregion

var ID = _schema{
	Table: _tableSchema{
		AllEmployees: _allEmployeesTable{
			_codaEntity: _codaEntity{
				ID:   `grid-TGESBHJkVA`,
				Name: `All employees`,
			},
			Cols: _allEmployeesTableColumns{
				Name: _codaEntity{
					ID:   `c-tCDt6yt4Ix`,
					Name: `Name`,
				},
				StartDate: _codaEntity{
					ID:   `c-Zs7oQbj-_J`,
					Name: `Start date`,
				},
				EndDate: _codaEntity{
					ID:   `c-7OoHuXqt8n`,
					Name: `End date`,
				},
				ContractHourRate: _codaEntity{
					ID:   `c-SItGvyE3ie`,
					Name: `Contract hour rate`,
				},
				OpeningDateIP: _codaEntity{
					ID:   `c-uU3-6piESs`,
					Name: `Opening date IP`,
				},
				WorkingNow: _codaEntity{
					ID:   `c-QfV5QzjuJP`,
					Name: `Working now?`,
				},
				EnglishFullName: _codaEntity{
					ID:   `c-TAlfzDcFzQ`,
					Name: `English full name`,
				},
				LegalEntity: _codaEntity{
					ID:   `c-smk4a68He5`,
					Name: `Legal entity`,
				},
				Location: _codaEntity{
					ID:   `c-WcmDQXPChx`,
					Name: `Location`,
				},
				FinanceSD: _codaEntity{
					ID:   `c-NeQmHu-raB`,
					Name: `Finance SD`,
				},
				GeneralSD: _codaEntity{
					ID:   `c-EMbqnhOkkr`,
					Name: `General SD`,
				},
				ContractNumber: _codaEntity{
					ID:   `c-XX2OkCkOSR`,
					Name: `Contract Number`,
				},
				ContractDate: _codaEntity{
					ID:   `c-fDIRo1JHHX`,
					Name: `Contract Date`,
				},
				LegalForm: _codaEntity{
					ID:   `c-w8WTgIbQ7H`,
					Name: `Legal form`,
				},
				BankTariff: _codaEntity{
					ID:   `c-Hx-nCcWt2v`,
					Name: `Bank tariff`,
				},
				Rounding: _codaEntity{
					ID:   `c-xvCHSSPdHb`,
					Name: `Rounding`,
				},
				BankDetails: _codaEntity{
					ID:   `c-wSSi6yT6d4`,
					Name: `Bank details`,
				},
				SpecialPaymentPolicy: _codaEntity{
					ID:   `c-FOuDAl0Fmk`,
					Name: `Special payment policy`,
				},
				RequiredFields: _codaEntity{
					ID:   `c-WZcnszI0Rm`,
					Name: `Required fields`,
				},
				Valid: _codaEntity{
					ID:   `c-0pE57fQdnw`,
					Name: `Valid?`,
				},
				InvalidFields: _codaEntity{
					ID:   `c-9NyvCfUrkk`,
					Name: `Invalid fields`,
				},
			},
		},
		Invoice: _invoiceTable{
			_codaEntity: _codaEntity{
				ID:   `grid-Wdy6Agpxou`,
				Name: `Invoice`,
			},
			Cols: _invoiceTableColumns{
				ID: _codaEntity{
					ID:   `c-bZ_nLfZufG`,
					Name: `ID`,
				},
				InvoiceHash: _codaEntity{
					ID:   `c-eJ2e_cRCaM`,
					Name: `Invoice #`,
				},
				Month: _codaEntity{
					ID:   `c-wR0IONcxGH`,
					Name: `Month`,
				},
				Employee: _codaEntity{
					ID:   `c-bbHUhqlbfN`,
					Name: `Employee`,
				},
				PreviousInvoice: _codaEntity{
					ID:   `c-FQ7rKmbXr6`,
					Name: `Previous invoice`,
				},
				EURRUBExpected: _codaEntity{
					ID:   `c-tvtGu9juVL`,
					Name: `EURRUB expected`,
				},
				EURSubtotal: _codaEntity{
					ID:   `c-9rnJJZ6gA7`,
					Name: `EUR Subtotal`,
				},
				EURRounding: _codaEntity{
					ID:   `c-Tri-EGUP_n`,
					Name: `EUR Rounding`,
				},
				EUREntries: _codaEntity{
					ID:   `c-bJpHVxywXD`,
					Name: `EUR Entries`,
				},
				Hours: _codaEntity{
					ID:   `c-KtVV9if8P7`,
					Name: `Hours`,
				},
				EURRUBActual: _codaEntity{
					ID:   `c-kLIyv9EvyH`,
					Name: `EURRUB actual`,
				},
				RUBActual: _codaEntity{
					ID:   `c-AxLSgrt7e3`,
					Name: `RUB Actual`,
				},
				RUBRateError: _codaEntity{
					ID:   `c-SsHRhKa_uC`,
					Name: `RUB Rate Error`,
				},
				InvoiceEntries: _codaEntity{
					ID:   `c-tpeCMU21_I`,
					Name: `Invoice Entries`,
				},
				RUBEntries: _codaEntity{
					ID:   `c-jNcl4nZe_h`,
					Name: `RUB Entries`,
				},
				PaymentChecksPassed: _codaEntity{
					ID:   `c-DRPGK3XTmD`,
					Name: `Payment Checks Passed`,
				},
				TemplatesRefs: _codaEntity{
					ID:   `c-esVje33Tt-`,
					Name: `Templates Refs`,
				},
				RecipientDetails: _codaEntity{
					ID:   `c-2TxWM7vHls`,
					Name: `Recipient details`,
				},
				EURTotal: _codaEntity{
					ID:   `c-Y5fNzlzJXF`,
					Name: `EUR Total`,
				},
				ApprovedManually: _codaEntity{
					ID:   `c-9Zy6wPmcmR`,
					Name: `Approved manually?`,
				},
				SenderDetails: _codaEntity{
					ID:   `c-GT8GvOJE1C`,
					Name: `Sender details`,
				},
				RUBTotal: _codaEntity{
					ID:   `c-WWb4V9ETtt`,
					Name: `RUB Total`,
				},
				HourRate: _codaEntity{
					ID:   `c-BXmgrJUyUd`,
					Name: `Hour Rate`,
				},
				WorkDays: _codaEntity{
					ID:   `c-ovkSZVew-L`,
					Name: `Work days`,
				},
				ContractDate: _codaEntity{
					ID:   `c-keT0IA7CqE`,
					Name: `Contract Date`,
				},
				ContractNumber: _codaEntity{
					ID:   `c-QntkvMYxT-`,
					Name: `Contract Number`,
				},
				Checks: _codaEntity{
					ID:   `c-U-pf-wsryV`,
					Name: `Checks`,
				},
				Alerts: _codaEntity{
					ID:   `c-RhKiOX-0y7`,
					Name: `Alerts`,
				},
			},
		},
		Months: _monthsTable{
			_codaEntity: _codaEntity{
				ID:   `grid-laH8qsdDyP`,
				Name: `Months`,
			},
			Cols: _monthsTableColumns{
				Month: _codaEntity{
					ID:   `c-u_Pgrgevw7`,
					Name: `Month`,
				},
				Year: _codaEntity{
					ID:   `c-NgPwXZshJM`,
					Name: `Year`,
				},
				ID: _codaEntity{
					ID:   `c-iRCjZ0JBcM`,
					Name: `ID`,
				},
				PreviousMonthLink: _codaEntity{
					ID:   `c-3Cc_lYdvmW`,
					Name: `Previous month Link`,
				},
				PreviousMonth: _codaEntity{
					ID:   `c-vuW159vf-o`,
					Name: `Previous month`,
				},
				Current: _codaEntity{
					ID:   `c-OLxcAJLQoW`,
					Name: `Current?`,
				},
				Near: _codaEntity{
					ID:   `c-2MiYICcxrc`,
					Name: `Near?`,
				},
				Future: _codaEntity{
					ID:   `c-16wzVYB6nB`,
					Name: `Future?`,
				},
				Upcoming: _codaEntity{
					ID:   `c-PQzLA1gRk1`,
					Name: `Upcoming?`,
				},
			},
		},
		Entries: _entriesTable{
			_codaEntity: _codaEntity{
				ID:   `grid-wBmvgFgaGi`,
				Name: `Entries`,
			},
			Cols: _entriesTableColumns{
				Comment: _codaEntity{
					ID:   `c--_r48PQnSn`,
					Name: `Comment`,
				},
				EURAmount: _codaEntity{
					ID:   `c-pRmEece9pf`,
					Name: `EUR Amount`,
				},
				RUBAmount: _codaEntity{
					ID:   `c-P2x5IJuMXN`,
					Name: `RUB Amount`,
				},
				Invoice: _codaEntity{
					ID:   `c-7SU0iOBY9J`,
					Name: `Invoice`,
				},
				Display: _codaEntity{
					ID:   `c-FVW_9PPzZ2`,
					Name: `Display`,
				},
				Type: _codaEntity{
					ID:   `c-zDY58PF0P6`,
					Name: `Type`,
				},
				ModifiedOn: _codaEntity{
					ID:   `c-7HSE88Op0l`,
					Name: `Modified on`,
				},
				CreatedOn: _codaEntity{
					ID:   `c-pKkFDJQXHe`,
					Name: `Created on`,
				},
				Origin: _codaEntity{
					ID:   `c-aJp16HyPKx`,
					Name: `Origin`,
				},
				ModifiedBy: _codaEntity{
					ID:   `c-VwCxsKPCnl`,
					Name: `Modified by`,
				},
				Sort: _codaEntity{
					ID:   `c-7rE4nrnOXc`,
					Name: `Sort`,
				},
				RUBAmountInEUR: _codaEntity{
					ID:   `c-jVyYfeGaZ8`,
					Name: `RUB Amount in EUR`,
				},
				Month: _codaEntity{
					ID:   `c-Mj8CH9hJ_A`,
					Name: `Month`,
				},
			},
		},
		WorkingEmployees: _workingEmployeesTable{
			_codaEntity: _codaEntity{
				ID:   `table-XbyycGwUU0`,
				Name: `Working Employees`,
			},
			Cols: _workingEmployeesTableColumns{
				Name: _codaEntity{
					ID:   `c-tCDt6yt4Ix`,
					Name: `Name`,
				},
				StartDate: _codaEntity{
					ID:   `c-Zs7oQbj-_J`,
					Name: `Start date`,
				},
				GeneralSD: _codaEntity{
					ID:   `c-EMbqnhOkkr`,
					Name: `General SD`,
				},
				FinanceSD: _codaEntity{
					ID:   `c-NeQmHu-raB`,
					Name: `Finance SD`,
				},
				Location: _codaEntity{
					ID:   `c-WcmDQXPChx`,
					Name: `Location`,
				},
				LegalEntity: _codaEntity{
					ID:   `c-smk4a68He5`,
					Name: `Legal entity`,
				},
				LegalForm: _codaEntity{
					ID:   `c-w8WTgIbQ7H`,
					Name: `Legal form`,
				},
				BankTariff: _codaEntity{
					ID:   `c-Hx-nCcWt2v`,
					Name: `Bank tariff`,
				},
				SpecialPaymentPolicy: _codaEntity{
					ID:   `c-FOuDAl0Fmk`,
					Name: `Special payment policy`,
				},
				EnglishFullName: _codaEntity{
					ID:   `c-TAlfzDcFzQ`,
					Name: `English full name`,
				},
				ContractNumber: _codaEntity{
					ID:   `c-XX2OkCkOSR`,
					Name: `Contract Number`,
				},
				ContractDate: _codaEntity{
					ID:   `c-fDIRo1JHHX`,
					Name: `Contract Date`,
				},
				BankDetails: _codaEntity{
					ID:   `c-wSSi6yT6d4`,
					Name: `Bank details`,
				},
			},
		},
		WorkingEmployeesNames: _workingEmployeesNamesTable{
			_codaEntity: _codaEntity{
				ID:   `table-dAwpX0i58t`,
				Name: `Working employees names`,
			},
			Cols: _workingEmployeesNamesTableColumns{
				Name: _codaEntity{
					ID:   `c-tCDt6yt4Ix`,
					Name: `Name`,
				},
				StartDate: _codaEntity{
					ID:   `c-Zs7oQbj-_J`,
					Name: `Start date`,
				},
				Location: _codaEntity{
					ID:   `c-WcmDQXPChx`,
					Name: `Location`,
				},
			},
		},
		InvoicesOverview: _invoicesOverviewTable{
			_codaEntity: _codaEntity{
				ID:   `table-_k4m2krdyp`,
				Name: `Invoices overview`,
			},
			Cols: _invoicesOverviewTableColumns{
				Employee: _codaEntity{
					ID:   `c-bbHUhqlbfN`,
					Name: `Employee`,
				},
				Month: _codaEntity{
					ID:   `c-wR0IONcxGH`,
					Name: `Month`,
				},
				PaymentChecksPassed: _codaEntity{
					ID:   `c-DRPGK3XTmD`,
					Name: `Payment Checks Passed`,
				},
				RUBEntries: _codaEntity{
					ID:   `c-jNcl4nZe_h`,
					Name: `RUB Entries`,
				},
				InvoiceEntries: _codaEntity{
					ID:   `c-tpeCMU21_I`,
					Name: `Invoice Entries`,
				},
				EURRUBExpected: _codaEntity{
					ID:   `c-tvtGu9juVL`,
					Name: `EURRUB expected`,
				},
				EURRUBActual: _codaEntity{
					ID:   `c-kLIyv9EvyH`,
					Name: `EURRUB actual`,
				},
				EURSubtotal: _codaEntity{
					ID:   `c-9rnJJZ6gA7`,
					Name: `EUR Subtotal`,
				},
				EURRounding: _codaEntity{
					ID:   `c-Tri-EGUP_n`,
					Name: `EUR Rounding`,
				},
				EUREntries: _codaEntity{
					ID:   `c-bJpHVxywXD`,
					Name: `EUR Entries`,
				},
				RUBRateError: _codaEntity{
					ID:   `c-SsHRhKa_uC`,
					Name: `RUB Rate Error`,
				},
				RecipientDetails: _codaEntity{
					ID:   `c-2TxWM7vHls`,
					Name: `Recipient details`,
				},
			},
		},
		PatentCompensation: _patentCompensationTable{
			_codaEntity: _codaEntity{
				ID:   `grid-_IJllxLQCt`,
				Name: `Patent compensation`,
			},
			Cols: _patentCompensationTableColumns{
				PaymentInvoice: _codaEntity{
					ID:   `c-sYkd0N-9Ef`,
					Name: `Payment Invoice`,
				},
				PeriodCost: _codaEntity{
					ID:   `c-FlQQoKxoau`,
					Name: `Period cost`,
				},
				Period: _codaEntity{
					ID:   `c-gtV-Qz9osQ`,
					Name: `Period`,
				},
				PeriodCostOverride: _codaEntity{
					ID:   `c-iR7HKVaAvK`,
					Name: `Period cost override`,
				},
				EmployeePatentRef: _codaEntity{
					ID:   `c-oRFcL19X2d`,
					Name: `Employee patent ref`,
				},
				Apply: _codaEntity{
					ID:   `c-SVnSxLqAWW`,
					Name: `Apply`,
				},
			},
		},
		EntryType: _entryTypeTable{
			_codaEntity: _codaEntity{
				ID:   `grid-ZQydbIU73l`,
				Name: `Entry Type`,
			},
			Cols: _entryTypeTableColumns{
				Type: _codaEntity{
					ID:   `c-2AJbX_XNUx`,
					Name: `Type`,
				},
				Comment: _codaEntity{
					ID:   `c-y50vUFEVml`,
					Name: `Comment`,
				},
				Archetype: _codaEntity{
					ID:   `c-2C7Vno33Ui`,
					Name: `Archetype`,
				},
				Sort: _codaEntity{
					ID:   `c-YN77WP5gru`,
					Name: `Sort`,
				},
			},
		},
		PatentsOverview: _patentsOverviewTable{
			_codaEntity: _codaEntity{
				ID:   `table-n2aIqJxO80`,
				Name: `Patents overview`,
			},
			Cols: _patentsOverviewTableColumns{
				PaymentInvoice: _codaEntity{
					ID:   `c-sYkd0N-9Ef`,
					Name: `Payment Invoice`,
				},
				PeriodCost: _codaEntity{
					ID:   `c-FlQQoKxoau`,
					Name: `Period cost`,
				},
				Period: _codaEntity{
					ID:   `c-gtV-Qz9osQ`,
					Name: `Period`,
				},
			},
		},
		LegalEntity: _legalEntityTable{
			_codaEntity: _codaEntity{
				ID:   `grid--dTms1XC6V`,
				Name: `Legal entity`,
			},
			Cols: _legalEntityTableColumns{
				EntityName: _codaEntity{
					ID:   `c-oDFd1kjV93`,
					Name: `Entity name`,
				},
				Requisites: _codaEntity{
					ID:   `c-5_sQbo5eww`,
					Name: `Requisites`,
				},
				Taxable: _codaEntity{
					ID:   `c-zCN8KuAI7k`,
					Name: `Taxable`,
				},
				OfficialName: _codaEntity{
					ID:   `c-eQsvF9_gTl`,
					Name: `Official name`,
				},
				AccountNumber: _codaEntity{
					ID:   `c-TJFRqfWIGm`,
					Name: `Account number`,
				},
			},
		},
		SalariesReport: _salariesReportTable{
			_codaEntity: _codaEntity{
				ID:   `table-R_NoGmR2fn`,
				Name: `Salaries report`,
			},
			Cols: _salariesReportTableColumns{
				Name: _codaEntity{
					ID:   `c-tCDt6yt4Ix`,
					Name: `Name`,
				},
				StartDate: _codaEntity{
					ID:   `c-Zs7oQbj-_J`,
					Name: `Start date`,
				},
			},
		},
		TaxYears: _taxYearsTable{
			_codaEntity: _codaEntity{
				ID:   `grid-LkqRfNkkB1`,
				Name: `Tax years`,
			},
			Cols: _taxYearsTableColumns{
				Year: _codaEntity{
					ID:   `c-EUuXlrh2Gj`,
					Name: `Year`,
				},
				PensionFundFixedPart: _codaEntity{
					ID:   `c-M2knIRBSqf`,
					Name: `Pension fund fixed part`,
				},
				SocialInsurance: _codaEntity{
					ID:   `c-eXc5b__5KI`,
					Name: `Social Insurance`,
				},
				IsCurrent: _codaEntity{
					ID:   `c--uAVz6AZiI`,
					Name: `Is Current`,
				},
				PensionFundPercentPart: _codaEntity{
					ID:   `c-o6tcH5VWM9`,
					Name: `Pension fund percent part`,
				},
				CalendarDaysInYear: _codaEntity{
					ID:   `c-xwHL0_a7ec`,
					Name: `Calendar days in year`,
				},
			},
		},
		EmployeePatents: _employeePatentsTable{
			_codaEntity: _codaEntity{
				ID:   `grid-EdCa9AeMSn`,
				Name: `Employee Patents`,
			},
			Cols: _employeePatentsTableColumns{
				Employee: _codaEntity{
					ID:   `c-_hIvEH4-wm`,
					Name: `Employee`,
				},
				Year: _codaEntity{
					ID:   `c-6NwC6fSqJ8`,
					Name: `Year`,
				},
				Cost: _codaEntity{
					ID:   `c-GJiM8dKB7D`,
					Name: `Cost`,
				},
				Scan: _codaEntity{
					ID:   `c-bSYBkB-1xD`,
					Name: `Scan`,
				},
				Date1: _codaEntity{
					ID:   `c-GMiD_fuAfh`,
					Name: `Date 1`,
				},
				Date1Payment: _codaEntity{
					ID:   `c-bURhTzifbl`,
					Name: `Date 1 Payment`,
				},
				Date2: _codaEntity{
					ID:   `c-xE6fWWIcul`,
					Name: `Date 2`,
				},
				Date2Payment: _codaEntity{
					ID:   `c-a7_3Kkjsfx`,
					Name: `Date 2 Payment`,
				},
				Display: _codaEntity{
					ID:   `c-Elg3MNoRYd`,
					Name: `Display`,
				},
			},
		},
		FullPayrollReport: _fullPayrollReportTable{
			_codaEntity: _codaEntity{
				ID:   `grid-qJKfU6FFmW`,
				Name: `Full payroll report`,
			},
			Cols: _fullPayrollReportTableColumns{
				SalaryNet: _codaEntity{
					ID:   `c-XQPSD9vAg8`,
					Name: `Salary Net`,
				},
				InvoiceRef: _codaEntity{
					ID:   `c-h-RzL2yXWh`,
					Name: `Invoice Ref`,
				},
				OvertimesRefs: _codaEntity{
					ID:   `c-NYgI7ALlUW`,
					Name: `Overtimes Refs`,
				},
				OvertimesRUB: _codaEntity{
					ID:   `c-t2MioXrUCp`,
					Name: `Overtimes, RUB`,
				},
				BonusesRefs: _codaEntity{
					ID:   `c-EEUaWatwxL`,
					Name: `Bonuses Refs`,
				},
				BonusesRUB: _codaEntity{
					ID:   `c-xt7ILGpLk4`,
					Name: `Bonuses, RUB`,
				},
				PublicHolidaysRefs: _codaEntity{
					ID:   `c--dFWXSXlSs`,
					Name: `Public Holidays Refs`,
				},
				PublicHolidaysRUB: _codaEntity{
					ID:   `c-bW1uokxXyQ`,
					Name: `Public holidays, RUB`,
				},
				RestCorrectionRefs: _codaEntity{
					ID:   `c-Lh_T0xuy8D`,
					Name: `Rest correction Refs`,
				},
				RestCorrectionsRUB: _codaEntity{
					ID:   `c-fwWdBxz5_G`,
					Name: `Rest corrections, RUB`,
				},
				AnnualContribsRUB: _codaEntity{
					ID:   `c-RtpNgfxxJH`,
					Name: `Annual Contribs, RUB`,
				},
				StartDayRefs: _codaEntity{
					ID:   `c-7n5ATW-ITP`,
					Name: `Start day Refs`,
				},
				StartDayRUB: _codaEntity{
					ID:   `c-mSFM6hiUeA`,
					Name: `Start day, RUB`,
				},
				SalaryChangesRefs: _codaEntity{
					ID:   `c-y0SWuMDsBH`,
					Name: `Salary changes Refs`,
				},
				SalaryChangesRUB: _codaEntity{
					ID:   `c-ZY9kZCN7ap`,
					Name: `Salary changes, RUB`,
				},
				LoansRefs: _codaEntity{
					ID:   `c-X4bSWDyr-G`,
					Name: `Loans Refs`,
				},
				LoansRUB: _codaEntity{
					ID:   `c-0yn_hfYsmz`,
					Name: `Loans, RUB`,
				},
				RUBServiceFees: _codaEntity{
					ID:   `c-ixLJinrV3u`,
					Name: `RUB Service fees`,
				},
				EURRounding: _codaEntity{
					ID:   `c-vugGgAGBr1`,
					Name: `EUR Rounding`,
				},
				AnnualUnpaidLeavesRUB: _codaEntity{
					ID:   `c-Uo4x06gCTd`,
					Name: `Annual/unpaid leaves, RUB`,
				},
				MonthlyContribsEUR: _codaEntity{
					ID:   `c-wZKc8T-kxa`,
					Name: `Monthly Contribs, EUR`,
				},
				QuitCompensationsRefs: _codaEntity{
					ID:   `c-mGpqcoJnCA`,
					Name: `Quit compensations Refs`,
				},
				QuitCompensationsRUB: _codaEntity{
					ID:   `c-vF3Bj7iDMb`,
					Name: `Quit compensations, RUB`,
				},
				PaidAnnualLeavesRefs: _codaEntity{
					ID:   `c-PsqZc5nM7T`,
					Name: `Paid annual leaves Refs`,
				},
				Location: _codaEntity{
					ID:   `c-R61qZWF4OL`,
					Name: `Location`,
				},
			},
		},
		EmptyActualRates: _emptyActualRatesTable{
			_codaEntity: _codaEntity{
				ID:   `table-7A_oBrrTkt`,
				Name: `Empty actual rates`,
			},
			Cols: _emptyActualRatesTableColumns{
				Month: _codaEntity{
					ID:   `c-wR0IONcxGH`,
					Name: `Month`,
				},
				Employee: _codaEntity{
					ID:   `c-bbHUhqlbfN`,
					Name: `Employee`,
				},
				EURRUBExpected: _codaEntity{
					ID:   `c-tvtGu9juVL`,
					Name: `EURRUB expected`,
				},
				EURRUBActual: _codaEntity{
					ID:   `c-kLIyv9EvyH`,
					Name: `EURRUB actual`,
				},
			},
		},
		CorrectionsByType: _correctionsByTypeTable{
			_codaEntity: _codaEntity{
				ID:   `table-03U7R1uke5`,
				Name: `Corrections by type`,
			},
			Cols: _correctionsByTypeTableColumns{
				Invoice: _codaEntity{
					ID:   `c-7SU0iOBY9J`,
					Name: `Invoice`,
				},
				Type: _codaEntity{
					ID:   `c-zDY58PF0P6`,
					Name: `Type`,
				},
				Comment: _codaEntity{
					ID:   `c--_r48PQnSn`,
					Name: `Comment`,
				},
				RUBAmount: _codaEntity{
					ID:   `c-P2x5IJuMXN`,
					Name: `RUB Amount`,
				},
				EURAmount: _codaEntity{
					ID:   `c-pRmEece9pf`,
					Name: `EUR Amount`,
				},
			},
		},
		PayrollReportToAdd: _payrollReportToAddTable{
			_codaEntity: _codaEntity{
				ID:   `table-H3qyUiWeb2`,
				Name: `Payroll report to add`,
			},
			Cols: _payrollReportToAddTableColumns{
				Month: _codaEntity{
					ID:   `c-wR0IONcxGH`,
					Name: `Month`,
				},
				Employee: _codaEntity{
					ID:   `c-bbHUhqlbfN`,
					Name: `Employee`,
				},
			},
		},
		BankTariffs: _bankTariffsTable{
			_codaEntity: _codaEntity{
				ID:   `grid-FqLroBl9Kk`,
				Name: `Bank tariffs`,
			},
			Cols: _bankTariffsTableColumns{
				Name: _codaEntity{
					ID:   `c-lVHmajh8kg`,
					Name: `Name`,
				},
				DefaultCCFee: _codaEntity{
					ID:   `c-VuojIAZubU`,
					Name: `Default CC Fee`,
				},
				DefaultServiceFee: _codaEntity{
					ID:   `c-RRIALNhlhh`,
					Name: `Default Service Fee`,
				},
			},
		},
		PHCorrections: _pHCorrectionsTable{
			_codaEntity: _codaEntity{
				ID:   `table-yaoOyDdzWV`,
				Name: `PH corrections`,
			},
			Cols: _pHCorrectionsTableColumns{
				Comment: _codaEntity{
					ID:   `c--_r48PQnSn`,
					Name: `Comment`,
				},
			},
		},
		PHMonthlyReport: _pHMonthlyReportTable{
			_codaEntity: _codaEntity{
				ID:   `grid-uoaCZGuzih`,
				Name: `PH Monthly Report`,
			},
			Cols: _pHMonthlyReportTableColumns{
				Month: _codaEntity{
					ID:   `c-ykIozjFfuS`,
					Name: `Month`,
				},
				TotalCorrectionRUB: _codaEntity{
					ID:   `c-hqPXSYAutx`,
					Name: `Total Correction, RUB`,
				},
				TotalCorrectionEUR: _codaEntity{
					ID:   `c-lQEjHtOlUm`,
					Name: `Total Correction, EUR`,
				},
			},
		},
		Location: _locationTable{
			_codaEntity: _codaEntity{
				ID:   `grid-zW24rUkABJ`,
				Name: `Location`,
			},
			Cols: _locationTableColumns{
				Location: _codaEntity{
					ID:   `c-TCMfV9X19C`,
					Name: `Location`,
				},
			},
		},
		CompanyRates: _companyRatesTable{
			_codaEntity: _codaEntity{
				ID:   `grid-EKocnbzws-`,
				Name: `Company rates`,
			},
			Cols: _companyRatesTableColumns{
				Month: _codaEntity{
					ID:   `c-qTxlDXIGQE`,
					Name: `Month`,
				},
				EURRUB: _codaEntity{
					ID:   `c-fmUjYXxNxl`,
					Name: `EURRUB`,
				},
			},
		},
		SummaryForCurrentPeriod3: _summaryForCurrentPeriod3Table{
			_codaEntity: _codaEntity{
				ID:   `grid-ClvroIdiQE`,
				Name: `Summary for current period 3`,
			},
			Cols: _summaryForCurrentPeriod3TableColumns{
				Subject: _codaEntity{
					ID:   `c-c1sgQCiF-0`,
					Name: `Subject`,
				},
				RUB: _codaEntity{
					ID:   `c-if5o63hqNX`,
					Name: `RUB`,
				},
				EUR: _codaEntity{
					ID:   `c-A7oM0_7cO0`,
					Name: `EUR`,
				},
				Location: _codaEntity{
					ID:   `c-BpKKTPnwp2`,
					Name: `Location`,
				},
				LocationRefs: _codaEntity{
					ID:   `c-L5lFB2c7l9`,
					Name: `Location Refs`,
				},
			},
		},
		CurrentPayrollV2: _currentPayrollV2Table{
			_codaEntity: _codaEntity{
				ID:   `table-eqcaSDFij2`,
				Name: `Current payroll v2`,
			},
			Cols: _currentPayrollV2TableColumns{
				InvoiceRef: _codaEntity{
					ID:   `c-h-RzL2yXWh`,
					Name: `Invoice Ref`,
				},
				Location: _codaEntity{
					ID:   `c-R61qZWF4OL`,
					Name: `Location`,
				},
				SalaryNet: _codaEntity{
					ID:   `c-XQPSD9vAg8`,
					Name: `Salary Net`,
				},
				RUBServiceFees: _codaEntity{
					ID:   `c-ixLJinrV3u`,
					Name: `RUB Service fees`,
				},
				EURRounding: _codaEntity{
					ID:   `c-vugGgAGBr1`,
					Name: `EUR Rounding`,
				},
				AnnualUnpaidLeavesRUB: _codaEntity{
					ID:   `c-Uo4x06gCTd`,
					Name: `Annual/unpaid leaves, RUB`,
				},
				AnnualContribsRUB: _codaEntity{
					ID:   `c-RtpNgfxxJH`,
					Name: `Annual Contribs, RUB`,
				},
				MonthlyContribsEUR: _codaEntity{
					ID:   `c-wZKc8T-kxa`,
					Name: `Monthly Contribs, EUR`,
				},
				PublicHolidaysRefs: _codaEntity{
					ID:   `c--dFWXSXlSs`,
					Name: `Public Holidays Refs`,
				},
				PublicHolidaysRUB: _codaEntity{
					ID:   `c-bW1uokxXyQ`,
					Name: `Public holidays, RUB`,
				},
				OvertimesRefs: _codaEntity{
					ID:   `c-NYgI7ALlUW`,
					Name: `Overtimes Refs`,
				},
				OvertimesRUB: _codaEntity{
					ID:   `c-t2MioXrUCp`,
					Name: `Overtimes, RUB`,
				},
				BonusesRefs: _codaEntity{
					ID:   `c-EEUaWatwxL`,
					Name: `Bonuses Refs`,
				},
				BonusesRUB: _codaEntity{
					ID:   `c-xt7ILGpLk4`,
					Name: `Bonuses, RUB`,
				},
				LoansRefs: _codaEntity{
					ID:   `c-X4bSWDyr-G`,
					Name: `Loans Refs`,
				},
				LoansRUB: _codaEntity{
					ID:   `c-0yn_hfYsmz`,
					Name: `Loans, RUB`,
				},
				SalaryChangesRefs: _codaEntity{
					ID:   `c-y0SWuMDsBH`,
					Name: `Salary changes Refs`,
				},
				SalaryChangesRUB: _codaEntity{
					ID:   `c-ZY9kZCN7ap`,
					Name: `Salary changes, RUB`,
				},
				StartDayRefs: _codaEntity{
					ID:   `c-7n5ATW-ITP`,
					Name: `Start day Refs`,
				},
				StartDayRUB: _codaEntity{
					ID:   `c-mSFM6hiUeA`,
					Name: `Start day, RUB`,
				},
				QuitCompensationsRefs: _codaEntity{
					ID:   `c-mGpqcoJnCA`,
					Name: `Quit compensations Refs`,
				},
				QuitCompensationsRUB: _codaEntity{
					ID:   `c-vF3Bj7iDMb`,
					Name: `Quit compensations, RUB`,
				},
				PaidAnnualLeavesRefs: _codaEntity{
					ID:   `c-PsqZc5nM7T`,
					Name: `Paid annual leaves Refs`,
				},
				RestCorrectionRefs: _codaEntity{
					ID:   `c-Lh_T0xuy8D`,
					Name: `Rest correction Refs`,
				},
				RestCorrectionsRUB: _codaEntity{
					ID:   `c-fwWdBxz5_G`,
					Name: `Rest corrections, RUB`,
				},
			},
		},
		HeadcountPerLocation: _headcountPerLocationTable{
			_codaEntity: _codaEntity{
				ID:   `grid-h6g2-D4HkR`,
				Name: `Headcount per location`,
			},
			Cols: _headcountPerLocationTableColumns{
				Location: _codaEntity{
					ID:   `c-ht4rbBoGAx`,
					Name: `Location`,
				},
				Headcount: _codaEntity{
					ID:   `c-eLHYZpUwyV`,
					Name: `Headcount`,
				},
			},
		},
		SuspiciousRates: _suspiciousRatesTable{
			_codaEntity: _codaEntity{
				ID:   `table-aBh0H9XkSP`,
				Name: `Suspicious rates`,
			},
			Cols: _suspiciousRatesTableColumns{
				Month: _codaEntity{
					ID:   `c-wR0IONcxGH`,
					Name: `Month`,
				},
				Employee: _codaEntity{
					ID:   `c-bbHUhqlbfN`,
					Name: `Employee`,
				},
				EURRUBExpected: _codaEntity{
					ID:   `c-tvtGu9juVL`,
					Name: `EURRUB expected`,
				},
				EURRUBActual: _codaEntity{
					ID:   `c-kLIyv9EvyH`,
					Name: `EURRUB actual`,
				},
			},
		},
		WorkDays: _workDaysTable{
			_codaEntity: _codaEntity{
				ID:   `grid-YdcFoXJyHm`,
				Name: `Work days`,
			},
			Cols: _workDaysTableColumns{
				Month: _codaEntity{
					ID:   `c-DanUSfEigL`,
					Name: `Month`,
				},
				WorkDays: _codaEntity{
					ID:   `c-lGp5-iaTg_`,
					Name: `Work days`,
				},
				Location: _codaEntity{
					ID:   `c-9EPvcm9xp-`,
					Name: `Location`,
				},
			},
		},
		CorrectionsByEmployee: _correctionsByEmployeeTable{
			_codaEntity: _codaEntity{
				ID:   `table-wHw0oNhM9z`,
				Name: `Corrections by employee`,
			},
			Cols: _correctionsByEmployeeTableColumns{
				Type: _codaEntity{
					ID:   `c-zDY58PF0P6`,
					Name: `Type`,
				},
				Comment: _codaEntity{
					ID:   `c--_r48PQnSn`,
					Name: `Comment`,
				},
				RUBAmount: _codaEntity{
					ID:   `c-P2x5IJuMXN`,
					Name: `RUB Amount`,
				},
				EURAmount: _codaEntity{
					ID:   `c-pRmEece9pf`,
					Name: `EUR Amount`,
				},
			},
		},
		EnterCompanyRatesForSelectedMonth: _enterCompanyRatesForSelectedMonthTable{
			_codaEntity: _codaEntity{
				ID:   `table-IL1Xkw9xN7`,
				Name: `Enter company rates for selected month`,
			},
			Cols: _enterCompanyRatesForSelectedMonthTableColumns{
				Month: _codaEntity{
					ID:   `c-qTxlDXIGQE`,
					Name: `Month`,
				},
				EURRUB: _codaEntity{
					ID:   `c-fmUjYXxNxl`,
					Name: `EURRUB`,
				},
			},
		},
		TemplateEntries: _templateEntriesTable{
			_codaEntity: _codaEntity{
				ID:   `grid-UCDG_ZiZul`,
				Name: `Template Entries`,
			},
			Cols: _templateEntriesTableColumns{
				Employee: _codaEntity{
					ID:   `c-i3AkRY8VR2`,
					Name: `Employee`,
				},
				MonthFrom: _codaEntity{
					ID:   `c-ecmeLn9tY5`,
					Name: `Month from`,
				},
				MonthTo: _codaEntity{
					ID:   `c-uT9WCaQDwD`,
					Name: `Month to`,
				},
				Type: _codaEntity{
					ID:   `c-XAPnEUIYZl`,
					Name: `Type`,
				},
				Comment: _codaEntity{
					ID:   `c-MA1AOZuc-X`,
					Name: `Comment`,
				},
				RUBAmount: _codaEntity{
					ID:   `c-JM08fLTvoQ`,
					Name: `RUB Amount`,
				},
				EURAmount: _codaEntity{
					ID:   `c-LRs1cqydXQ`,
					Name: `EUR Amount`,
				},
				ModifiedBy: _codaEntity{
					ID:   `c-LEF8qqAn8z`,
					Name: `Modified by`,
				},
				CreatedOn: _codaEntity{
					ID:   `c-09NCJ1zLwk`,
					Name: `Created on`,
				},
				ModifiedOn: _codaEntity{
					ID:   `c-PorXY2SBXh`,
					Name: `Modified on`,
				},
				Display: _codaEntity{
					ID:   `c-IF-PVJ6rtI`,
					Name: `Display`,
				},
				IncludedToNewInvoice: _codaEntity{
					ID:   `c-pYGtsVG5Pj`,
					Name: `Included to new invoice`,
				},
			},
		},
		AllEmployeesNames: _allEmployeesNamesTable{
			_codaEntity: _codaEntity{
				ID:   `table-krFqRkjiag`,
				Name: `All employees names`,
			},
			Cols: _allEmployeesNamesTableColumns{
				Name: _codaEntity{
					ID:   `c-tCDt6yt4Ix`,
					Name: `Name`,
				},
				StartDate: _codaEntity{
					ID:   `c-Zs7oQbj-_J`,
					Name: `Start date`,
				},
				Location: _codaEntity{
					ID:   `c-WcmDQXPChx`,
					Name: `Location`,
				},
			},
		},
		BankDetails: _bankDetailsTable{
			_codaEntity: _codaEntity{
				ID:   `grid-RmSMcSeoRT`,
				Name: `Bank details`,
			},
			Cols: _bankDetailsTableColumns{
				Employee: _codaEntity{
					ID:   `c-G9rzkLyUA6`,
					Name: `Employee`,
				},
				Account: _codaEntity{
					ID:   `c-7TwwLMMH2Y`,
					Name: `Account`,
				},
				Address1: _codaEntity{
					ID:   `c-Z4kWEGdXUY`,
					Name: `Address 1`,
				},
				Address2: _codaEntity{
					ID:   `c-I051sZQZwd`,
					Name: `Address 2`,
				},
				BeneficiaryBank: _codaEntity{
					ID:   `c-ychArTE7uo`,
					Name: `Beneficiary Bank`,
				},
				MonthFrom: _codaEntity{
					ID:   `c-jJTCJEAhIj`,
					Name: `Month from`,
				},
				MonthTo: _codaEntity{
					ID:   `c-zWrlKJa5JL`,
					Name: `Month to`,
				},
				ID: _codaEntity{
					ID:   `c-6wrPfoVH6_`,
					Name: `ID`,
				},
				Text: _codaEntity{
					ID:   `c-vWfYwgU4Up`,
					Name: `Text`,
				},
				BankRequisites: _codaEntity{
					ID:   `c-kvJol7ACwf`,
					Name: `Bank requisites`,
				},
			},
		},
		BeneficiaryBank: _beneficiaryBankTable{
			_codaEntity: _codaEntity{
				ID:   `grid-nm04UZgIT5`,
				Name: `Beneficiary Bank`,
			},
			Cols: _beneficiaryBankTableColumns{
				Name: _codaEntity{
					ID:   `c-n7C1h8-HT0`,
					Name: `Name`,
				},
				Address1: _codaEntity{
					ID:   `c-IXiurFEJhe`,
					Name: `Address 1`,
				},
				Address2: _codaEntity{
					ID:   `c-4V09Q5_ecT`,
					Name: `Address 2`,
				},
				Address3: _codaEntity{
					ID:   `c-eXcEw6G3-d`,
					Name: `Address 3`,
				},
				BeneficiarySWIFT: _codaEntity{
					ID:   `c-ZJ42UOAJJ2`,
					Name: `Beneficiary SWIFT`,
				},
				IntermediarySWIFT: _codaEntity{
					ID:   `c-0YB127-zuw`,
					Name: `Intermediary SWIFT`,
				},
			},
		},
		PayrollSchedule: _payrollScheduleTable{
			_codaEntity: _codaEntity{
				ID:   `grid-eTSlW-4Wsv`,
				Name: `Payroll Schedule`,
			},
			Cols: _payrollScheduleTableColumns{
				Month: _codaEntity{
					ID:   `c-KE4PnR0O-p`,
					Name: `Month`,
				},
				ExecutionDate: _codaEntity{
					ID:   `c-AQjpD31QKS`,
					Name: `Execution date`,
				},
			},
		},
		PensionFundFixed: _pensionFundFixedTable{
			_codaEntity: _codaEntity{
				ID:   `grid-ikOK1_C1fc`,
				Name: `Pension Fund fixed`,
			},
			Cols: _pensionFundFixedTableColumns{
				Invoice: _codaEntity{
					ID:   `c-sYkd0N-9Ef`,
					Name: `Invoice`,
				},
				OpeningDateIP: _codaEntity{
					ID:   `c-Q83cwaB-vf`,
					Name: `Opening date IP`,
				},
				PeriodStart: _codaEntity{
					ID:   `c-UgsMCGn1oX`,
					Name: `Period Start`,
				},
				PeriodEnd: _codaEntity{
					ID:   `c-7Bt0dg_odm`,
					Name: `Period End`,
				},
				AmountIPDays: _codaEntity{
					ID:   `c-wraB-EUIPu`,
					Name: `Amount IP days`,
				},
				PensionFundFixedToPay: _codaEntity{
					ID:   `c-5Gm9BIf7sa`,
					Name: `Pension fund fixed - to pay`,
				},
				PensionFundFixedTotal: _codaEntity{
					ID:   `c-D3jKQu0yHQ`,
					Name: `Pension Fund fixed - total`,
				},
				Year: _codaEntity{
					ID:   `c-_hn4kyEKo7`,
					Name: `Year`,
				},
				Apply: _codaEntity{
					ID:   `c-fyHmYOce3g`,
					Name: `Apply`,
				},
			},
		},
		SocialInsurance: _socialInsuranceTable{
			_codaEntity: _codaEntity{
				ID:   `grid-xke_mOFuzO`,
				Name: `Social Insurance`,
			},
			Cols: _socialInsuranceTableColumns{
				Invoice: _codaEntity{
					ID:   `c-sYkd0N-9Ef`,
					Name: `Invoice`,
				},
				OpeningDateIP: _codaEntity{
					ID:   `c-Q83cwaB-vf`,
					Name: `Opening date IP`,
				},
				PeriodStart: _codaEntity{
					ID:   `c-UgsMCGn1oX`,
					Name: `Period Start`,
				},
				PeriodEnd: _codaEntity{
					ID:   `c-7Bt0dg_odm`,
					Name: `Period End`,
				},
				AmountIPDays: _codaEntity{
					ID:   `c-wraB-EUIPu`,
					Name: `Amount IP days`,
				},
				SocialInsuranceToPay: _codaEntity{
					ID:   `c-hRpESBxMnx`,
					Name: `Social Insurance - to pay`,
				},
				SocialInsuranceTotal: _codaEntity{
					ID:   `c-6OpLGjaPb6`,
					Name: `Social Insurance - total`,
				},
				Year: _codaEntity{
					ID:   `c-_hn4kyEKo7`,
					Name: `Year`,
				},
				Apply: _codaEntity{
					ID:   `c-xSCK9SJjHk`,
					Name: `Apply`,
				},
			},
		},
		PensionFundPercent: _pensionFundPercentTable{
			_codaEntity: _codaEntity{
				ID:   `grid-5B0Z-WEqCn`,
				Name: `Pension fund percent`,
			},
			Cols: _pensionFundPercentTableColumns{
				Invoice: _codaEntity{
					ID:   `c-sYkd0N-9Ef`,
					Name: `Invoice`,
				},
				PensionFundPercent: _codaEntity{
					ID:   `c-nO-EnVUZSb`,
					Name: `Pension fund percent`,
				},
				Year: _codaEntity{
					ID:   `c-_hn4kyEKo7`,
					Name: `Year`,
				},
				Apply: _codaEntity{
					ID:   `c-4sK_CrcwHD`,
					Name: `Apply`,
				},
			},
		},
		PerDayCalculations: _perDayCalculationsTable{
			_codaEntity: _codaEntity{
				ID:   `grid-ik-9DIjBqz`,
				Name: `Per Day Calculations`,
			},
			Cols: _perDayCalculationsTableColumns{
				Type: _codaEntity{
					ID:   `c-3Ivn-M1j7-`,
					Name: `Type`,
				},
				NumberOfDays: _codaEntity{
					ID:   `c-gDOyigH1cm`,
					Name: `Number of days`,
				},
				CostOfDay: _codaEntity{
					ID:   `c-K_Iy0iERKR`,
					Name: `Cost of day`,
				},
				Total: _codaEntity{
					ID:   `c-Y2E1Vwe2_-`,
					Name: `Total`,
				},
				PaymentInvoice: _codaEntity{
					ID:   `c-7SU0iOBY9J`,
					Name: `Payment invoice`,
				},
				SalaryPeriod: _codaEntity{
					ID:   `c-bK4qXZUCqs`,
					Name: `Salary period`,
				},
				CalculationInvoice: _codaEntity{
					ID:   `c-QXP63jNl9T`,
					Name: `Calculation invoice`,
				},
				Salary: _codaEntity{
					ID:   `c-jgeE5L-QmG`,
					Name: `Salary`,
				},
				Apply: _codaEntity{
					ID:   `c-5wgfO7-p7n`,
					Name: `Apply`,
				},
				WorkPeriod: _codaEntity{
					ID:   `c-dfz1IaNFyb`,
					Name: `Work period`,
				},
			},
		},
		PerDayPolicies: _perDayPoliciesTable{
			_codaEntity: _codaEntity{
				ID:   `grid-MwSd1ImG9X`,
				Name: `Per Day Policies`,
			},
			Cols: _perDayPoliciesTableColumns{
				Name: _codaEntity{
					ID:   `c-SESlR7_60Q`,
					Name: `Name`,
				},
				Coefficient: _codaEntity{
					ID:   `c-Cg4D8wBxQx`,
					Name: `Coefficient`,
				},
				EntryType: _codaEntity{
					ID:   `c-MyD8pD9imA`,
					Name: `Entry Type`,
				},
			},
		},
		Salaries: _salariesTable{
			_codaEntity: _codaEntity{
				ID:   `table-zWwQuzxVi7`,
				Name: `Salaries`,
			},
			Cols: _salariesTableColumns{
				Employee: _codaEntity{
					ID:   `c-i3AkRY8VR2`,
					Name: `Employee`,
				},
				MonthFrom: _codaEntity{
					ID:   `c-ecmeLn9tY5`,
					Name: `Month from`,
				},
				MonthTo: _codaEntity{
					ID:   `c-uT9WCaQDwD`,
					Name: `Month to`,
				},
				Comment: _codaEntity{
					ID:   `c-MA1AOZuc-X`,
					Name: `Comment`,
				},
				RUBAmount: _codaEntity{
					ID:   `c-JM08fLTvoQ`,
					Name: `RUB Amount`,
				},
				EURAmount: _codaEntity{
					ID:   `c-LRs1cqydXQ`,
					Name: `EUR Amount`,
				},
			},
		},
		PayableEmployees: _payableEmployeesTable{
			_codaEntity: _codaEntity{
				ID:   `grid-ULBMNv2LxC`,
				Name: `Payable employees`,
			},
			Cols: _payableEmployeesTableColumns{
				Employee: _codaEntity{
					ID:   `c-E3ueCNW5Td`,
					Name: `Employee`,
				},
				BonusQuarter: _codaEntity{
					ID:   `c-b7PNViCexb`,
					Name: `Bonus Quarter`,
				},
				TargetInvoice: _codaEntity{
					ID:   `c-lNa8MQX1Ze`,
					Name: `Target invoice`,
				},
				AddAny: _codaEntity{
					ID:   `c-5kK0bjRk3J`,
					Name: `Add any`,
				},
				FlexBenefit: _codaEntity{
					ID:   `c-5k0Q3x_vWp`,
					Name: `Flex benefit`,
				},
				SelfEmplTax: _codaEntity{
					ID:   `c-0jQDMsAjed`,
					Name: `Self-Empl Tax`,
				},
				IE6PercentTax: _codaEntity{
					ID:   `c-L-78eDsX4J`,
					Name: `IE 6% Tax`,
				},
				ManualEntries: _codaEntity{
					ID:   `c-gwL_v6jBRy`,
					Name: `Manual Entries`,
				},
				ExcludedEntryTypes: _codaEntity{
					ID:   `c-aMaPUsZYA1`,
					Name: `Excluded Entry Types`,
				},
				PayableNow: _codaEntity{
					ID:   `c-6HSqW9zar4`,
					Name: `Payable now`,
				},
				ExcludeFromPayment: _codaEntity{
					ID:   `c-osG85-umSw`,
					Name: `Exclude from payment`,
				},
			},
		},
		QuickManualEntry: _quickManualEntryTable{
			_codaEntity: _codaEntity{
				ID:   `table-jI1G_u-gq-`,
				Name: `Quick Manual Entry`,
			},
			Cols: _quickManualEntryTableColumns{
				TargetInvoice: _codaEntity{
					ID:   `c-lNa8MQX1Ze`,
					Name: `Target invoice`,
				},
				ManualEntries: _codaEntity{
					ID:   `c-gwL_v6jBRy`,
					Name: `Manual Entries`,
				},
				AddAny: _codaEntity{
					ID:   `c-5kK0bjRk3J`,
					Name: `Add any`,
				},
				BonusQuarter: _codaEntity{
					ID:   `c-b7PNViCexb`,
					Name: `Bonus Quarter`,
				},
				FlexBenefit: _codaEntity{
					ID:   `c-5k0Q3x_vWp`,
					Name: `Flex benefit`,
				},
				SelfEmplTax: _codaEntity{
					ID:   `c-0jQDMsAjed`,
					Name: `Self-Empl Tax`,
				},
				IE6PercentTax: _codaEntity{
					ID:   `c-L-78eDsX4J`,
					Name: `IE 6% Tax`,
				},
			},
		},
		NewInvoiceEntriesPerType: _newInvoiceEntriesPerTypeTable{
			_codaEntity: _codaEntity{
				ID:   `table-vHvZOlu-NN`,
				Name: `New invoice entries per type`,
			},
			Cols: _newInvoiceEntriesPerTypeTableColumns{
				Invoice: _codaEntity{
					ID:   `c-7SU0iOBY9J`,
					Name: `Invoice`,
				},
				Type: _codaEntity{
					ID:   `c-zDY58PF0P6`,
					Name: `Type`,
				},
				RUBAmount: _codaEntity{
					ID:   `c-P2x5IJuMXN`,
					Name: `RUB Amount`,
				},
				EURAmount: _codaEntity{
					ID:   `c-pRmEece9pf`,
					Name: `EUR Amount`,
				},
				Comment: _codaEntity{
					ID:   `c--_r48PQnSn`,
					Name: `Comment`,
				},
			},
		},
		EntriesPerDateAndType: _entriesPerDateAndTypeTable{
			_codaEntity: _codaEntity{
				ID:   `table-FPbyh6ItDw`,
				Name: `Entries per date and type`,
			},
			Cols: _entriesPerDateAndTypeTableColumns{
				Invoice: _codaEntity{
					ID:   `c-7SU0iOBY9J`,
					Name: `Invoice`,
				},
				Type: _codaEntity{
					ID:   `c-zDY58PF0P6`,
					Name: `Type`,
				},
				RUBAmount: _codaEntity{
					ID:   `c-P2x5IJuMXN`,
					Name: `RUB Amount`,
				},
				EURAmount: _codaEntity{
					ID:   `c-pRmEece9pf`,
					Name: `EUR Amount`,
				},
				Comment: _codaEntity{
					ID:   `c--_r48PQnSn`,
					Name: `Comment`,
				},
				Month: _codaEntity{
					ID:   `c-Mj8CH9hJ_A`,
					Name: `Month`,
				},
			},
		},
		AddNewEmployee: _addNewEmployeeTable{
			_codaEntity: _codaEntity{
				ID:   `table-3H0OrLZ2Z-`,
				Name: `Add new employee`,
			},
			Cols: _addNewEmployeeTableColumns{
				Name: _codaEntity{
					ID:   `c-tCDt6yt4Ix`,
					Name: `Name`,
				},
				LegalForm: _codaEntity{
					ID:   `c-w8WTgIbQ7H`,
					Name: `Legal form`,
				},
				StartDate: _codaEntity{
					ID:   `c-Zs7oQbj-_J`,
					Name: `Start date`,
				},
				EndDate: _codaEntity{
					ID:   `c-7OoHuXqt8n`,
					Name: `End date`,
				},
				ContractDate: _codaEntity{
					ID:   `c-fDIRo1JHHX`,
					Name: `Contract Date`,
				},
				ContractNumber: _codaEntity{
					ID:   `c-XX2OkCkOSR`,
					Name: `Contract Number`,
				},
				Location: _codaEntity{
					ID:   `c-WcmDQXPChx`,
					Name: `Location`,
				},
				LegalEntity: _codaEntity{
					ID:   `c-smk4a68He5`,
					Name: `Legal entity`,
				},
				OpeningDateIP: _codaEntity{
					ID:   `c-uU3-6piESs`,
					Name: `Opening date IP`,
				},
				BankDetails: _codaEntity{
					ID:   `c-wSSi6yT6d4`,
					Name: `Bank details`,
				},
				GeneralSD: _codaEntity{
					ID:   `c-EMbqnhOkkr`,
					Name: `General SD`,
				},
				FinanceSD: _codaEntity{
					ID:   `c-NeQmHu-raB`,
					Name: `Finance SD`,
				},
				BankTariff: _codaEntity{
					ID:   `c-Hx-nCcWt2v`,
					Name: `Bank tariff`,
				},
				ContractHourRate: _codaEntity{
					ID:   `c-SItGvyE3ie`,
					Name: `Contract hour rate`,
				},
				Rounding: _codaEntity{
					ID:   `c-xvCHSSPdHb`,
					Name: `Rounding`,
				},
				EnglishFullName: _codaEntity{
					ID:   `c-TAlfzDcFzQ`,
					Name: `English full name`,
				},
				SpecialPaymentPolicy: _codaEntity{
					ID:   `c-FOuDAl0Fmk`,
					Name: `Special payment policy`,
				},
				WorkingNow: _codaEntity{
					ID:   `c-QfV5QzjuJP`,
					Name: `Working now?`,
				},
				Valid: _codaEntity{
					ID:   `c-0pE57fQdnw`,
					Name: `Valid?`,
				},
				InvalidFields: _codaEntity{
					ID:   `c-9NyvCfUrkk`,
					Name: `Invalid fields`,
				},
			},
		},
		CurrentTemplateEntries: _currentTemplateEntriesTable{
			_codaEntity: _codaEntity{
				ID:   `table-DUS1zaTB_3`,
				Name: `Current template entries`,
			},
			Cols: _currentTemplateEntriesTableColumns{
				Employee: _codaEntity{
					ID:   `c-i3AkRY8VR2`,
					Name: `Employee`,
				},
				MonthFrom: _codaEntity{
					ID:   `c-ecmeLn9tY5`,
					Name: `Month from`,
				},
				MonthTo: _codaEntity{
					ID:   `c-uT9WCaQDwD`,
					Name: `Month to`,
				},
				Type: _codaEntity{
					ID:   `c-XAPnEUIYZl`,
					Name: `Type`,
				},
				RUBAmount: _codaEntity{
					ID:   `c-JM08fLTvoQ`,
					Name: `RUB Amount`,
				},
				EURAmount: _codaEntity{
					ID:   `c-LRs1cqydXQ`,
					Name: `EUR Amount`,
				},
				Comment: _codaEntity{
					ID:   `c-MA1AOZuc-X`,
					Name: `Comment`,
				},
			},
		},
		TemplateEntriesMonthsFiltering: _templateEntriesMonthsFilteringTable{
			_codaEntity: _codaEntity{
				ID:   `grid-imyVV2Q8VT`,
				Name: `Template entries months filtering`,
			},
			Cols: _templateEntriesMonthsFilteringTableColumns{
				Month: _codaEntity{
					ID:   `c-lfM8-ZOodZ`,
					Name: `Month`,
				},
				FormatTypeButtonTextTypeSlateRootChildrenAlignmentLeftChildrenTextFrom202112IdCl0LineLevel0StyleParagraphTypeLine: _codaEntity{
					ID:   `c-VwJ7SsrQA3`,
					Name: `{"formatType":"button","text":{"type":"slate","root":{"children":[{"alignment":"Left","children":[{"text":"From 2021-12"}],"id":"cl-0","lineLevel":0,"style":"Paragraph","type":"Line"}]}}}`,
				},
				FormatTypeButtonTextTypeSlateRootChildrenAlignmentLeftChildrenTextTo202112IdCl0LineLevel0StyleParagraphTypeLine: _codaEntity{
					ID:   `c-_Vc6Xy2_j_`,
					Name: `{"formatType":"button","text":{"type":"slate","root":{"children":[{"alignment":"Left","children":[{"text":"To 2021-12"}],"id":"cl-0","lineLevel":0,"style":"Paragraph","type":"Line"}]}}}`,
				},
				FromValue: _codaEntity{
					ID:   `c-K8zCZG7n_2`,
					Name: `From value`,
				},
				ToValue: _codaEntity{
					ID:   `c-Rx4qtO-SsR`,
					Name: `To value`,
				},
				Button: _codaEntity{
					ID:   `c-HeLiGb2ebp`,
					Name: `Button`,
				},
			},
		},
		TemplateEntriesTypeFiltering: _templateEntriesTypeFilteringTable{
			_codaEntity: _codaEntity{
				ID:   `grid-KNYop66J0l`,
				Name: `Template entries type filtering`,
			},
			Cols: _templateEntriesTypeFilteringTableColumns{
				Type: _codaEntity{
					ID:   `c-lJ3teF8sWt`,
					Name: `Type`,
				},
				FilteringType: _codaEntity{
					ID:   `c-PHXJfT5_97`,
					Name: `Filtering Type`,
				},
				OnlyBtn: _codaEntity{
					ID:   `c-X1mSVuFREE`,
					Name: `Only Btn`,
				},
				InclBtn: _codaEntity{
					ID:   `c-ImBtluMOWE`,
					Name: `Incl Btn`,
				},
				ExclBtn: _codaEntity{
					ID:   `c-d3evldj8KB`,
					Name: `Excl Btn`,
				},
			},
		},
		EntriesMonthsFiltering: _entriesMonthsFilteringTable{
			_codaEntity: _codaEntity{
				ID:   `grid-U7iScPEM0h`,
				Name: `Entries months filtering`,
			},
			Cols: _entriesMonthsFilteringTableColumns{
				Month: _codaEntity{
					ID:   `c-lfM8-ZOodZ`,
					Name: `Month`,
				},
				FormatTypeButtonTextTypeSlateRootChildrenAlignmentLeftChildrenTextFrom202112IdCl0LineLevel0StyleParagraphTypeLine: _codaEntity{
					ID:   `c-VwJ7SsrQA3`,
					Name: `{"formatType":"button","text":{"type":"slate","root":{"children":[{"alignment":"Left","children":[{"text":"From 2021-12"}],"id":"cl-0","lineLevel":0,"style":"Paragraph","type":"Line"}]}}}`,
				},
				FormatTypeButtonTextTypeSlateRootChildrenAlignmentLeftChildrenTextTo202112IdCl0LineLevel0StyleParagraphTypeLine: _codaEntity{
					ID:   `c-_Vc6Xy2_j_`,
					Name: `{"formatType":"button","text":{"type":"slate","root":{"children":[{"alignment":"Left","children":[{"text":"To 2021-12"}],"id":"cl-0","lineLevel":0,"style":"Paragraph","type":"Line"}]}}}`,
				},
				FromValue: _codaEntity{
					ID:   `c-K8zCZG7n_2`,
					Name: `From value`,
				},
				ToValue: _codaEntity{
					ID:   `c-Rx4qtO-SsR`,
					Name: `To value`,
				},
				Button: _codaEntity{
					ID:   `c-HeLiGb2ebp`,
					Name: `Button`,
				},
			},
		},
		EntriesTypeFiltering: _entriesTypeFilteringTable{
			_codaEntity: _codaEntity{
				ID:   `grid-UcdAATi4id`,
				Name: `Entries type filtering`,
			},
			Cols: _entriesTypeFilteringTableColumns{
				Type: _codaEntity{
					ID:   `c-lJ3teF8sWt`,
					Name: `Type`,
				},
				FilteringType: _codaEntity{
					ID:   `c-PHXJfT5_97`,
					Name: `Filtering Type`,
				},
				OnlyBtn: _codaEntity{
					ID:   `c-X1mSVuFREE`,
					Name: `Only Btn`,
				},
				InclBtn: _codaEntity{
					ID:   `c-ImBtluMOWE`,
					Name: `Incl Btn`,
				},
				ExclBtn: _codaEntity{
					ID:   `c-d3evldj8KB`,
					Name: `Excl Btn`,
				},
			},
		},
		FilteredEntries: _filteredEntriesTable{
			_codaEntity: _codaEntity{
				ID:   `table-D6FRxXtQYS`,
				Name: `Filtered Entries`,
			},
			Cols: _filteredEntriesTableColumns{
				Invoice: _codaEntity{
					ID:   `c-7SU0iOBY9J`,
					Name: `Invoice`,
				},
				Type: _codaEntity{
					ID:   `c-zDY58PF0P6`,
					Name: `Type`,
				},
				RUBAmount: _codaEntity{
					ID:   `c-P2x5IJuMXN`,
					Name: `RUB Amount`,
				},
				EURAmount: _codaEntity{
					ID:   `c-pRmEece9pf`,
					Name: `EUR Amount`,
				},
				Comment: _codaEntity{
					ID:   `c--_r48PQnSn`,
					Name: `Comment`,
				},
			},
		},
		AddCompanyRate: _addCompanyRateTable{
			_codaEntity: _codaEntity{
				ID:   `table-g-tJJSbV8H`,
				Name: `Add company rate`,
			},
			Cols: _addCompanyRateTableColumns{
				Month: _codaEntity{
					ID:   `c-qTxlDXIGQE`,
					Name: `Month`,
				},
				EURRUB: _codaEntity{
					ID:   `c-fmUjYXxNxl`,
					Name: `EURRUB`,
				},
			},
		},
		TESTTABLE: _tESTTABLETable{
			_codaEntity: _codaEntity{
				ID:   `grid-wEU-5HbECi`,
				Name: `TEST TABLE`,
			},
			Cols: _tESTTABLETableColumns{
				Name: _codaEntity{
					ID:   `c-ts1a_lfGC5`,
					Name: `Name`,
				},
				Column2: _codaEntity{
					ID:   `c-FDsN1xG0FA`,
					Name: `Column 2`,
				},
				Column3: _codaEntity{
					ID:   `c-rFe1HLVgms`,
					Name: `Column 3`,
				},
				Duration: _codaEntity{
					ID:   `c-hrssIsk7r8`,
					Name: `Duration`,
				},
				Currency: _codaEntity{
					ID:   `c-1l9sk744wK`,
					Name: `Currency`,
				},
				Email: _codaEntity{
					ID:   `c-mgGMr50AOl`,
					Name: `email?`,
				},
				Slider: _codaEntity{
					ID:   `c-ppTUc0rqc8`,
					Name: `Slider`,
				},
				Percent: _codaEntity{
					ID:   `c-XxU1geqmzQ`,
					Name: `Percent`,
				},
				Scale: _codaEntity{
					ID:   `c-8HgFEfWzDn`,
					Name: `Scale`,
				},
				People: _codaEntity{
					ID:   `c-DLKwVVVzr-`,
					Name: `People`,
				},
				Date: _codaEntity{
					ID:   `c-JSPeKpNt2B`,
					Name: `Date`,
				},
				DateTime: _codaEntity{
					ID:   `c-2-QvLwdY_q`,
					Name: `DateTime`,
				},
				Time: _codaEntity{
					ID:   `c-_L1iwGXWJp`,
					Name: `Time`,
				},
			},
		},
	},
	Formula: _formulaSchema{
		CurrentMonth: _codaEntity{
			ID:   `f-rnJn4-MytN`,
			Name: `currentMonth`,
		},
		PayrollReportCurRate: _codaEntity{
			ID:   `f-29VxTdfxQ1`,
			Name: `payrollReportCurRate`,
		},
		InvoiceAddingRate: _codaEntity{
			ID:   `f-Szv1kBPaqg`,
			Name: `invoiceAddingRate`,
		},
		NewInvoiceValidation: _codaEntity{
			ID:   `f-mvuXtisHj6`,
			Name: `newInvoiceValidation`,
		},
		NewInvoiceValidationIcon: _codaEntity{
			ID:   `f-DEQrOzH6JR`,
			Name: `newInvoiceValidationIcon`,
		},
		NewInvoiceErrors: _codaEntity{
			ID:   `f--I2SwJC0C_`,
			Name: `newInvoiceErrors`,
		},
		NewInvoicePayableEmployees: _codaEntity{
			ID:   `f-NWxXPZ-TMc`,
			Name: `newInvoicePayableEmployees`,
		},
		NewInvoiceWarns: _codaEntity{
			ID:   `f-g_OuXCjAtP`,
			Name: `newInvoiceWarns`,
		},
	},
	Control: _controlSchema{
		SelectOverviewMonth: _codaEntity{
			ID:   `ctrl-pgiOKuvlsi`,
			Name: `selectOverviewMonth`,
		},
		SelectOverviewEmployee: _codaEntity{
			ID:   `ctrl-jOuC2qXPDn`,
			Name: `selectOverviewEmployee`,
		},
		InvoiceAddingMonth: _codaEntity{
			ID:   `ctrl-tmRmOIk1PB`,
			Name: `invoiceAddingMonth`,
		},
		PayrollReportCurPeriod: _codaEntity{
			ID:   `ctrl-PdzCvb2Pk_`,
			Name: `payrollReportCurPeriod`,
		},
		PayrollReportAddReport: _codaEntity{
			ID:   `ctrl-UIeU83BjQI`,
			Name: `payrollReportAddReport`,
		},
		FillRatesShowFilled: _codaEntity{
			ID:   `ctrl-KsXj7cpo3G`,
			Name: `fillRatesShowFilled`,
		},
		NewInvoiceBtn: _codaEntity{
			ID:   `ctrl-_VdNjxp4nS`,
			Name: `newInvoiceBtn`,
		},
		NewInvoiceMonth: _codaEntity{
			ID:   `ctrl-AMUYcRRj1w`,
			Name: `newInvoiceMonth`,
		},
		Button1: _codaEntity{
			ID:   `ctrl-HAuPB-WNu8`,
			Name: `button 1`,
		},
		Button2: _codaEntity{
			ID:   `ctrl-ijbG8VjY6V`,
			Name: `button 2`,
		},
		Button3: _codaEntity{
			ID:   `ctrl-8x76CGB4N_`,
			Name: `button 3`,
		},
		BtnTemplateEntriesShowAllTypes: _codaEntity{
			ID:   `ctrl-tQ-Yq4n1_-`,
			Name: `btnTemplateEntriesShowAllTypes`,
		},
		BtnTemplateEntriesShowAllDates: _codaEntity{
			ID:   `ctrl-7V643mJOAv`,
			Name: `btnTemplateEntriesShowAllDates`,
		},
		BtnTemplateEntriesShowAllDates2: _codaEntity{
			ID:   `ctrl-Yuwe123KO2`,
			Name: `btnTemplateEntriesShowAllDates 2`,
		},
		BtnTemplateEntriesShowAllTypes2: _codaEntity{
			ID:   `ctrl-__5se6m0jX`,
			Name: `btnTemplateEntriesShowAllTypes 2`,
		},
	},
}

//region Coda types

type Person struct {
	Name  string
	Email string
}

type WebPage struct {
	Url string
}

type MonetaryAmount struct {
	Currency string
	Amount   float64
}

type Attachment struct {
	Name   string
	Height int
	Width  int
	URL    string
}

type structuredValue struct {
	Context        string `json:"@context"`
	Type           string `json:"@type"`
	AdditionalType string `json:"additionalType"`
	Name           string `json:"name"`
	Url            string `json:"url"`
	TableId        string `json:"tableId"`
	RowId          string `json:"rowId"`
	TableUrl       string `json:"tableUrl"`
}

//endregion

//region Errors

func newFieldError(fieldID string, expectedType string, rawv interface{}) error {
	return fmt.Errorf(
		"unexpected type for field %s. Expected type %s, got %T (value `%#v`)",
		fieldID,
		expectedType,
		rawv,
		rawv,
	)
}

type ErrContainer []error

func (c *ErrContainer) AddError(err error) {
	*c = append(*c, err)
}

func (c ErrContainer) Error() string {
	stringErr := ""
	for _, err := range c {
		stringErr += err.Error() + "; "
	}

	return stringErr
}

func NewErrorContainer() ErrContainer {
	return make(ErrContainer, 0)
}

//endregion

//region Parsing of basic internal types

type Valuer interface {
	GetValue(key string) (value interface{}, ok bool)
}

func ToString(colID string, row Valuer) (string, error) {
	rawv, ok := row.GetValue(colID)
	if !ok {
		return "", nil
	}
	if value, ok := rawv.(string); ok {
		return strings.Trim(value, "`"), nil
	}

	// If whole cell looks like an URL Coda may parse it so and return column value as a WebPage structure
	webpage, err := ToWebPage(colID, row)
	if err == nil {
		return webpage.Url, nil
	}

	// If whole cell looks like a money amount Coda may parse it so and return column value as a MonetaryAmount structure
	money, err := ToMonetaryAmount(colID, row)
	if err == nil {
		return fmt.Sprintf("%.2f %v", money.Amount, money.Currency), nil
	}

	bs, _ := json.Marshal(rawv)

	return strings.Trim(string(bs), `"`), nil
}

// CodaTimeFormat holds the format used in Coda time values. Regardless of the type it always returns values in this format.
//
// Examples:
//    "Date": "2022-02-03T13:00:00.000-08:00",
//    "DateTime": "2022-02-04T03:30:00.000-08:00",
//    "Time": "1899-12-29T13:29:43.000-08:00"
const CodaTimeFormat = "2006-01-02T15:04:05.999-07:00"

func ToDateTime(colID string, row Valuer) (time.Time, error) {
	return ToTimeWithFormat(CodaTimeFormat, colID, row)
}

func ToDate(colID string, row Valuer) (time.Time, error) {
	return ToTimeWithFormat(CodaTimeFormat, colID, row)
}

func ToTime(colID string, row Valuer) (time.Time, error) {
	return ToTimeWithFormat(CodaTimeFormat, colID, row)
}

func ToTimeWithFormat(format string, colID string, row Valuer) (t time.Time, err error) {
	rawv, ok := row.GetValue(colID)
	if !ok {
		return time.Time{}, nil
	}
	if value, ok := rawv.(string); ok {
		if value == "" {
			return time.Time{}, nil
		}
		timev, terr := time.Parse(format, value)
		if terr != nil {
			return time.Time{}, terr
		}
		return timev, nil
	}

	return time.Time{}, newFieldError(colID, "string in format "+CodaTimeFormat, rawv)
}

func ToFloat64(colID string, row Valuer) (float64, error) {
	rawv, ok := row.GetValue(colID)
	if !ok {
		return 0, nil
	}
	switch v := rawv.(type) {
	case float64:
		return v, nil
	case int64:
		return float64(v), nil
	case int32:
		return float64(v), nil
	case float32:
		return float64(v), nil
	case string:
		if strings.Trim(v, " `") == "" {
			return 0, nil
		}
		return strconv.ParseFloat(v, 64)
	default:
		return 0, newFieldError(colID, "float64", rawv)
	}
}

func ToBool(colID string, row Valuer) (bool, error) {
	rawv, ok := row.GetValue(colID)
	if !ok {
		return false, nil
	}
	switch v := rawv.(type) {
	case bool:
		return v, nil
	case string:
		return false, nil
	default:
		return false, newFieldError(colID, "bool", rawv)
	}
}

func ToUint8(colID string, row Valuer) (uint8, error) {
	if v, err := ToFloat64(colID, row); err == nil {
		return uint8(v), nil
	}
	rawv, _ := row.GetValue(colID)
	return 0, newFieldError(colID, "uint8", rawv)
}

func toStructuredValueFromValuer(colID string, row Valuer) (sv structuredValue, err error) {
	rawv, ok := row.GetValue(colID)
	if !ok {
		return structuredValue{}, nil
	}

	return toStructuredValue(rawv)
}

func toStructuredValue(rawv interface{}) (sv structuredValue, err error) {
	var ok bool
	var mapv map[string]interface{}

	if mapv, ok = rawv.(map[string]interface{}); !ok {
		return sv, fmt.Errorf("unexpected value type %T", rawv)
	}

	if sv.Context, ok = mapv["@context"].(string); !ok {
		return sv, fmt.Errorf("@context is not set")
	}

	if sv.Type, ok = mapv["@type"].(string); !ok {
		return sv, fmt.Errorf("@type is not set")
	}

	if sv.AdditionalType, ok = mapv["additionalType"].(string); !ok {
		return sv, fmt.Errorf("additionalType is not set")
	}

	if sv.Name, ok = mapv["name"].(string); !ok {
		return sv, fmt.Errorf("name is not set")
	}

	if sv.Url, ok = mapv["url"].(string); !ok {
		return sv, fmt.Errorf("url is not set")
	}

	if sv.TableId, ok = mapv["tableId"].(string); !ok {
		return sv, fmt.Errorf("tableId is not set")
	}

	if sv.RowId, ok = mapv["rowId"].(string); !ok {
		return sv, fmt.Errorf("rowId is not set")
	}

	if sv.TableUrl, ok = mapv["tableUrl"].(string); !ok {
		return sv, fmt.Errorf("tableUrl is not set")
	}

	return
}

//ToWebPage parses Valuer value(s) of the following structure:
//{
//    "@context": "http://schema.org/",
//    "@type": "WebPage",
//    "url": "https://example.org"
//}
func ToWebPage(colID string, row Valuer) (p WebPage, err error) {
	v, ok := row.GetValue(colID)
	if !ok {
		return WebPage{}, nil
	}

	if mapVal, ok := v.(map[string]interface{}); ok && mapVal["@type"] == "WebPage" {
		return WebPage{Url: mapVal["url"].(string)}, nil
	}

	return WebPage{}, fmt.Errorf("unexpected value type %T (value %#v)", v, v)
}

//ToPersons parses Valuer value(s) of the following structure:
//{
//  "@context": "http://schema.org/",
//  "@type": "Person",
//  "name": "John Doe",
//  "email": "john.doe@example.org"
//},
func ToPersons(colID string, row Valuer) (persons []Person, err error) {
	v, ok := row.GetValue(colID)
	if !ok {
		return nil, nil
	}

	if sliceVal, ok := v.([]interface{}); ok {
		for sliceIdx, interVal := range sliceVal {
			var mapVal map[string]interface{}
			if mapVal, ok = interVal.(map[string]interface{}); !ok {
				return nil, fmt.Errorf("slice value #%v: unexpected item type %T (value %#v)", sliceIdx, mapVal, mapVal)
			}
			person, err := newPersonFromInterface(mapVal)
			if err != nil {
				return nil, fmt.Errorf("slice value #%v: %w", sliceIdx, err)
			}
			persons = append(persons, person)
		}

		return
	}

	if mapVal, ok := v.(map[string]interface{}); ok {
		person, err := newPersonFromInterface(mapVal)
		if err != nil {
			return nil, err
		}
		return []Person{person}, nil
	}

	return nil, fmt.Errorf("unexpected value type %T (value %#v)", v, v)
}

//ToAttachments parses Valuer value(s) of the following structure:
// {
//   "@context": "http://schema.org/",
//   "@type": "ImageObject",
//   "name": "....pdf",
//   "height": "",
//   "width": "",
//   "url": "https://codahosted.io/docs/...",
//   "status": "live"
// }
//
// {
//   "@context": "http://schema.org/",
//   "@type": "ImageObject",
//   "name": "....jpg",
//   "height": 4032,
//   "width": 3024,
//   "url": "https://codahosted.io/docs/...",
//   "status": "live"
// }
func ToAttachments(colID string, row Valuer) (atts []Attachment, err error) {
	v, ok := row.GetValue(colID)
	if !ok {
		return nil, nil
	}

	if sliceVal, ok := v.([]interface{}); ok {
		for sliceIdx, interVal := range sliceVal {
			var mapVal map[string]interface{}
			if mapVal, ok = interVal.(map[string]interface{}); !ok {
				return nil, fmt.Errorf("slice value #%v: unexpected item type %T (value %#v)", sliceIdx, mapVal, mapVal)
			}
			att, err := newAttachmentFromInterface(mapVal)
			if err != nil {
				return nil, fmt.Errorf("slice value #%v: %w", sliceIdx, err)
			}
			atts = append(atts, att)
		}

		return
	}

	if mapVal, ok := v.(map[string]interface{}); ok {
		att, err := newAttachmentFromInterface(mapVal)
		if err != nil {
			return nil, err
		}
		return []Attachment{att}, nil
	}

	return nil, fmt.Errorf("unexpected value type %T (value %#v)", v, v)
}

//ToMonetaryAmount parses Valuer value(s) of the following structure:
//{
//	"@context": "http://schema.org/",
//	"@type": "MonetaryAmount",
//	"currency": "JPY",
//	"amount": 543
//},
func ToMonetaryAmount(colID string, row Valuer) (money MonetaryAmount, err error) {
	v, ok := row.GetValue(colID)
	if !ok {
		return MonetaryAmount{}, nil
	}

	if mapVal, ok := v.(map[string]interface{}); ok {
		return newMoneyFromInterface(mapVal)
	}

	return MonetaryAmount{}, fmt.Errorf("unexpected value type %T (value %#v)", v, v)
}

func newPersonFromInterface(value map[string]interface{}) (Person, error) {
	valueType, _ := value["@type"].(string)

	if valueType != "Person" {
		return Person{}, fmt.Errorf("value @type is not Person: %v", valueType)
	}

	return Person{
		Name:  value["name"].(string),
		Email: value["email"].(string),
	}, nil
}

func newAttachmentFromInterface(value map[string]interface{}) (Attachment, error) {
	valueType, _ := value["@type"].(string)

	if valueType != "ImageObject" {
		return Attachment{}, fmt.Errorf("value @type is not ImageObject: %v", valueType)
	}

	height, _ := value["height"].(float64)
	width, _ := value["width"].(float64)

	return Attachment{
		Name:   value["name"].(string),
		Height: int(height),
		Width:  int(width),
		URL:    value["url"].(string),
	}, nil
}

func newMoneyFromInterface(value map[string]interface{}) (MonetaryAmount, error) {
	valueType, _ := value["@type"].(string)

	if valueType != "MonetaryAmount" {
		return MonetaryAmount{}, fmt.Errorf("value @type is not MonetaryAmount: %v", valueType)
	}

	amount, _ := value["amount"].(float64)

	return MonetaryAmount{
		Currency: value["currency"].(string),
		Amount:   amount,
	}, nil
}

//endregion

//region Data structs

// AllEmployees is DTO for All employees table
type AllEmployees struct {
	Name                 string
	StartDate            time.Time
	EndDate              time.Time
	ContractHourRate     float64
	OpeningDateIP        time.Time
	WorkingNow           bool
	EnglishFullName      string
	LegalEntity          LegalEntityLookup
	Location             LocationLookup
	FinanceSD            string
	GeneralSD            string
	ContractNumber       string
	ContractDate         string
	LegalForm            string
	BankTariff           BankTariffsLookup
	Rounding             float64
	BankDetails          BankDetailsLookup
	SpecialPaymentPolicy bool
	RequiredFields       string
	Valid                bool
	InvalidFields        string
}

func NewAllEmployees(row Valuer) (dto AllEmployees, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Name, err = ToString(ID.Table.AllEmployees.Cols.Name.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AllEmployees.Cols.Name.Name, ID.Table.AllEmployees.Cols.Name.ID, err))
	}
	if dto.StartDate, err = ToDate(ID.Table.AllEmployees.Cols.StartDate.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AllEmployees.Cols.StartDate.Name, ID.Table.AllEmployees.Cols.StartDate.ID, err))
	}
	if dto.EndDate, err = ToDate(ID.Table.AllEmployees.Cols.EndDate.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AllEmployees.Cols.EndDate.Name, ID.Table.AllEmployees.Cols.EndDate.ID, err))
	}
	if dto.ContractHourRate, err = ToFloat64(ID.Table.AllEmployees.Cols.ContractHourRate.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AllEmployees.Cols.ContractHourRate.Name, ID.Table.AllEmployees.Cols.ContractHourRate.ID, err))
	}
	if dto.OpeningDateIP, err = ToDate(ID.Table.AllEmployees.Cols.OpeningDateIP.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AllEmployees.Cols.OpeningDateIP.Name, ID.Table.AllEmployees.Cols.OpeningDateIP.ID, err))
	}
	if dto.WorkingNow, err = ToBool(ID.Table.AllEmployees.Cols.WorkingNow.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AllEmployees.Cols.WorkingNow.Name, ID.Table.AllEmployees.Cols.WorkingNow.ID, err))
	}
	if dto.EnglishFullName, err = ToString(ID.Table.AllEmployees.Cols.EnglishFullName.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AllEmployees.Cols.EnglishFullName.Name, ID.Table.AllEmployees.Cols.EnglishFullName.ID, err))
	}
	if dto.LegalEntity, err = ToLegalEntityLookup(ID.Table.AllEmployees.Cols.LegalEntity.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AllEmployees.Cols.LegalEntity.Name, ID.Table.AllEmployees.Cols.LegalEntity.ID, err))
	}
	if dto.Location, err = ToLocationLookup(ID.Table.AllEmployees.Cols.Location.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AllEmployees.Cols.Location.Name, ID.Table.AllEmployees.Cols.Location.ID, err))
	}
	if dto.FinanceSD, err = ToString(ID.Table.AllEmployees.Cols.FinanceSD.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AllEmployees.Cols.FinanceSD.Name, ID.Table.AllEmployees.Cols.FinanceSD.ID, err))
	}
	if dto.GeneralSD, err = ToString(ID.Table.AllEmployees.Cols.GeneralSD.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AllEmployees.Cols.GeneralSD.Name, ID.Table.AllEmployees.Cols.GeneralSD.ID, err))
	}
	if dto.ContractNumber, err = ToString(ID.Table.AllEmployees.Cols.ContractNumber.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AllEmployees.Cols.ContractNumber.Name, ID.Table.AllEmployees.Cols.ContractNumber.ID, err))
	}
	if dto.ContractDate, err = ToString(ID.Table.AllEmployees.Cols.ContractDate.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AllEmployees.Cols.ContractDate.Name, ID.Table.AllEmployees.Cols.ContractDate.ID, err))
	}
	if dto.LegalForm, err = ToString(ID.Table.AllEmployees.Cols.LegalForm.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AllEmployees.Cols.LegalForm.Name, ID.Table.AllEmployees.Cols.LegalForm.ID, err))
	}
	if dto.BankTariff, err = ToBankTariffsLookup(ID.Table.AllEmployees.Cols.BankTariff.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AllEmployees.Cols.BankTariff.Name, ID.Table.AllEmployees.Cols.BankTariff.ID, err))
	}
	if dto.Rounding, err = ToFloat64(ID.Table.AllEmployees.Cols.Rounding.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AllEmployees.Cols.Rounding.Name, ID.Table.AllEmployees.Cols.Rounding.ID, err))
	}
	if dto.BankDetails, err = ToBankDetailsLookup(ID.Table.AllEmployees.Cols.BankDetails.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AllEmployees.Cols.BankDetails.Name, ID.Table.AllEmployees.Cols.BankDetails.ID, err))
	}
	if dto.SpecialPaymentPolicy, err = ToBool(ID.Table.AllEmployees.Cols.SpecialPaymentPolicy.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AllEmployees.Cols.SpecialPaymentPolicy.Name, ID.Table.AllEmployees.Cols.SpecialPaymentPolicy.ID, err))
	}
	if dto.RequiredFields, err = ToString(ID.Table.AllEmployees.Cols.RequiredFields.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AllEmployees.Cols.RequiredFields.Name, ID.Table.AllEmployees.Cols.RequiredFields.ID, err))
	}
	if dto.Valid, err = ToBool(ID.Table.AllEmployees.Cols.Valid.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AllEmployees.Cols.Valid.Name, ID.Table.AllEmployees.Cols.Valid.ID, err))
	}
	if dto.InvalidFields, err = ToString(ID.Table.AllEmployees.Cols.InvalidFields.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AllEmployees.Cols.InvalidFields.Name, ID.Table.AllEmployees.Cols.InvalidFields.ID, err))
	}

	if len(errc) > 0 {
		return AllEmployees{}, errc
	}

	return
}

// Invoice is DTO for Invoice table
type Invoice struct {
	ID                  string
	InvoiceHash         string
	Month               MonthsLookup
	Employee            AllEmployeesLookup
	PreviousInvoice     InvoiceLookup
	EURRUBExpected      float64
	EURSubtotal         float64
	EURRounding         float64
	EUREntries          float64
	Hours               float64
	EURRUBActual        float64
	RUBActual           float64
	RUBRateError        float64
	InvoiceEntries      EntriesLookup
	RUBEntries          float64
	PaymentChecksPassed bool
	TemplatesRefs       TemplateEntriesLookup
	RecipientDetails    BankDetailsLookup
	EURTotal            float64
	ApprovedManually    bool
	SenderDetails       LegalEntityLookup
	RUBTotal            float64
	HourRate            float64
	WorkDays            float64
	ContractDate        string
	ContractNumber      string
	Checks              string
	Alerts              string
}

func NewInvoice(row Valuer) (dto Invoice, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.ID, err = ToString(ID.Table.Invoice.Cols.ID.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Invoice.Cols.ID.Name, ID.Table.Invoice.Cols.ID.ID, err))
	}
	if dto.InvoiceHash, err = ToString(ID.Table.Invoice.Cols.InvoiceHash.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Invoice.Cols.InvoiceHash.Name, ID.Table.Invoice.Cols.InvoiceHash.ID, err))
	}
	if dto.Month, err = ToMonthsLookup(ID.Table.Invoice.Cols.Month.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Invoice.Cols.Month.Name, ID.Table.Invoice.Cols.Month.ID, err))
	}
	if dto.Employee, err = ToAllEmployeesLookup(ID.Table.Invoice.Cols.Employee.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Invoice.Cols.Employee.Name, ID.Table.Invoice.Cols.Employee.ID, err))
	}
	if dto.PreviousInvoice, err = ToInvoiceLookup(ID.Table.Invoice.Cols.PreviousInvoice.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Invoice.Cols.PreviousInvoice.Name, ID.Table.Invoice.Cols.PreviousInvoice.ID, err))
	}
	if dto.EURRUBExpected, err = ToFloat64(ID.Table.Invoice.Cols.EURRUBExpected.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Invoice.Cols.EURRUBExpected.Name, ID.Table.Invoice.Cols.EURRUBExpected.ID, err))
	}
	if dto.EURSubtotal, err = ToFloat64(ID.Table.Invoice.Cols.EURSubtotal.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Invoice.Cols.EURSubtotal.Name, ID.Table.Invoice.Cols.EURSubtotal.ID, err))
	}
	if dto.EURRounding, err = ToFloat64(ID.Table.Invoice.Cols.EURRounding.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Invoice.Cols.EURRounding.Name, ID.Table.Invoice.Cols.EURRounding.ID, err))
	}
	if dto.EUREntries, err = ToFloat64(ID.Table.Invoice.Cols.EUREntries.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Invoice.Cols.EUREntries.Name, ID.Table.Invoice.Cols.EUREntries.ID, err))
	}
	if dto.Hours, err = ToFloat64(ID.Table.Invoice.Cols.Hours.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Invoice.Cols.Hours.Name, ID.Table.Invoice.Cols.Hours.ID, err))
	}
	if dto.EURRUBActual, err = ToFloat64(ID.Table.Invoice.Cols.EURRUBActual.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Invoice.Cols.EURRUBActual.Name, ID.Table.Invoice.Cols.EURRUBActual.ID, err))
	}
	if dto.RUBActual, err = ToFloat64(ID.Table.Invoice.Cols.RUBActual.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Invoice.Cols.RUBActual.Name, ID.Table.Invoice.Cols.RUBActual.ID, err))
	}
	if dto.RUBRateError, err = ToFloat64(ID.Table.Invoice.Cols.RUBRateError.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Invoice.Cols.RUBRateError.Name, ID.Table.Invoice.Cols.RUBRateError.ID, err))
	}
	if dto.InvoiceEntries, err = ToEntriesLookup(ID.Table.Invoice.Cols.InvoiceEntries.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Invoice.Cols.InvoiceEntries.Name, ID.Table.Invoice.Cols.InvoiceEntries.ID, err))
	}
	if dto.RUBEntries, err = ToFloat64(ID.Table.Invoice.Cols.RUBEntries.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Invoice.Cols.RUBEntries.Name, ID.Table.Invoice.Cols.RUBEntries.ID, err))
	}
	if dto.PaymentChecksPassed, err = ToBool(ID.Table.Invoice.Cols.PaymentChecksPassed.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Invoice.Cols.PaymentChecksPassed.Name, ID.Table.Invoice.Cols.PaymentChecksPassed.ID, err))
	}
	if dto.TemplatesRefs, err = ToTemplateEntriesLookup(ID.Table.Invoice.Cols.TemplatesRefs.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Invoice.Cols.TemplatesRefs.Name, ID.Table.Invoice.Cols.TemplatesRefs.ID, err))
	}
	if dto.RecipientDetails, err = ToBankDetailsLookup(ID.Table.Invoice.Cols.RecipientDetails.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Invoice.Cols.RecipientDetails.Name, ID.Table.Invoice.Cols.RecipientDetails.ID, err))
	}
	if dto.EURTotal, err = ToFloat64(ID.Table.Invoice.Cols.EURTotal.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Invoice.Cols.EURTotal.Name, ID.Table.Invoice.Cols.EURTotal.ID, err))
	}
	if dto.ApprovedManually, err = ToBool(ID.Table.Invoice.Cols.ApprovedManually.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Invoice.Cols.ApprovedManually.Name, ID.Table.Invoice.Cols.ApprovedManually.ID, err))
	}
	if dto.SenderDetails, err = ToLegalEntityLookup(ID.Table.Invoice.Cols.SenderDetails.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Invoice.Cols.SenderDetails.Name, ID.Table.Invoice.Cols.SenderDetails.ID, err))
	}
	if dto.RUBTotal, err = ToFloat64(ID.Table.Invoice.Cols.RUBTotal.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Invoice.Cols.RUBTotal.Name, ID.Table.Invoice.Cols.RUBTotal.ID, err))
	}
	if dto.HourRate, err = ToFloat64(ID.Table.Invoice.Cols.HourRate.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Invoice.Cols.HourRate.Name, ID.Table.Invoice.Cols.HourRate.ID, err))
	}
	if dto.WorkDays, err = ToFloat64(ID.Table.Invoice.Cols.WorkDays.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Invoice.Cols.WorkDays.Name, ID.Table.Invoice.Cols.WorkDays.ID, err))
	}
	if dto.ContractDate, err = ToString(ID.Table.Invoice.Cols.ContractDate.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Invoice.Cols.ContractDate.Name, ID.Table.Invoice.Cols.ContractDate.ID, err))
	}
	if dto.ContractNumber, err = ToString(ID.Table.Invoice.Cols.ContractNumber.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Invoice.Cols.ContractNumber.Name, ID.Table.Invoice.Cols.ContractNumber.ID, err))
	}
	if dto.Checks, err = ToString(ID.Table.Invoice.Cols.Checks.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Invoice.Cols.Checks.Name, ID.Table.Invoice.Cols.Checks.ID, err))
	}
	if dto.Alerts, err = ToString(ID.Table.Invoice.Cols.Alerts.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Invoice.Cols.Alerts.Name, ID.Table.Invoice.Cols.Alerts.ID, err))
	}

	if len(errc) > 0 {
		return Invoice{}, errc
	}

	return
}

// Months is DTO for Months table
type Months struct {
	Month             time.Time
	Year              float64
	ID                string
	PreviousMonthLink MonthsLookup
	PreviousMonth     time.Time
	Current           bool
	Near              bool
	Future            bool
	Upcoming          bool
}

func NewMonths(row Valuer) (dto Months, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Month, err = ToDate(ID.Table.Months.Cols.Month.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Months.Cols.Month.Name, ID.Table.Months.Cols.Month.ID, err))
	}
	if dto.Year, err = ToFloat64(ID.Table.Months.Cols.Year.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Months.Cols.Year.Name, ID.Table.Months.Cols.Year.ID, err))
	}
	if dto.ID, err = ToString(ID.Table.Months.Cols.ID.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Months.Cols.ID.Name, ID.Table.Months.Cols.ID.ID, err))
	}
	if dto.PreviousMonthLink, err = ToMonthsLookup(ID.Table.Months.Cols.PreviousMonthLink.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Months.Cols.PreviousMonthLink.Name, ID.Table.Months.Cols.PreviousMonthLink.ID, err))
	}
	if dto.PreviousMonth, err = ToDate(ID.Table.Months.Cols.PreviousMonth.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Months.Cols.PreviousMonth.Name, ID.Table.Months.Cols.PreviousMonth.ID, err))
	}
	if dto.Current, err = ToBool(ID.Table.Months.Cols.Current.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Months.Cols.Current.Name, ID.Table.Months.Cols.Current.ID, err))
	}
	if dto.Near, err = ToBool(ID.Table.Months.Cols.Near.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Months.Cols.Near.Name, ID.Table.Months.Cols.Near.ID, err))
	}
	if dto.Future, err = ToBool(ID.Table.Months.Cols.Future.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Months.Cols.Future.Name, ID.Table.Months.Cols.Future.ID, err))
	}
	if dto.Upcoming, err = ToBool(ID.Table.Months.Cols.Upcoming.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Months.Cols.Upcoming.Name, ID.Table.Months.Cols.Upcoming.ID, err))
	}

	if len(errc) > 0 {
		return Months{}, errc
	}

	return
}

// Entries is DTO for Entries table
type Entries struct {
	Comment        string
	EURAmount      float64
	RUBAmount      float64
	Invoice        InvoiceLookup
	Display        string
	Type           EntryTypeLookup
	ModifiedOn     time.Time
	CreatedOn      time.Time
	Origin         string
	ModifiedBy     []Person
	Sort           float64
	RUBAmountInEUR float64
	Month          MonthsLookup
}

func NewEntries(row Valuer) (dto Entries, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Comment, err = ToString(ID.Table.Entries.Cols.Comment.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Entries.Cols.Comment.Name, ID.Table.Entries.Cols.Comment.ID, err))
	}
	if dto.EURAmount, err = ToFloat64(ID.Table.Entries.Cols.EURAmount.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Entries.Cols.EURAmount.Name, ID.Table.Entries.Cols.EURAmount.ID, err))
	}
	if dto.RUBAmount, err = ToFloat64(ID.Table.Entries.Cols.RUBAmount.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Entries.Cols.RUBAmount.Name, ID.Table.Entries.Cols.RUBAmount.ID, err))
	}
	if dto.Invoice, err = ToInvoiceLookup(ID.Table.Entries.Cols.Invoice.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Entries.Cols.Invoice.Name, ID.Table.Entries.Cols.Invoice.ID, err))
	}
	if dto.Display, err = ToString(ID.Table.Entries.Cols.Display.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Entries.Cols.Display.Name, ID.Table.Entries.Cols.Display.ID, err))
	}
	if dto.Type, err = ToEntryTypeLookup(ID.Table.Entries.Cols.Type.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Entries.Cols.Type.Name, ID.Table.Entries.Cols.Type.ID, err))
	}
	if dto.ModifiedOn, err = ToDateTime(ID.Table.Entries.Cols.ModifiedOn.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Entries.Cols.ModifiedOn.Name, ID.Table.Entries.Cols.ModifiedOn.ID, err))
	}
	if dto.CreatedOn, err = ToDateTime(ID.Table.Entries.Cols.CreatedOn.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Entries.Cols.CreatedOn.Name, ID.Table.Entries.Cols.CreatedOn.ID, err))
	}
	if dto.Origin, err = ToString(ID.Table.Entries.Cols.Origin.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Entries.Cols.Origin.Name, ID.Table.Entries.Cols.Origin.ID, err))
	}
	if dto.ModifiedBy, err = ToPersons(ID.Table.Entries.Cols.ModifiedBy.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Entries.Cols.ModifiedBy.Name, ID.Table.Entries.Cols.ModifiedBy.ID, err))
	}
	if dto.Sort, err = ToFloat64(ID.Table.Entries.Cols.Sort.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Entries.Cols.Sort.Name, ID.Table.Entries.Cols.Sort.ID, err))
	}
	if dto.RUBAmountInEUR, err = ToFloat64(ID.Table.Entries.Cols.RUBAmountInEUR.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Entries.Cols.RUBAmountInEUR.Name, ID.Table.Entries.Cols.RUBAmountInEUR.ID, err))
	}
	if dto.Month, err = ToMonthsLookup(ID.Table.Entries.Cols.Month.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Entries.Cols.Month.Name, ID.Table.Entries.Cols.Month.ID, err))
	}

	if len(errc) > 0 {
		return Entries{}, errc
	}

	return
}

// WorkingEmployees is DTO for Working Employees table
type WorkingEmployees struct {
	Name                 string
	StartDate            time.Time
	GeneralSD            string
	FinanceSD            string
	Location             LocationLookup
	LegalEntity          LegalEntityLookup
	LegalForm            string
	BankTariff           BankTariffsLookup
	SpecialPaymentPolicy bool
	EnglishFullName      string
	ContractNumber       string
	ContractDate         string
	BankDetails          BankDetailsLookup
}

func NewWorkingEmployees(row Valuer) (dto WorkingEmployees, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Name, err = ToString(ID.Table.WorkingEmployees.Cols.Name.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.WorkingEmployees.Cols.Name.Name, ID.Table.WorkingEmployees.Cols.Name.ID, err))
	}
	if dto.StartDate, err = ToDate(ID.Table.WorkingEmployees.Cols.StartDate.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.WorkingEmployees.Cols.StartDate.Name, ID.Table.WorkingEmployees.Cols.StartDate.ID, err))
	}
	if dto.GeneralSD, err = ToString(ID.Table.WorkingEmployees.Cols.GeneralSD.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.WorkingEmployees.Cols.GeneralSD.Name, ID.Table.WorkingEmployees.Cols.GeneralSD.ID, err))
	}
	if dto.FinanceSD, err = ToString(ID.Table.WorkingEmployees.Cols.FinanceSD.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.WorkingEmployees.Cols.FinanceSD.Name, ID.Table.WorkingEmployees.Cols.FinanceSD.ID, err))
	}
	if dto.Location, err = ToLocationLookup(ID.Table.WorkingEmployees.Cols.Location.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.WorkingEmployees.Cols.Location.Name, ID.Table.WorkingEmployees.Cols.Location.ID, err))
	}
	if dto.LegalEntity, err = ToLegalEntityLookup(ID.Table.WorkingEmployees.Cols.LegalEntity.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.WorkingEmployees.Cols.LegalEntity.Name, ID.Table.WorkingEmployees.Cols.LegalEntity.ID, err))
	}
	if dto.LegalForm, err = ToString(ID.Table.WorkingEmployees.Cols.LegalForm.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.WorkingEmployees.Cols.LegalForm.Name, ID.Table.WorkingEmployees.Cols.LegalForm.ID, err))
	}
	if dto.BankTariff, err = ToBankTariffsLookup(ID.Table.WorkingEmployees.Cols.BankTariff.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.WorkingEmployees.Cols.BankTariff.Name, ID.Table.WorkingEmployees.Cols.BankTariff.ID, err))
	}
	if dto.SpecialPaymentPolicy, err = ToBool(ID.Table.WorkingEmployees.Cols.SpecialPaymentPolicy.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.WorkingEmployees.Cols.SpecialPaymentPolicy.Name, ID.Table.WorkingEmployees.Cols.SpecialPaymentPolicy.ID, err))
	}
	if dto.EnglishFullName, err = ToString(ID.Table.WorkingEmployees.Cols.EnglishFullName.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.WorkingEmployees.Cols.EnglishFullName.Name, ID.Table.WorkingEmployees.Cols.EnglishFullName.ID, err))
	}
	if dto.ContractNumber, err = ToString(ID.Table.WorkingEmployees.Cols.ContractNumber.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.WorkingEmployees.Cols.ContractNumber.Name, ID.Table.WorkingEmployees.Cols.ContractNumber.ID, err))
	}
	if dto.ContractDate, err = ToString(ID.Table.WorkingEmployees.Cols.ContractDate.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.WorkingEmployees.Cols.ContractDate.Name, ID.Table.WorkingEmployees.Cols.ContractDate.ID, err))
	}
	if dto.BankDetails, err = ToBankDetailsLookup(ID.Table.WorkingEmployees.Cols.BankDetails.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.WorkingEmployees.Cols.BankDetails.Name, ID.Table.WorkingEmployees.Cols.BankDetails.ID, err))
	}

	if len(errc) > 0 {
		return WorkingEmployees{}, errc
	}

	return
}

// WorkingEmployeesNames is DTO for Working employees names table
type WorkingEmployeesNames struct {
	Name      string
	StartDate time.Time
	Location  LocationLookup
}

func NewWorkingEmployeesNames(row Valuer) (dto WorkingEmployeesNames, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Name, err = ToString(ID.Table.WorkingEmployeesNames.Cols.Name.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.WorkingEmployeesNames.Cols.Name.Name, ID.Table.WorkingEmployeesNames.Cols.Name.ID, err))
	}
	if dto.StartDate, err = ToDate(ID.Table.WorkingEmployeesNames.Cols.StartDate.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.WorkingEmployeesNames.Cols.StartDate.Name, ID.Table.WorkingEmployeesNames.Cols.StartDate.ID, err))
	}
	if dto.Location, err = ToLocationLookup(ID.Table.WorkingEmployeesNames.Cols.Location.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.WorkingEmployeesNames.Cols.Location.Name, ID.Table.WorkingEmployeesNames.Cols.Location.ID, err))
	}

	if len(errc) > 0 {
		return WorkingEmployeesNames{}, errc
	}

	return
}

// InvoicesOverview is DTO for Invoices overview table
type InvoicesOverview struct {
	Employee            AllEmployeesLookup
	Month               MonthsLookup
	PaymentChecksPassed bool
	RUBEntries          float64
	InvoiceEntries      EntriesLookup
	EURRUBExpected      float64
	EURRUBActual        float64
	EURSubtotal         float64
	EURRounding         float64
	EUREntries          float64
	RUBRateError        float64
	RecipientDetails    BankDetailsLookup
}

func NewInvoicesOverview(row Valuer) (dto InvoicesOverview, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Employee, err = ToAllEmployeesLookup(ID.Table.InvoicesOverview.Cols.Employee.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.InvoicesOverview.Cols.Employee.Name, ID.Table.InvoicesOverview.Cols.Employee.ID, err))
	}
	if dto.Month, err = ToMonthsLookup(ID.Table.InvoicesOverview.Cols.Month.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.InvoicesOverview.Cols.Month.Name, ID.Table.InvoicesOverview.Cols.Month.ID, err))
	}
	if dto.PaymentChecksPassed, err = ToBool(ID.Table.InvoicesOverview.Cols.PaymentChecksPassed.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.InvoicesOverview.Cols.PaymentChecksPassed.Name, ID.Table.InvoicesOverview.Cols.PaymentChecksPassed.ID, err))
	}
	if dto.RUBEntries, err = ToFloat64(ID.Table.InvoicesOverview.Cols.RUBEntries.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.InvoicesOverview.Cols.RUBEntries.Name, ID.Table.InvoicesOverview.Cols.RUBEntries.ID, err))
	}
	if dto.InvoiceEntries, err = ToEntriesLookup(ID.Table.InvoicesOverview.Cols.InvoiceEntries.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.InvoicesOverview.Cols.InvoiceEntries.Name, ID.Table.InvoicesOverview.Cols.InvoiceEntries.ID, err))
	}
	if dto.EURRUBExpected, err = ToFloat64(ID.Table.InvoicesOverview.Cols.EURRUBExpected.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.InvoicesOverview.Cols.EURRUBExpected.Name, ID.Table.InvoicesOverview.Cols.EURRUBExpected.ID, err))
	}
	if dto.EURRUBActual, err = ToFloat64(ID.Table.InvoicesOverview.Cols.EURRUBActual.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.InvoicesOverview.Cols.EURRUBActual.Name, ID.Table.InvoicesOverview.Cols.EURRUBActual.ID, err))
	}
	if dto.EURSubtotal, err = ToFloat64(ID.Table.InvoicesOverview.Cols.EURSubtotal.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.InvoicesOverview.Cols.EURSubtotal.Name, ID.Table.InvoicesOverview.Cols.EURSubtotal.ID, err))
	}
	if dto.EURRounding, err = ToFloat64(ID.Table.InvoicesOverview.Cols.EURRounding.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.InvoicesOverview.Cols.EURRounding.Name, ID.Table.InvoicesOverview.Cols.EURRounding.ID, err))
	}
	if dto.EUREntries, err = ToFloat64(ID.Table.InvoicesOverview.Cols.EUREntries.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.InvoicesOverview.Cols.EUREntries.Name, ID.Table.InvoicesOverview.Cols.EUREntries.ID, err))
	}
	if dto.RUBRateError, err = ToFloat64(ID.Table.InvoicesOverview.Cols.RUBRateError.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.InvoicesOverview.Cols.RUBRateError.Name, ID.Table.InvoicesOverview.Cols.RUBRateError.ID, err))
	}
	if dto.RecipientDetails, err = ToBankDetailsLookup(ID.Table.InvoicesOverview.Cols.RecipientDetails.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.InvoicesOverview.Cols.RecipientDetails.Name, ID.Table.InvoicesOverview.Cols.RecipientDetails.ID, err))
	}

	if len(errc) > 0 {
		return InvoicesOverview{}, errc
	}

	return
}

// PatentCompensation is DTO for Patent compensation table
type PatentCompensation struct {
	PaymentInvoice     InvoiceLookup
	PeriodCost         float64
	Period             string
	PeriodCostOverride float64
	EmployeePatentRef  EmployeePatentsLookup
	Apply              string
}

func NewPatentCompensation(row Valuer) (dto PatentCompensation, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.PaymentInvoice, err = ToInvoiceLookup(ID.Table.PatentCompensation.Cols.PaymentInvoice.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PatentCompensation.Cols.PaymentInvoice.Name, ID.Table.PatentCompensation.Cols.PaymentInvoice.ID, err))
	}
	if dto.PeriodCost, err = ToFloat64(ID.Table.PatentCompensation.Cols.PeriodCost.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PatentCompensation.Cols.PeriodCost.Name, ID.Table.PatentCompensation.Cols.PeriodCost.ID, err))
	}
	if dto.Period, err = ToString(ID.Table.PatentCompensation.Cols.Period.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PatentCompensation.Cols.Period.Name, ID.Table.PatentCompensation.Cols.Period.ID, err))
	}
	if dto.PeriodCostOverride, err = ToFloat64(ID.Table.PatentCompensation.Cols.PeriodCostOverride.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PatentCompensation.Cols.PeriodCostOverride.Name, ID.Table.PatentCompensation.Cols.PeriodCostOverride.ID, err))
	}
	if dto.EmployeePatentRef, err = ToEmployeePatentsLookup(ID.Table.PatentCompensation.Cols.EmployeePatentRef.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PatentCompensation.Cols.EmployeePatentRef.Name, ID.Table.PatentCompensation.Cols.EmployeePatentRef.ID, err))
	}
	if dto.Apply, err = ToString(ID.Table.PatentCompensation.Cols.Apply.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PatentCompensation.Cols.Apply.Name, ID.Table.PatentCompensation.Cols.Apply.ID, err))
	}

	if len(errc) > 0 {
		return PatentCompensation{}, errc
	}

	return
}

// EntryType is DTO for Entry Type table
type EntryType struct {
	Type      string
	Comment   string
	Archetype string
	Sort      float64
}

func NewEntryType(row Valuer) (dto EntryType, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Type, err = ToString(ID.Table.EntryType.Cols.Type.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EntryType.Cols.Type.Name, ID.Table.EntryType.Cols.Type.ID, err))
	}
	if dto.Comment, err = ToString(ID.Table.EntryType.Cols.Comment.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EntryType.Cols.Comment.Name, ID.Table.EntryType.Cols.Comment.ID, err))
	}
	if dto.Archetype, err = ToString(ID.Table.EntryType.Cols.Archetype.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EntryType.Cols.Archetype.Name, ID.Table.EntryType.Cols.Archetype.ID, err))
	}
	if dto.Sort, err = ToFloat64(ID.Table.EntryType.Cols.Sort.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EntryType.Cols.Sort.Name, ID.Table.EntryType.Cols.Sort.ID, err))
	}

	if len(errc) > 0 {
		return EntryType{}, errc
	}

	return
}

// PatentsOverview is DTO for Patents overview table
type PatentsOverview struct {
	PaymentInvoice InvoiceLookup
	PeriodCost     float64
	Period         string
}

func NewPatentsOverview(row Valuer) (dto PatentsOverview, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.PaymentInvoice, err = ToInvoiceLookup(ID.Table.PatentsOverview.Cols.PaymentInvoice.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PatentsOverview.Cols.PaymentInvoice.Name, ID.Table.PatentsOverview.Cols.PaymentInvoice.ID, err))
	}
	if dto.PeriodCost, err = ToFloat64(ID.Table.PatentsOverview.Cols.PeriodCost.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PatentsOverview.Cols.PeriodCost.Name, ID.Table.PatentsOverview.Cols.PeriodCost.ID, err))
	}
	if dto.Period, err = ToString(ID.Table.PatentsOverview.Cols.Period.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PatentsOverview.Cols.Period.Name, ID.Table.PatentsOverview.Cols.Period.ID, err))
	}

	if len(errc) > 0 {
		return PatentsOverview{}, errc
	}

	return
}

// LegalEntity is DTO for Legal entity table
type LegalEntity struct {
	EntityName    string
	Requisites    string
	Taxable       bool
	OfficialName  string
	AccountNumber string
}

func NewLegalEntity(row Valuer) (dto LegalEntity, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.EntityName, err = ToString(ID.Table.LegalEntity.Cols.EntityName.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.LegalEntity.Cols.EntityName.Name, ID.Table.LegalEntity.Cols.EntityName.ID, err))
	}
	if dto.Requisites, err = ToString(ID.Table.LegalEntity.Cols.Requisites.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.LegalEntity.Cols.Requisites.Name, ID.Table.LegalEntity.Cols.Requisites.ID, err))
	}
	if dto.Taxable, err = ToBool(ID.Table.LegalEntity.Cols.Taxable.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.LegalEntity.Cols.Taxable.Name, ID.Table.LegalEntity.Cols.Taxable.ID, err))
	}
	if dto.OfficialName, err = ToString(ID.Table.LegalEntity.Cols.OfficialName.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.LegalEntity.Cols.OfficialName.Name, ID.Table.LegalEntity.Cols.OfficialName.ID, err))
	}
	if dto.AccountNumber, err = ToString(ID.Table.LegalEntity.Cols.AccountNumber.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.LegalEntity.Cols.AccountNumber.Name, ID.Table.LegalEntity.Cols.AccountNumber.ID, err))
	}

	if len(errc) > 0 {
		return LegalEntity{}, errc
	}

	return
}

// SalariesReport is DTO for Salaries report table
type SalariesReport struct {
	Name      string
	StartDate time.Time
}

func NewSalariesReport(row Valuer) (dto SalariesReport, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Name, err = ToString(ID.Table.SalariesReport.Cols.Name.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.SalariesReport.Cols.Name.Name, ID.Table.SalariesReport.Cols.Name.ID, err))
	}
	if dto.StartDate, err = ToDate(ID.Table.SalariesReport.Cols.StartDate.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.SalariesReport.Cols.StartDate.Name, ID.Table.SalariesReport.Cols.StartDate.ID, err))
	}

	if len(errc) > 0 {
		return SalariesReport{}, errc
	}

	return
}

// TaxYears is DTO for Tax years table
type TaxYears struct {
	Year                   float64
	PensionFundFixedPart   float64
	SocialInsurance        float64
	IsCurrent              bool
	PensionFundPercentPart float64
	CalendarDaysInYear     float64
}

func NewTaxYears(row Valuer) (dto TaxYears, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Year, err = ToFloat64(ID.Table.TaxYears.Cols.Year.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TaxYears.Cols.Year.Name, ID.Table.TaxYears.Cols.Year.ID, err))
	}
	if dto.PensionFundFixedPart, err = ToFloat64(ID.Table.TaxYears.Cols.PensionFundFixedPart.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TaxYears.Cols.PensionFundFixedPart.Name, ID.Table.TaxYears.Cols.PensionFundFixedPart.ID, err))
	}
	if dto.SocialInsurance, err = ToFloat64(ID.Table.TaxYears.Cols.SocialInsurance.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TaxYears.Cols.SocialInsurance.Name, ID.Table.TaxYears.Cols.SocialInsurance.ID, err))
	}
	if dto.IsCurrent, err = ToBool(ID.Table.TaxYears.Cols.IsCurrent.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TaxYears.Cols.IsCurrent.Name, ID.Table.TaxYears.Cols.IsCurrent.ID, err))
	}
	if dto.PensionFundPercentPart, err = ToFloat64(ID.Table.TaxYears.Cols.PensionFundPercentPart.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TaxYears.Cols.PensionFundPercentPart.Name, ID.Table.TaxYears.Cols.PensionFundPercentPart.ID, err))
	}
	if dto.CalendarDaysInYear, err = ToFloat64(ID.Table.TaxYears.Cols.CalendarDaysInYear.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TaxYears.Cols.CalendarDaysInYear.Name, ID.Table.TaxYears.Cols.CalendarDaysInYear.ID, err))
	}

	if len(errc) > 0 {
		return TaxYears{}, errc
	}

	return
}

// EmployeePatents is DTO for Employee Patents table
type EmployeePatents struct {
	Employee     AllEmployeesLookup
	Year         TaxYearsLookup
	Cost         float64
	Scan         []Attachment
	Date1        time.Time
	Date1Payment float64
	Date2        time.Time
	Date2Payment float64
	Display      string
}

func NewEmployeePatents(row Valuer) (dto EmployeePatents, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Employee, err = ToAllEmployeesLookup(ID.Table.EmployeePatents.Cols.Employee.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EmployeePatents.Cols.Employee.Name, ID.Table.EmployeePatents.Cols.Employee.ID, err))
	}
	if dto.Year, err = ToTaxYearsLookup(ID.Table.EmployeePatents.Cols.Year.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EmployeePatents.Cols.Year.Name, ID.Table.EmployeePatents.Cols.Year.ID, err))
	}
	if dto.Cost, err = ToFloat64(ID.Table.EmployeePatents.Cols.Cost.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EmployeePatents.Cols.Cost.Name, ID.Table.EmployeePatents.Cols.Cost.ID, err))
	}
	if dto.Scan, err = ToAttachments(ID.Table.EmployeePatents.Cols.Scan.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EmployeePatents.Cols.Scan.Name, ID.Table.EmployeePatents.Cols.Scan.ID, err))
	}
	if dto.Date1, err = ToDate(ID.Table.EmployeePatents.Cols.Date1.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EmployeePatents.Cols.Date1.Name, ID.Table.EmployeePatents.Cols.Date1.ID, err))
	}
	if dto.Date1Payment, err = ToFloat64(ID.Table.EmployeePatents.Cols.Date1Payment.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EmployeePatents.Cols.Date1Payment.Name, ID.Table.EmployeePatents.Cols.Date1Payment.ID, err))
	}
	if dto.Date2, err = ToDate(ID.Table.EmployeePatents.Cols.Date2.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EmployeePatents.Cols.Date2.Name, ID.Table.EmployeePatents.Cols.Date2.ID, err))
	}
	if dto.Date2Payment, err = ToFloat64(ID.Table.EmployeePatents.Cols.Date2Payment.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EmployeePatents.Cols.Date2Payment.Name, ID.Table.EmployeePatents.Cols.Date2Payment.ID, err))
	}
	if dto.Display, err = ToString(ID.Table.EmployeePatents.Cols.Display.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EmployeePatents.Cols.Display.Name, ID.Table.EmployeePatents.Cols.Display.ID, err))
	}

	if len(errc) > 0 {
		return EmployeePatents{}, errc
	}

	return
}

// FullPayrollReport is DTO for Full payroll report table
type FullPayrollReport struct {
	SalaryNet             float64
	InvoiceRef            InvoiceLookup
	OvertimesRefs         EntriesLookup
	OvertimesRUB          float64
	BonusesRefs           string
	BonusesRUB            float64
	PublicHolidaysRefs    EntriesLookup
	PublicHolidaysRUB     float64
	RestCorrectionRefs    EntriesLookup
	RestCorrectionsRUB    float64
	AnnualContribsRUB     float64
	StartDayRefs          EntriesLookup
	StartDayRUB           float64
	SalaryChangesRefs     EntriesLookup
	SalaryChangesRUB      float64
	LoansRefs             string
	LoansRUB              float64
	RUBServiceFees        float64
	EURRounding           float64
	AnnualUnpaidLeavesRUB float64
	MonthlyContribsEUR    float64
	QuitCompensationsRefs EntriesLookup
	QuitCompensationsRUB  float64
	PaidAnnualLeavesRefs  EntriesLookup
	Location              LocationLookup
}

func NewFullPayrollReport(row Valuer) (dto FullPayrollReport, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.SalaryNet, err = ToFloat64(ID.Table.FullPayrollReport.Cols.SalaryNet.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.FullPayrollReport.Cols.SalaryNet.Name, ID.Table.FullPayrollReport.Cols.SalaryNet.ID, err))
	}
	if dto.InvoiceRef, err = ToInvoiceLookup(ID.Table.FullPayrollReport.Cols.InvoiceRef.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.FullPayrollReport.Cols.InvoiceRef.Name, ID.Table.FullPayrollReport.Cols.InvoiceRef.ID, err))
	}
	if dto.OvertimesRefs, err = ToEntriesLookup(ID.Table.FullPayrollReport.Cols.OvertimesRefs.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.FullPayrollReport.Cols.OvertimesRefs.Name, ID.Table.FullPayrollReport.Cols.OvertimesRefs.ID, err))
	}
	if dto.OvertimesRUB, err = ToFloat64(ID.Table.FullPayrollReport.Cols.OvertimesRUB.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.FullPayrollReport.Cols.OvertimesRUB.Name, ID.Table.FullPayrollReport.Cols.OvertimesRUB.ID, err))
	}
	if dto.BonusesRefs, err = ToString(ID.Table.FullPayrollReport.Cols.BonusesRefs.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.FullPayrollReport.Cols.BonusesRefs.Name, ID.Table.FullPayrollReport.Cols.BonusesRefs.ID, err))
	}
	if dto.BonusesRUB, err = ToFloat64(ID.Table.FullPayrollReport.Cols.BonusesRUB.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.FullPayrollReport.Cols.BonusesRUB.Name, ID.Table.FullPayrollReport.Cols.BonusesRUB.ID, err))
	}
	if dto.PublicHolidaysRefs, err = ToEntriesLookup(ID.Table.FullPayrollReport.Cols.PublicHolidaysRefs.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.FullPayrollReport.Cols.PublicHolidaysRefs.Name, ID.Table.FullPayrollReport.Cols.PublicHolidaysRefs.ID, err))
	}
	if dto.PublicHolidaysRUB, err = ToFloat64(ID.Table.FullPayrollReport.Cols.PublicHolidaysRUB.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.FullPayrollReport.Cols.PublicHolidaysRUB.Name, ID.Table.FullPayrollReport.Cols.PublicHolidaysRUB.ID, err))
	}
	if dto.RestCorrectionRefs, err = ToEntriesLookup(ID.Table.FullPayrollReport.Cols.RestCorrectionRefs.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.FullPayrollReport.Cols.RestCorrectionRefs.Name, ID.Table.FullPayrollReport.Cols.RestCorrectionRefs.ID, err))
	}
	if dto.RestCorrectionsRUB, err = ToFloat64(ID.Table.FullPayrollReport.Cols.RestCorrectionsRUB.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.FullPayrollReport.Cols.RestCorrectionsRUB.Name, ID.Table.FullPayrollReport.Cols.RestCorrectionsRUB.ID, err))
	}
	if dto.AnnualContribsRUB, err = ToFloat64(ID.Table.FullPayrollReport.Cols.AnnualContribsRUB.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.FullPayrollReport.Cols.AnnualContribsRUB.Name, ID.Table.FullPayrollReport.Cols.AnnualContribsRUB.ID, err))
	}
	if dto.StartDayRefs, err = ToEntriesLookup(ID.Table.FullPayrollReport.Cols.StartDayRefs.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.FullPayrollReport.Cols.StartDayRefs.Name, ID.Table.FullPayrollReport.Cols.StartDayRefs.ID, err))
	}
	if dto.StartDayRUB, err = ToFloat64(ID.Table.FullPayrollReport.Cols.StartDayRUB.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.FullPayrollReport.Cols.StartDayRUB.Name, ID.Table.FullPayrollReport.Cols.StartDayRUB.ID, err))
	}
	if dto.SalaryChangesRefs, err = ToEntriesLookup(ID.Table.FullPayrollReport.Cols.SalaryChangesRefs.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.FullPayrollReport.Cols.SalaryChangesRefs.Name, ID.Table.FullPayrollReport.Cols.SalaryChangesRefs.ID, err))
	}
	if dto.SalaryChangesRUB, err = ToFloat64(ID.Table.FullPayrollReport.Cols.SalaryChangesRUB.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.FullPayrollReport.Cols.SalaryChangesRUB.Name, ID.Table.FullPayrollReport.Cols.SalaryChangesRUB.ID, err))
	}
	if dto.LoansRefs, err = ToString(ID.Table.FullPayrollReport.Cols.LoansRefs.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.FullPayrollReport.Cols.LoansRefs.Name, ID.Table.FullPayrollReport.Cols.LoansRefs.ID, err))
	}
	if dto.LoansRUB, err = ToFloat64(ID.Table.FullPayrollReport.Cols.LoansRUB.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.FullPayrollReport.Cols.LoansRUB.Name, ID.Table.FullPayrollReport.Cols.LoansRUB.ID, err))
	}
	if dto.RUBServiceFees, err = ToFloat64(ID.Table.FullPayrollReport.Cols.RUBServiceFees.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.FullPayrollReport.Cols.RUBServiceFees.Name, ID.Table.FullPayrollReport.Cols.RUBServiceFees.ID, err))
	}
	if dto.EURRounding, err = ToFloat64(ID.Table.FullPayrollReport.Cols.EURRounding.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.FullPayrollReport.Cols.EURRounding.Name, ID.Table.FullPayrollReport.Cols.EURRounding.ID, err))
	}
	if dto.AnnualUnpaidLeavesRUB, err = ToFloat64(ID.Table.FullPayrollReport.Cols.AnnualUnpaidLeavesRUB.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.FullPayrollReport.Cols.AnnualUnpaidLeavesRUB.Name, ID.Table.FullPayrollReport.Cols.AnnualUnpaidLeavesRUB.ID, err))
	}
	if dto.MonthlyContribsEUR, err = ToFloat64(ID.Table.FullPayrollReport.Cols.MonthlyContribsEUR.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.FullPayrollReport.Cols.MonthlyContribsEUR.Name, ID.Table.FullPayrollReport.Cols.MonthlyContribsEUR.ID, err))
	}
	if dto.QuitCompensationsRefs, err = ToEntriesLookup(ID.Table.FullPayrollReport.Cols.QuitCompensationsRefs.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.FullPayrollReport.Cols.QuitCompensationsRefs.Name, ID.Table.FullPayrollReport.Cols.QuitCompensationsRefs.ID, err))
	}
	if dto.QuitCompensationsRUB, err = ToFloat64(ID.Table.FullPayrollReport.Cols.QuitCompensationsRUB.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.FullPayrollReport.Cols.QuitCompensationsRUB.Name, ID.Table.FullPayrollReport.Cols.QuitCompensationsRUB.ID, err))
	}
	if dto.PaidAnnualLeavesRefs, err = ToEntriesLookup(ID.Table.FullPayrollReport.Cols.PaidAnnualLeavesRefs.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.FullPayrollReport.Cols.PaidAnnualLeavesRefs.Name, ID.Table.FullPayrollReport.Cols.PaidAnnualLeavesRefs.ID, err))
	}
	if dto.Location, err = ToLocationLookup(ID.Table.FullPayrollReport.Cols.Location.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.FullPayrollReport.Cols.Location.Name, ID.Table.FullPayrollReport.Cols.Location.ID, err))
	}

	if len(errc) > 0 {
		return FullPayrollReport{}, errc
	}

	return
}

// EmptyActualRates is DTO for Empty actual rates table
type EmptyActualRates struct {
	Month          MonthsLookup
	Employee       AllEmployeesLookup
	EURRUBExpected float64
	EURRUBActual   float64
}

func NewEmptyActualRates(row Valuer) (dto EmptyActualRates, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Month, err = ToMonthsLookup(ID.Table.EmptyActualRates.Cols.Month.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EmptyActualRates.Cols.Month.Name, ID.Table.EmptyActualRates.Cols.Month.ID, err))
	}
	if dto.Employee, err = ToAllEmployeesLookup(ID.Table.EmptyActualRates.Cols.Employee.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EmptyActualRates.Cols.Employee.Name, ID.Table.EmptyActualRates.Cols.Employee.ID, err))
	}
	if dto.EURRUBExpected, err = ToFloat64(ID.Table.EmptyActualRates.Cols.EURRUBExpected.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EmptyActualRates.Cols.EURRUBExpected.Name, ID.Table.EmptyActualRates.Cols.EURRUBExpected.ID, err))
	}
	if dto.EURRUBActual, err = ToFloat64(ID.Table.EmptyActualRates.Cols.EURRUBActual.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EmptyActualRates.Cols.EURRUBActual.Name, ID.Table.EmptyActualRates.Cols.EURRUBActual.ID, err))
	}

	if len(errc) > 0 {
		return EmptyActualRates{}, errc
	}

	return
}

// CorrectionsByType is DTO for Corrections by type table
type CorrectionsByType struct {
	Invoice   InvoiceLookup
	Type      EntryTypeLookup
	Comment   string
	RUBAmount float64
	EURAmount float64
}

func NewCorrectionsByType(row Valuer) (dto CorrectionsByType, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Invoice, err = ToInvoiceLookup(ID.Table.CorrectionsByType.Cols.Invoice.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CorrectionsByType.Cols.Invoice.Name, ID.Table.CorrectionsByType.Cols.Invoice.ID, err))
	}
	if dto.Type, err = ToEntryTypeLookup(ID.Table.CorrectionsByType.Cols.Type.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CorrectionsByType.Cols.Type.Name, ID.Table.CorrectionsByType.Cols.Type.ID, err))
	}
	if dto.Comment, err = ToString(ID.Table.CorrectionsByType.Cols.Comment.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CorrectionsByType.Cols.Comment.Name, ID.Table.CorrectionsByType.Cols.Comment.ID, err))
	}
	if dto.RUBAmount, err = ToFloat64(ID.Table.CorrectionsByType.Cols.RUBAmount.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CorrectionsByType.Cols.RUBAmount.Name, ID.Table.CorrectionsByType.Cols.RUBAmount.ID, err))
	}
	if dto.EURAmount, err = ToFloat64(ID.Table.CorrectionsByType.Cols.EURAmount.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CorrectionsByType.Cols.EURAmount.Name, ID.Table.CorrectionsByType.Cols.EURAmount.ID, err))
	}

	if len(errc) > 0 {
		return CorrectionsByType{}, errc
	}

	return
}

// PayrollReportToAdd is DTO for Payroll report to add table
type PayrollReportToAdd struct {
	Month    MonthsLookup
	Employee AllEmployeesLookup
}

func NewPayrollReportToAdd(row Valuer) (dto PayrollReportToAdd, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Month, err = ToMonthsLookup(ID.Table.PayrollReportToAdd.Cols.Month.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PayrollReportToAdd.Cols.Month.Name, ID.Table.PayrollReportToAdd.Cols.Month.ID, err))
	}
	if dto.Employee, err = ToAllEmployeesLookup(ID.Table.PayrollReportToAdd.Cols.Employee.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PayrollReportToAdd.Cols.Employee.Name, ID.Table.PayrollReportToAdd.Cols.Employee.ID, err))
	}

	if len(errc) > 0 {
		return PayrollReportToAdd{}, errc
	}

	return
}

// BankTariffs is DTO for Bank tariffs table
type BankTariffs struct {
	Name              string
	DefaultCCFee      float64
	DefaultServiceFee float64
}

func NewBankTariffs(row Valuer) (dto BankTariffs, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Name, err = ToString(ID.Table.BankTariffs.Cols.Name.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.BankTariffs.Cols.Name.Name, ID.Table.BankTariffs.Cols.Name.ID, err))
	}
	if dto.DefaultCCFee, err = ToFloat64(ID.Table.BankTariffs.Cols.DefaultCCFee.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.BankTariffs.Cols.DefaultCCFee.Name, ID.Table.BankTariffs.Cols.DefaultCCFee.ID, err))
	}
	if dto.DefaultServiceFee, err = ToFloat64(ID.Table.BankTariffs.Cols.DefaultServiceFee.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.BankTariffs.Cols.DefaultServiceFee.Name, ID.Table.BankTariffs.Cols.DefaultServiceFee.ID, err))
	}

	if len(errc) > 0 {
		return BankTariffs{}, errc
	}

	return
}

// PHCorrections is DTO for PH corrections table
type PHCorrections struct {
	Comment string
}

func NewPHCorrections(row Valuer) (dto PHCorrections, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Comment, err = ToString(ID.Table.PHCorrections.Cols.Comment.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PHCorrections.Cols.Comment.Name, ID.Table.PHCorrections.Cols.Comment.ID, err))
	}

	if len(errc) > 0 {
		return PHCorrections{}, errc
	}

	return
}

// PHMonthlyReport is DTO for PH Monthly Report table
type PHMonthlyReport struct {
	Month              MonthsLookup
	TotalCorrectionRUB float64
	TotalCorrectionEUR float64
}

func NewPHMonthlyReport(row Valuer) (dto PHMonthlyReport, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Month, err = ToMonthsLookup(ID.Table.PHMonthlyReport.Cols.Month.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PHMonthlyReport.Cols.Month.Name, ID.Table.PHMonthlyReport.Cols.Month.ID, err))
	}
	if dto.TotalCorrectionRUB, err = ToFloat64(ID.Table.PHMonthlyReport.Cols.TotalCorrectionRUB.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PHMonthlyReport.Cols.TotalCorrectionRUB.Name, ID.Table.PHMonthlyReport.Cols.TotalCorrectionRUB.ID, err))
	}
	if dto.TotalCorrectionEUR, err = ToFloat64(ID.Table.PHMonthlyReport.Cols.TotalCorrectionEUR.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PHMonthlyReport.Cols.TotalCorrectionEUR.Name, ID.Table.PHMonthlyReport.Cols.TotalCorrectionEUR.ID, err))
	}

	if len(errc) > 0 {
		return PHMonthlyReport{}, errc
	}

	return
}

// Location is DTO for Location table
type Location struct {
	Location string
}

func NewLocation(row Valuer) (dto Location, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Location, err = ToString(ID.Table.Location.Cols.Location.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Location.Cols.Location.Name, ID.Table.Location.Cols.Location.ID, err))
	}

	if len(errc) > 0 {
		return Location{}, errc
	}

	return
}

// CompanyRates is DTO for Company rates table
type CompanyRates struct {
	Month  MonthsLookup
	EURRUB float64
}

func NewCompanyRates(row Valuer) (dto CompanyRates, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Month, err = ToMonthsLookup(ID.Table.CompanyRates.Cols.Month.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CompanyRates.Cols.Month.Name, ID.Table.CompanyRates.Cols.Month.ID, err))
	}
	if dto.EURRUB, err = ToFloat64(ID.Table.CompanyRates.Cols.EURRUB.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CompanyRates.Cols.EURRUB.Name, ID.Table.CompanyRates.Cols.EURRUB.ID, err))
	}

	if len(errc) > 0 {
		return CompanyRates{}, errc
	}

	return
}

// SummaryForCurrentPeriod3 is DTO for Summary for current period 3 table
type SummaryForCurrentPeriod3 struct {
	Subject      string
	RUB          float64
	EUR          float64
	Location     LocationLookup
	LocationRefs FullPayrollReportLookup
}

func NewSummaryForCurrentPeriod3(row Valuer) (dto SummaryForCurrentPeriod3, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Subject, err = ToString(ID.Table.SummaryForCurrentPeriod3.Cols.Subject.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.SummaryForCurrentPeriod3.Cols.Subject.Name, ID.Table.SummaryForCurrentPeriod3.Cols.Subject.ID, err))
	}
	if dto.RUB, err = ToFloat64(ID.Table.SummaryForCurrentPeriod3.Cols.RUB.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.SummaryForCurrentPeriod3.Cols.RUB.Name, ID.Table.SummaryForCurrentPeriod3.Cols.RUB.ID, err))
	}
	if dto.EUR, err = ToFloat64(ID.Table.SummaryForCurrentPeriod3.Cols.EUR.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.SummaryForCurrentPeriod3.Cols.EUR.Name, ID.Table.SummaryForCurrentPeriod3.Cols.EUR.ID, err))
	}
	if dto.Location, err = ToLocationLookup(ID.Table.SummaryForCurrentPeriod3.Cols.Location.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.SummaryForCurrentPeriod3.Cols.Location.Name, ID.Table.SummaryForCurrentPeriod3.Cols.Location.ID, err))
	}
	if dto.LocationRefs, err = ToFullPayrollReportLookup(ID.Table.SummaryForCurrentPeriod3.Cols.LocationRefs.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.SummaryForCurrentPeriod3.Cols.LocationRefs.Name, ID.Table.SummaryForCurrentPeriod3.Cols.LocationRefs.ID, err))
	}

	if len(errc) > 0 {
		return SummaryForCurrentPeriod3{}, errc
	}

	return
}

// CurrentPayrollV2 is DTO for Current payroll v2 table
type CurrentPayrollV2 struct {
	InvoiceRef            InvoiceLookup
	Location              LocationLookup
	SalaryNet             float64
	RUBServiceFees        float64
	EURRounding           float64
	AnnualUnpaidLeavesRUB float64
	AnnualContribsRUB     float64
	MonthlyContribsEUR    float64
	PublicHolidaysRefs    EntriesLookup
	PublicHolidaysRUB     float64
	OvertimesRefs         EntriesLookup
	OvertimesRUB          float64
	BonusesRefs           string
	BonusesRUB            float64
	LoansRefs             string
	LoansRUB              float64
	SalaryChangesRefs     EntriesLookup
	SalaryChangesRUB      float64
	StartDayRefs          EntriesLookup
	StartDayRUB           float64
	QuitCompensationsRefs EntriesLookup
	QuitCompensationsRUB  float64
	PaidAnnualLeavesRefs  EntriesLookup
	RestCorrectionRefs    EntriesLookup
	RestCorrectionsRUB    float64
}

func NewCurrentPayrollV2(row Valuer) (dto CurrentPayrollV2, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.InvoiceRef, err = ToInvoiceLookup(ID.Table.CurrentPayrollV2.Cols.InvoiceRef.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentPayrollV2.Cols.InvoiceRef.Name, ID.Table.CurrentPayrollV2.Cols.InvoiceRef.ID, err))
	}
	if dto.Location, err = ToLocationLookup(ID.Table.CurrentPayrollV2.Cols.Location.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentPayrollV2.Cols.Location.Name, ID.Table.CurrentPayrollV2.Cols.Location.ID, err))
	}
	if dto.SalaryNet, err = ToFloat64(ID.Table.CurrentPayrollV2.Cols.SalaryNet.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentPayrollV2.Cols.SalaryNet.Name, ID.Table.CurrentPayrollV2.Cols.SalaryNet.ID, err))
	}
	if dto.RUBServiceFees, err = ToFloat64(ID.Table.CurrentPayrollV2.Cols.RUBServiceFees.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentPayrollV2.Cols.RUBServiceFees.Name, ID.Table.CurrentPayrollV2.Cols.RUBServiceFees.ID, err))
	}
	if dto.EURRounding, err = ToFloat64(ID.Table.CurrentPayrollV2.Cols.EURRounding.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentPayrollV2.Cols.EURRounding.Name, ID.Table.CurrentPayrollV2.Cols.EURRounding.ID, err))
	}
	if dto.AnnualUnpaidLeavesRUB, err = ToFloat64(ID.Table.CurrentPayrollV2.Cols.AnnualUnpaidLeavesRUB.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentPayrollV2.Cols.AnnualUnpaidLeavesRUB.Name, ID.Table.CurrentPayrollV2.Cols.AnnualUnpaidLeavesRUB.ID, err))
	}
	if dto.AnnualContribsRUB, err = ToFloat64(ID.Table.CurrentPayrollV2.Cols.AnnualContribsRUB.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentPayrollV2.Cols.AnnualContribsRUB.Name, ID.Table.CurrentPayrollV2.Cols.AnnualContribsRUB.ID, err))
	}
	if dto.MonthlyContribsEUR, err = ToFloat64(ID.Table.CurrentPayrollV2.Cols.MonthlyContribsEUR.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentPayrollV2.Cols.MonthlyContribsEUR.Name, ID.Table.CurrentPayrollV2.Cols.MonthlyContribsEUR.ID, err))
	}
	if dto.PublicHolidaysRefs, err = ToEntriesLookup(ID.Table.CurrentPayrollV2.Cols.PublicHolidaysRefs.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentPayrollV2.Cols.PublicHolidaysRefs.Name, ID.Table.CurrentPayrollV2.Cols.PublicHolidaysRefs.ID, err))
	}
	if dto.PublicHolidaysRUB, err = ToFloat64(ID.Table.CurrentPayrollV2.Cols.PublicHolidaysRUB.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentPayrollV2.Cols.PublicHolidaysRUB.Name, ID.Table.CurrentPayrollV2.Cols.PublicHolidaysRUB.ID, err))
	}
	if dto.OvertimesRefs, err = ToEntriesLookup(ID.Table.CurrentPayrollV2.Cols.OvertimesRefs.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentPayrollV2.Cols.OvertimesRefs.Name, ID.Table.CurrentPayrollV2.Cols.OvertimesRefs.ID, err))
	}
	if dto.OvertimesRUB, err = ToFloat64(ID.Table.CurrentPayrollV2.Cols.OvertimesRUB.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentPayrollV2.Cols.OvertimesRUB.Name, ID.Table.CurrentPayrollV2.Cols.OvertimesRUB.ID, err))
	}
	if dto.BonusesRefs, err = ToString(ID.Table.CurrentPayrollV2.Cols.BonusesRefs.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentPayrollV2.Cols.BonusesRefs.Name, ID.Table.CurrentPayrollV2.Cols.BonusesRefs.ID, err))
	}
	if dto.BonusesRUB, err = ToFloat64(ID.Table.CurrentPayrollV2.Cols.BonusesRUB.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentPayrollV2.Cols.BonusesRUB.Name, ID.Table.CurrentPayrollV2.Cols.BonusesRUB.ID, err))
	}
	if dto.LoansRefs, err = ToString(ID.Table.CurrentPayrollV2.Cols.LoansRefs.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentPayrollV2.Cols.LoansRefs.Name, ID.Table.CurrentPayrollV2.Cols.LoansRefs.ID, err))
	}
	if dto.LoansRUB, err = ToFloat64(ID.Table.CurrentPayrollV2.Cols.LoansRUB.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentPayrollV2.Cols.LoansRUB.Name, ID.Table.CurrentPayrollV2.Cols.LoansRUB.ID, err))
	}
	if dto.SalaryChangesRefs, err = ToEntriesLookup(ID.Table.CurrentPayrollV2.Cols.SalaryChangesRefs.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentPayrollV2.Cols.SalaryChangesRefs.Name, ID.Table.CurrentPayrollV2.Cols.SalaryChangesRefs.ID, err))
	}
	if dto.SalaryChangesRUB, err = ToFloat64(ID.Table.CurrentPayrollV2.Cols.SalaryChangesRUB.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentPayrollV2.Cols.SalaryChangesRUB.Name, ID.Table.CurrentPayrollV2.Cols.SalaryChangesRUB.ID, err))
	}
	if dto.StartDayRefs, err = ToEntriesLookup(ID.Table.CurrentPayrollV2.Cols.StartDayRefs.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentPayrollV2.Cols.StartDayRefs.Name, ID.Table.CurrentPayrollV2.Cols.StartDayRefs.ID, err))
	}
	if dto.StartDayRUB, err = ToFloat64(ID.Table.CurrentPayrollV2.Cols.StartDayRUB.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentPayrollV2.Cols.StartDayRUB.Name, ID.Table.CurrentPayrollV2.Cols.StartDayRUB.ID, err))
	}
	if dto.QuitCompensationsRefs, err = ToEntriesLookup(ID.Table.CurrentPayrollV2.Cols.QuitCompensationsRefs.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentPayrollV2.Cols.QuitCompensationsRefs.Name, ID.Table.CurrentPayrollV2.Cols.QuitCompensationsRefs.ID, err))
	}
	if dto.QuitCompensationsRUB, err = ToFloat64(ID.Table.CurrentPayrollV2.Cols.QuitCompensationsRUB.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentPayrollV2.Cols.QuitCompensationsRUB.Name, ID.Table.CurrentPayrollV2.Cols.QuitCompensationsRUB.ID, err))
	}
	if dto.PaidAnnualLeavesRefs, err = ToEntriesLookup(ID.Table.CurrentPayrollV2.Cols.PaidAnnualLeavesRefs.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentPayrollV2.Cols.PaidAnnualLeavesRefs.Name, ID.Table.CurrentPayrollV2.Cols.PaidAnnualLeavesRefs.ID, err))
	}
	if dto.RestCorrectionRefs, err = ToEntriesLookup(ID.Table.CurrentPayrollV2.Cols.RestCorrectionRefs.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentPayrollV2.Cols.RestCorrectionRefs.Name, ID.Table.CurrentPayrollV2.Cols.RestCorrectionRefs.ID, err))
	}
	if dto.RestCorrectionsRUB, err = ToFloat64(ID.Table.CurrentPayrollV2.Cols.RestCorrectionsRUB.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentPayrollV2.Cols.RestCorrectionsRUB.Name, ID.Table.CurrentPayrollV2.Cols.RestCorrectionsRUB.ID, err))
	}

	if len(errc) > 0 {
		return CurrentPayrollV2{}, errc
	}

	return
}

// HeadcountPerLocation is DTO for Headcount per location table
type HeadcountPerLocation struct {
	Location  LocationLookup
	Headcount float64
}

func NewHeadcountPerLocation(row Valuer) (dto HeadcountPerLocation, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Location, err = ToLocationLookup(ID.Table.HeadcountPerLocation.Cols.Location.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.HeadcountPerLocation.Cols.Location.Name, ID.Table.HeadcountPerLocation.Cols.Location.ID, err))
	}
	if dto.Headcount, err = ToFloat64(ID.Table.HeadcountPerLocation.Cols.Headcount.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.HeadcountPerLocation.Cols.Headcount.Name, ID.Table.HeadcountPerLocation.Cols.Headcount.ID, err))
	}

	if len(errc) > 0 {
		return HeadcountPerLocation{}, errc
	}

	return
}

// SuspiciousRates is DTO for Suspicious rates table
type SuspiciousRates struct {
	Month          MonthsLookup
	Employee       AllEmployeesLookup
	EURRUBExpected float64
	EURRUBActual   float64
}

func NewSuspiciousRates(row Valuer) (dto SuspiciousRates, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Month, err = ToMonthsLookup(ID.Table.SuspiciousRates.Cols.Month.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.SuspiciousRates.Cols.Month.Name, ID.Table.SuspiciousRates.Cols.Month.ID, err))
	}
	if dto.Employee, err = ToAllEmployeesLookup(ID.Table.SuspiciousRates.Cols.Employee.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.SuspiciousRates.Cols.Employee.Name, ID.Table.SuspiciousRates.Cols.Employee.ID, err))
	}
	if dto.EURRUBExpected, err = ToFloat64(ID.Table.SuspiciousRates.Cols.EURRUBExpected.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.SuspiciousRates.Cols.EURRUBExpected.Name, ID.Table.SuspiciousRates.Cols.EURRUBExpected.ID, err))
	}
	if dto.EURRUBActual, err = ToFloat64(ID.Table.SuspiciousRates.Cols.EURRUBActual.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.SuspiciousRates.Cols.EURRUBActual.Name, ID.Table.SuspiciousRates.Cols.EURRUBActual.ID, err))
	}

	if len(errc) > 0 {
		return SuspiciousRates{}, errc
	}

	return
}

// WorkDays is DTO for Work days table
type WorkDays struct {
	Month    MonthsLookup
	WorkDays float64
	Location LocationLookup
}

func NewWorkDays(row Valuer) (dto WorkDays, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Month, err = ToMonthsLookup(ID.Table.WorkDays.Cols.Month.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.WorkDays.Cols.Month.Name, ID.Table.WorkDays.Cols.Month.ID, err))
	}
	if dto.WorkDays, err = ToFloat64(ID.Table.WorkDays.Cols.WorkDays.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.WorkDays.Cols.WorkDays.Name, ID.Table.WorkDays.Cols.WorkDays.ID, err))
	}
	if dto.Location, err = ToLocationLookup(ID.Table.WorkDays.Cols.Location.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.WorkDays.Cols.Location.Name, ID.Table.WorkDays.Cols.Location.ID, err))
	}

	if len(errc) > 0 {
		return WorkDays{}, errc
	}

	return
}

// CorrectionsByEmployee is DTO for Corrections by employee table
type CorrectionsByEmployee struct {
	Type      EntryTypeLookup
	Comment   string
	RUBAmount float64
	EURAmount float64
}

func NewCorrectionsByEmployee(row Valuer) (dto CorrectionsByEmployee, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Type, err = ToEntryTypeLookup(ID.Table.CorrectionsByEmployee.Cols.Type.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CorrectionsByEmployee.Cols.Type.Name, ID.Table.CorrectionsByEmployee.Cols.Type.ID, err))
	}
	if dto.Comment, err = ToString(ID.Table.CorrectionsByEmployee.Cols.Comment.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CorrectionsByEmployee.Cols.Comment.Name, ID.Table.CorrectionsByEmployee.Cols.Comment.ID, err))
	}
	if dto.RUBAmount, err = ToFloat64(ID.Table.CorrectionsByEmployee.Cols.RUBAmount.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CorrectionsByEmployee.Cols.RUBAmount.Name, ID.Table.CorrectionsByEmployee.Cols.RUBAmount.ID, err))
	}
	if dto.EURAmount, err = ToFloat64(ID.Table.CorrectionsByEmployee.Cols.EURAmount.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CorrectionsByEmployee.Cols.EURAmount.Name, ID.Table.CorrectionsByEmployee.Cols.EURAmount.ID, err))
	}

	if len(errc) > 0 {
		return CorrectionsByEmployee{}, errc
	}

	return
}

// EnterCompanyRatesForSelectedMonth is DTO for Enter company rates for selected month table
type EnterCompanyRatesForSelectedMonth struct {
	Month  MonthsLookup
	EURRUB float64
}

func NewEnterCompanyRatesForSelectedMonth(row Valuer) (dto EnterCompanyRatesForSelectedMonth, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Month, err = ToMonthsLookup(ID.Table.EnterCompanyRatesForSelectedMonth.Cols.Month.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EnterCompanyRatesForSelectedMonth.Cols.Month.Name, ID.Table.EnterCompanyRatesForSelectedMonth.Cols.Month.ID, err))
	}
	if dto.EURRUB, err = ToFloat64(ID.Table.EnterCompanyRatesForSelectedMonth.Cols.EURRUB.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EnterCompanyRatesForSelectedMonth.Cols.EURRUB.Name, ID.Table.EnterCompanyRatesForSelectedMonth.Cols.EURRUB.ID, err))
	}

	if len(errc) > 0 {
		return EnterCompanyRatesForSelectedMonth{}, errc
	}

	return
}

// TemplateEntries is DTO for Template Entries table
type TemplateEntries struct {
	Employee             AllEmployeesLookup
	MonthFrom            MonthsLookup
	MonthTo              MonthsLookup
	Type                 EntryTypeLookup
	Comment              string
	RUBAmount            float64
	EURAmount            float64
	ModifiedBy           []Person
	CreatedOn            time.Time
	ModifiedOn           time.Time
	Display              string
	IncludedToNewInvoice bool
}

func NewTemplateEntries(row Valuer) (dto TemplateEntries, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Employee, err = ToAllEmployeesLookup(ID.Table.TemplateEntries.Cols.Employee.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TemplateEntries.Cols.Employee.Name, ID.Table.TemplateEntries.Cols.Employee.ID, err))
	}
	if dto.MonthFrom, err = ToMonthsLookup(ID.Table.TemplateEntries.Cols.MonthFrom.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TemplateEntries.Cols.MonthFrom.Name, ID.Table.TemplateEntries.Cols.MonthFrom.ID, err))
	}
	if dto.MonthTo, err = ToMonthsLookup(ID.Table.TemplateEntries.Cols.MonthTo.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TemplateEntries.Cols.MonthTo.Name, ID.Table.TemplateEntries.Cols.MonthTo.ID, err))
	}
	if dto.Type, err = ToEntryTypeLookup(ID.Table.TemplateEntries.Cols.Type.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TemplateEntries.Cols.Type.Name, ID.Table.TemplateEntries.Cols.Type.ID, err))
	}
	if dto.Comment, err = ToString(ID.Table.TemplateEntries.Cols.Comment.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TemplateEntries.Cols.Comment.Name, ID.Table.TemplateEntries.Cols.Comment.ID, err))
	}
	if dto.RUBAmount, err = ToFloat64(ID.Table.TemplateEntries.Cols.RUBAmount.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TemplateEntries.Cols.RUBAmount.Name, ID.Table.TemplateEntries.Cols.RUBAmount.ID, err))
	}
	if dto.EURAmount, err = ToFloat64(ID.Table.TemplateEntries.Cols.EURAmount.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TemplateEntries.Cols.EURAmount.Name, ID.Table.TemplateEntries.Cols.EURAmount.ID, err))
	}
	if dto.ModifiedBy, err = ToPersons(ID.Table.TemplateEntries.Cols.ModifiedBy.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TemplateEntries.Cols.ModifiedBy.Name, ID.Table.TemplateEntries.Cols.ModifiedBy.ID, err))
	}
	if dto.CreatedOn, err = ToDateTime(ID.Table.TemplateEntries.Cols.CreatedOn.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TemplateEntries.Cols.CreatedOn.Name, ID.Table.TemplateEntries.Cols.CreatedOn.ID, err))
	}
	if dto.ModifiedOn, err = ToDateTime(ID.Table.TemplateEntries.Cols.ModifiedOn.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TemplateEntries.Cols.ModifiedOn.Name, ID.Table.TemplateEntries.Cols.ModifiedOn.ID, err))
	}
	if dto.Display, err = ToString(ID.Table.TemplateEntries.Cols.Display.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TemplateEntries.Cols.Display.Name, ID.Table.TemplateEntries.Cols.Display.ID, err))
	}
	if dto.IncludedToNewInvoice, err = ToBool(ID.Table.TemplateEntries.Cols.IncludedToNewInvoice.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TemplateEntries.Cols.IncludedToNewInvoice.Name, ID.Table.TemplateEntries.Cols.IncludedToNewInvoice.ID, err))
	}

	if len(errc) > 0 {
		return TemplateEntries{}, errc
	}

	return
}

// AllEmployeesNames is DTO for All employees names table
type AllEmployeesNames struct {
	Name      string
	StartDate time.Time
	Location  LocationLookup
}

func NewAllEmployeesNames(row Valuer) (dto AllEmployeesNames, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Name, err = ToString(ID.Table.AllEmployeesNames.Cols.Name.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AllEmployeesNames.Cols.Name.Name, ID.Table.AllEmployeesNames.Cols.Name.ID, err))
	}
	if dto.StartDate, err = ToDate(ID.Table.AllEmployeesNames.Cols.StartDate.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AllEmployeesNames.Cols.StartDate.Name, ID.Table.AllEmployeesNames.Cols.StartDate.ID, err))
	}
	if dto.Location, err = ToLocationLookup(ID.Table.AllEmployeesNames.Cols.Location.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AllEmployeesNames.Cols.Location.Name, ID.Table.AllEmployeesNames.Cols.Location.ID, err))
	}

	if len(errc) > 0 {
		return AllEmployeesNames{}, errc
	}

	return
}

// BankDetails is DTO for Bank details table
type BankDetails struct {
	Employee        AllEmployeesLookup
	Account         string
	Address1        string
	Address2        string
	BeneficiaryBank BeneficiaryBankLookup
	MonthFrom       MonthsLookup
	MonthTo         MonthsLookup
	ID              string
	Text            string
	BankRequisites  string
}

func NewBankDetails(row Valuer) (dto BankDetails, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Employee, err = ToAllEmployeesLookup(ID.Table.BankDetails.Cols.Employee.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.BankDetails.Cols.Employee.Name, ID.Table.BankDetails.Cols.Employee.ID, err))
	}
	if dto.Account, err = ToString(ID.Table.BankDetails.Cols.Account.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.BankDetails.Cols.Account.Name, ID.Table.BankDetails.Cols.Account.ID, err))
	}
	if dto.Address1, err = ToString(ID.Table.BankDetails.Cols.Address1.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.BankDetails.Cols.Address1.Name, ID.Table.BankDetails.Cols.Address1.ID, err))
	}
	if dto.Address2, err = ToString(ID.Table.BankDetails.Cols.Address2.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.BankDetails.Cols.Address2.Name, ID.Table.BankDetails.Cols.Address2.ID, err))
	}
	if dto.BeneficiaryBank, err = ToBeneficiaryBankLookup(ID.Table.BankDetails.Cols.BeneficiaryBank.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.BankDetails.Cols.BeneficiaryBank.Name, ID.Table.BankDetails.Cols.BeneficiaryBank.ID, err))
	}
	if dto.MonthFrom, err = ToMonthsLookup(ID.Table.BankDetails.Cols.MonthFrom.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.BankDetails.Cols.MonthFrom.Name, ID.Table.BankDetails.Cols.MonthFrom.ID, err))
	}
	if dto.MonthTo, err = ToMonthsLookup(ID.Table.BankDetails.Cols.MonthTo.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.BankDetails.Cols.MonthTo.Name, ID.Table.BankDetails.Cols.MonthTo.ID, err))
	}
	if dto.ID, err = ToString(ID.Table.BankDetails.Cols.ID.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.BankDetails.Cols.ID.Name, ID.Table.BankDetails.Cols.ID.ID, err))
	}
	if dto.Text, err = ToString(ID.Table.BankDetails.Cols.Text.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.BankDetails.Cols.Text.Name, ID.Table.BankDetails.Cols.Text.ID, err))
	}
	if dto.BankRequisites, err = ToString(ID.Table.BankDetails.Cols.BankRequisites.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.BankDetails.Cols.BankRequisites.Name, ID.Table.BankDetails.Cols.BankRequisites.ID, err))
	}

	if len(errc) > 0 {
		return BankDetails{}, errc
	}

	return
}

// BeneficiaryBank is DTO for Beneficiary Bank table
type BeneficiaryBank struct {
	Name              string
	Address1          string
	Address2          string
	Address3          string
	BeneficiarySWIFT  string
	IntermediarySWIFT string
}

func NewBeneficiaryBank(row Valuer) (dto BeneficiaryBank, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Name, err = ToString(ID.Table.BeneficiaryBank.Cols.Name.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.BeneficiaryBank.Cols.Name.Name, ID.Table.BeneficiaryBank.Cols.Name.ID, err))
	}
	if dto.Address1, err = ToString(ID.Table.BeneficiaryBank.Cols.Address1.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.BeneficiaryBank.Cols.Address1.Name, ID.Table.BeneficiaryBank.Cols.Address1.ID, err))
	}
	if dto.Address2, err = ToString(ID.Table.BeneficiaryBank.Cols.Address2.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.BeneficiaryBank.Cols.Address2.Name, ID.Table.BeneficiaryBank.Cols.Address2.ID, err))
	}
	if dto.Address3, err = ToString(ID.Table.BeneficiaryBank.Cols.Address3.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.BeneficiaryBank.Cols.Address3.Name, ID.Table.BeneficiaryBank.Cols.Address3.ID, err))
	}
	if dto.BeneficiarySWIFT, err = ToString(ID.Table.BeneficiaryBank.Cols.BeneficiarySWIFT.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.BeneficiaryBank.Cols.BeneficiarySWIFT.Name, ID.Table.BeneficiaryBank.Cols.BeneficiarySWIFT.ID, err))
	}
	if dto.IntermediarySWIFT, err = ToString(ID.Table.BeneficiaryBank.Cols.IntermediarySWIFT.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.BeneficiaryBank.Cols.IntermediarySWIFT.Name, ID.Table.BeneficiaryBank.Cols.IntermediarySWIFT.ID, err))
	}

	if len(errc) > 0 {
		return BeneficiaryBank{}, errc
	}

	return
}

// PayrollSchedule is DTO for Payroll Schedule table
type PayrollSchedule struct {
	Month         MonthsLookup
	ExecutionDate time.Time
}

func NewPayrollSchedule(row Valuer) (dto PayrollSchedule, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Month, err = ToMonthsLookup(ID.Table.PayrollSchedule.Cols.Month.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PayrollSchedule.Cols.Month.Name, ID.Table.PayrollSchedule.Cols.Month.ID, err))
	}
	if dto.ExecutionDate, err = ToDate(ID.Table.PayrollSchedule.Cols.ExecutionDate.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PayrollSchedule.Cols.ExecutionDate.Name, ID.Table.PayrollSchedule.Cols.ExecutionDate.ID, err))
	}

	if len(errc) > 0 {
		return PayrollSchedule{}, errc
	}

	return
}

// PensionFundFixed is DTO for Pension Fund fixed table
type PensionFundFixed struct {
	Invoice               InvoiceLookup
	OpeningDateIP         time.Time
	PeriodStart           time.Time
	PeriodEnd             time.Time
	AmountIPDays          float64
	PensionFundFixedToPay float64
	PensionFundFixedTotal float64
	Year                  TaxYearsLookup
	Apply                 string
}

func NewPensionFundFixed(row Valuer) (dto PensionFundFixed, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Invoice, err = ToInvoiceLookup(ID.Table.PensionFundFixed.Cols.Invoice.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PensionFundFixed.Cols.Invoice.Name, ID.Table.PensionFundFixed.Cols.Invoice.ID, err))
	}
	if dto.OpeningDateIP, err = ToDate(ID.Table.PensionFundFixed.Cols.OpeningDateIP.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PensionFundFixed.Cols.OpeningDateIP.Name, ID.Table.PensionFundFixed.Cols.OpeningDateIP.ID, err))
	}
	if dto.PeriodStart, err = ToDate(ID.Table.PensionFundFixed.Cols.PeriodStart.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PensionFundFixed.Cols.PeriodStart.Name, ID.Table.PensionFundFixed.Cols.PeriodStart.ID, err))
	}
	if dto.PeriodEnd, err = ToDate(ID.Table.PensionFundFixed.Cols.PeriodEnd.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PensionFundFixed.Cols.PeriodEnd.Name, ID.Table.PensionFundFixed.Cols.PeriodEnd.ID, err))
	}
	if dto.AmountIPDays, err = ToFloat64(ID.Table.PensionFundFixed.Cols.AmountIPDays.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PensionFundFixed.Cols.AmountIPDays.Name, ID.Table.PensionFundFixed.Cols.AmountIPDays.ID, err))
	}
	if dto.PensionFundFixedToPay, err = ToFloat64(ID.Table.PensionFundFixed.Cols.PensionFundFixedToPay.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PensionFundFixed.Cols.PensionFundFixedToPay.Name, ID.Table.PensionFundFixed.Cols.PensionFundFixedToPay.ID, err))
	}
	if dto.PensionFundFixedTotal, err = ToFloat64(ID.Table.PensionFundFixed.Cols.PensionFundFixedTotal.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PensionFundFixed.Cols.PensionFundFixedTotal.Name, ID.Table.PensionFundFixed.Cols.PensionFundFixedTotal.ID, err))
	}
	if dto.Year, err = ToTaxYearsLookup(ID.Table.PensionFundFixed.Cols.Year.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PensionFundFixed.Cols.Year.Name, ID.Table.PensionFundFixed.Cols.Year.ID, err))
	}
	if dto.Apply, err = ToString(ID.Table.PensionFundFixed.Cols.Apply.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PensionFundFixed.Cols.Apply.Name, ID.Table.PensionFundFixed.Cols.Apply.ID, err))
	}

	if len(errc) > 0 {
		return PensionFundFixed{}, errc
	}

	return
}

// SocialInsurance is DTO for Social Insurance table
type SocialInsurance struct {
	Invoice              InvoiceLookup
	OpeningDateIP        time.Time
	PeriodStart          time.Time
	PeriodEnd            time.Time
	AmountIPDays         float64
	SocialInsuranceToPay float64
	SocialInsuranceTotal float64
	Year                 TaxYearsLookup
	Apply                string
}

func NewSocialInsurance(row Valuer) (dto SocialInsurance, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Invoice, err = ToInvoiceLookup(ID.Table.SocialInsurance.Cols.Invoice.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.SocialInsurance.Cols.Invoice.Name, ID.Table.SocialInsurance.Cols.Invoice.ID, err))
	}
	if dto.OpeningDateIP, err = ToDate(ID.Table.SocialInsurance.Cols.OpeningDateIP.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.SocialInsurance.Cols.OpeningDateIP.Name, ID.Table.SocialInsurance.Cols.OpeningDateIP.ID, err))
	}
	if dto.PeriodStart, err = ToDate(ID.Table.SocialInsurance.Cols.PeriodStart.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.SocialInsurance.Cols.PeriodStart.Name, ID.Table.SocialInsurance.Cols.PeriodStart.ID, err))
	}
	if dto.PeriodEnd, err = ToDate(ID.Table.SocialInsurance.Cols.PeriodEnd.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.SocialInsurance.Cols.PeriodEnd.Name, ID.Table.SocialInsurance.Cols.PeriodEnd.ID, err))
	}
	if dto.AmountIPDays, err = ToFloat64(ID.Table.SocialInsurance.Cols.AmountIPDays.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.SocialInsurance.Cols.AmountIPDays.Name, ID.Table.SocialInsurance.Cols.AmountIPDays.ID, err))
	}
	if dto.SocialInsuranceToPay, err = ToFloat64(ID.Table.SocialInsurance.Cols.SocialInsuranceToPay.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.SocialInsurance.Cols.SocialInsuranceToPay.Name, ID.Table.SocialInsurance.Cols.SocialInsuranceToPay.ID, err))
	}
	if dto.SocialInsuranceTotal, err = ToFloat64(ID.Table.SocialInsurance.Cols.SocialInsuranceTotal.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.SocialInsurance.Cols.SocialInsuranceTotal.Name, ID.Table.SocialInsurance.Cols.SocialInsuranceTotal.ID, err))
	}
	if dto.Year, err = ToTaxYearsLookup(ID.Table.SocialInsurance.Cols.Year.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.SocialInsurance.Cols.Year.Name, ID.Table.SocialInsurance.Cols.Year.ID, err))
	}
	if dto.Apply, err = ToString(ID.Table.SocialInsurance.Cols.Apply.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.SocialInsurance.Cols.Apply.Name, ID.Table.SocialInsurance.Cols.Apply.ID, err))
	}

	if len(errc) > 0 {
		return SocialInsurance{}, errc
	}

	return
}

// PensionFundPercent is DTO for Pension fund percent table
type PensionFundPercent struct {
	Invoice            InvoiceLookup
	PensionFundPercent float64
	Year               TaxYearsLookup
	Apply              string
}

func NewPensionFundPercent(row Valuer) (dto PensionFundPercent, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Invoice, err = ToInvoiceLookup(ID.Table.PensionFundPercent.Cols.Invoice.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PensionFundPercent.Cols.Invoice.Name, ID.Table.PensionFundPercent.Cols.Invoice.ID, err))
	}
	if dto.PensionFundPercent, err = ToFloat64(ID.Table.PensionFundPercent.Cols.PensionFundPercent.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PensionFundPercent.Cols.PensionFundPercent.Name, ID.Table.PensionFundPercent.Cols.PensionFundPercent.ID, err))
	}
	if dto.Year, err = ToTaxYearsLookup(ID.Table.PensionFundPercent.Cols.Year.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PensionFundPercent.Cols.Year.Name, ID.Table.PensionFundPercent.Cols.Year.ID, err))
	}
	if dto.Apply, err = ToString(ID.Table.PensionFundPercent.Cols.Apply.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PensionFundPercent.Cols.Apply.Name, ID.Table.PensionFundPercent.Cols.Apply.ID, err))
	}

	if len(errc) > 0 {
		return PensionFundPercent{}, errc
	}

	return
}

// PerDayCalculations is DTO for Per Day Calculations table
type PerDayCalculations struct {
	Type               PerDayPoliciesLookup
	NumberOfDays       float64
	CostOfDay          float64
	Total              float64
	PaymentInvoice     InvoiceLookup
	SalaryPeriod       MonthsLookup
	CalculationInvoice InvoiceLookup
	Salary             EntriesLookup
	Apply              string
	WorkPeriod         MonthsLookup
}

func NewPerDayCalculations(row Valuer) (dto PerDayCalculations, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Type, err = ToPerDayPoliciesLookup(ID.Table.PerDayCalculations.Cols.Type.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PerDayCalculations.Cols.Type.Name, ID.Table.PerDayCalculations.Cols.Type.ID, err))
	}
	if dto.NumberOfDays, err = ToFloat64(ID.Table.PerDayCalculations.Cols.NumberOfDays.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PerDayCalculations.Cols.NumberOfDays.Name, ID.Table.PerDayCalculations.Cols.NumberOfDays.ID, err))
	}
	if dto.CostOfDay, err = ToFloat64(ID.Table.PerDayCalculations.Cols.CostOfDay.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PerDayCalculations.Cols.CostOfDay.Name, ID.Table.PerDayCalculations.Cols.CostOfDay.ID, err))
	}
	if dto.Total, err = ToFloat64(ID.Table.PerDayCalculations.Cols.Total.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PerDayCalculations.Cols.Total.Name, ID.Table.PerDayCalculations.Cols.Total.ID, err))
	}
	if dto.PaymentInvoice, err = ToInvoiceLookup(ID.Table.PerDayCalculations.Cols.PaymentInvoice.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PerDayCalculations.Cols.PaymentInvoice.Name, ID.Table.PerDayCalculations.Cols.PaymentInvoice.ID, err))
	}
	if dto.SalaryPeriod, err = ToMonthsLookup(ID.Table.PerDayCalculations.Cols.SalaryPeriod.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PerDayCalculations.Cols.SalaryPeriod.Name, ID.Table.PerDayCalculations.Cols.SalaryPeriod.ID, err))
	}
	if dto.CalculationInvoice, err = ToInvoiceLookup(ID.Table.PerDayCalculations.Cols.CalculationInvoice.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PerDayCalculations.Cols.CalculationInvoice.Name, ID.Table.PerDayCalculations.Cols.CalculationInvoice.ID, err))
	}
	if dto.Salary, err = ToEntriesLookup(ID.Table.PerDayCalculations.Cols.Salary.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PerDayCalculations.Cols.Salary.Name, ID.Table.PerDayCalculations.Cols.Salary.ID, err))
	}
	if dto.Apply, err = ToString(ID.Table.PerDayCalculations.Cols.Apply.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PerDayCalculations.Cols.Apply.Name, ID.Table.PerDayCalculations.Cols.Apply.ID, err))
	}
	if dto.WorkPeriod, err = ToMonthsLookup(ID.Table.PerDayCalculations.Cols.WorkPeriod.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PerDayCalculations.Cols.WorkPeriod.Name, ID.Table.PerDayCalculations.Cols.WorkPeriod.ID, err))
	}

	if len(errc) > 0 {
		return PerDayCalculations{}, errc
	}

	return
}

// PerDayPolicies is DTO for Per Day Policies table
type PerDayPolicies struct {
	Name        string
	Coefficient float64
	EntryType   EntryTypeLookup
}

func NewPerDayPolicies(row Valuer) (dto PerDayPolicies, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Name, err = ToString(ID.Table.PerDayPolicies.Cols.Name.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PerDayPolicies.Cols.Name.Name, ID.Table.PerDayPolicies.Cols.Name.ID, err))
	}
	if dto.Coefficient, err = ToFloat64(ID.Table.PerDayPolicies.Cols.Coefficient.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PerDayPolicies.Cols.Coefficient.Name, ID.Table.PerDayPolicies.Cols.Coefficient.ID, err))
	}
	if dto.EntryType, err = ToEntryTypeLookup(ID.Table.PerDayPolicies.Cols.EntryType.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PerDayPolicies.Cols.EntryType.Name, ID.Table.PerDayPolicies.Cols.EntryType.ID, err))
	}

	if len(errc) > 0 {
		return PerDayPolicies{}, errc
	}

	return
}

// Salaries is DTO for Salaries table
type Salaries struct {
	Employee  AllEmployeesLookup
	MonthFrom MonthsLookup
	MonthTo   MonthsLookup
	Comment   string
	RUBAmount float64
	EURAmount float64
}

func NewSalaries(row Valuer) (dto Salaries, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Employee, err = ToAllEmployeesLookup(ID.Table.Salaries.Cols.Employee.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Salaries.Cols.Employee.Name, ID.Table.Salaries.Cols.Employee.ID, err))
	}
	if dto.MonthFrom, err = ToMonthsLookup(ID.Table.Salaries.Cols.MonthFrom.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Salaries.Cols.MonthFrom.Name, ID.Table.Salaries.Cols.MonthFrom.ID, err))
	}
	if dto.MonthTo, err = ToMonthsLookup(ID.Table.Salaries.Cols.MonthTo.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Salaries.Cols.MonthTo.Name, ID.Table.Salaries.Cols.MonthTo.ID, err))
	}
	if dto.Comment, err = ToString(ID.Table.Salaries.Cols.Comment.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Salaries.Cols.Comment.Name, ID.Table.Salaries.Cols.Comment.ID, err))
	}
	if dto.RUBAmount, err = ToFloat64(ID.Table.Salaries.Cols.RUBAmount.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Salaries.Cols.RUBAmount.Name, ID.Table.Salaries.Cols.RUBAmount.ID, err))
	}
	if dto.EURAmount, err = ToFloat64(ID.Table.Salaries.Cols.EURAmount.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.Salaries.Cols.EURAmount.Name, ID.Table.Salaries.Cols.EURAmount.ID, err))
	}

	if len(errc) > 0 {
		return Salaries{}, errc
	}

	return
}

// PayableEmployees is DTO for Payable employees table
type PayableEmployees struct {
	Employee           AllEmployeesLookup
	BonusQuarter       string
	TargetInvoice      InvoiceLookup
	AddAny             string
	FlexBenefit        string
	SelfEmplTax        string
	IE6PercentTax      string
	ManualEntries      EntriesLookup
	ExcludedEntryTypes string
	PayableNow         bool
	ExcludeFromPayment bool
}

func NewPayableEmployees(row Valuer) (dto PayableEmployees, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Employee, err = ToAllEmployeesLookup(ID.Table.PayableEmployees.Cols.Employee.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PayableEmployees.Cols.Employee.Name, ID.Table.PayableEmployees.Cols.Employee.ID, err))
	}
	if dto.BonusQuarter, err = ToString(ID.Table.PayableEmployees.Cols.BonusQuarter.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PayableEmployees.Cols.BonusQuarter.Name, ID.Table.PayableEmployees.Cols.BonusQuarter.ID, err))
	}
	if dto.TargetInvoice, err = ToInvoiceLookup(ID.Table.PayableEmployees.Cols.TargetInvoice.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PayableEmployees.Cols.TargetInvoice.Name, ID.Table.PayableEmployees.Cols.TargetInvoice.ID, err))
	}
	if dto.AddAny, err = ToString(ID.Table.PayableEmployees.Cols.AddAny.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PayableEmployees.Cols.AddAny.Name, ID.Table.PayableEmployees.Cols.AddAny.ID, err))
	}
	if dto.FlexBenefit, err = ToString(ID.Table.PayableEmployees.Cols.FlexBenefit.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PayableEmployees.Cols.FlexBenefit.Name, ID.Table.PayableEmployees.Cols.FlexBenefit.ID, err))
	}
	if dto.SelfEmplTax, err = ToString(ID.Table.PayableEmployees.Cols.SelfEmplTax.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PayableEmployees.Cols.SelfEmplTax.Name, ID.Table.PayableEmployees.Cols.SelfEmplTax.ID, err))
	}
	if dto.IE6PercentTax, err = ToString(ID.Table.PayableEmployees.Cols.IE6PercentTax.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PayableEmployees.Cols.IE6PercentTax.Name, ID.Table.PayableEmployees.Cols.IE6PercentTax.ID, err))
	}
	if dto.ManualEntries, err = ToEntriesLookup(ID.Table.PayableEmployees.Cols.ManualEntries.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PayableEmployees.Cols.ManualEntries.Name, ID.Table.PayableEmployees.Cols.ManualEntries.ID, err))
	}
	if dto.ExcludedEntryTypes, err = ToString(ID.Table.PayableEmployees.Cols.ExcludedEntryTypes.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PayableEmployees.Cols.ExcludedEntryTypes.Name, ID.Table.PayableEmployees.Cols.ExcludedEntryTypes.ID, err))
	}
	if dto.PayableNow, err = ToBool(ID.Table.PayableEmployees.Cols.PayableNow.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PayableEmployees.Cols.PayableNow.Name, ID.Table.PayableEmployees.Cols.PayableNow.ID, err))
	}
	if dto.ExcludeFromPayment, err = ToBool(ID.Table.PayableEmployees.Cols.ExcludeFromPayment.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.PayableEmployees.Cols.ExcludeFromPayment.Name, ID.Table.PayableEmployees.Cols.ExcludeFromPayment.ID, err))
	}

	if len(errc) > 0 {
		return PayableEmployees{}, errc
	}

	return
}

// QuickManualEntry is DTO for Quick Manual Entry table
type QuickManualEntry struct {
	TargetInvoice InvoiceLookup
	ManualEntries EntriesLookup
	AddAny        string
	BonusQuarter  string
	FlexBenefit   string
	SelfEmplTax   string
	IE6PercentTax string
}

func NewQuickManualEntry(row Valuer) (dto QuickManualEntry, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.TargetInvoice, err = ToInvoiceLookup(ID.Table.QuickManualEntry.Cols.TargetInvoice.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.QuickManualEntry.Cols.TargetInvoice.Name, ID.Table.QuickManualEntry.Cols.TargetInvoice.ID, err))
	}
	if dto.ManualEntries, err = ToEntriesLookup(ID.Table.QuickManualEntry.Cols.ManualEntries.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.QuickManualEntry.Cols.ManualEntries.Name, ID.Table.QuickManualEntry.Cols.ManualEntries.ID, err))
	}
	if dto.AddAny, err = ToString(ID.Table.QuickManualEntry.Cols.AddAny.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.QuickManualEntry.Cols.AddAny.Name, ID.Table.QuickManualEntry.Cols.AddAny.ID, err))
	}
	if dto.BonusQuarter, err = ToString(ID.Table.QuickManualEntry.Cols.BonusQuarter.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.QuickManualEntry.Cols.BonusQuarter.Name, ID.Table.QuickManualEntry.Cols.BonusQuarter.ID, err))
	}
	if dto.FlexBenefit, err = ToString(ID.Table.QuickManualEntry.Cols.FlexBenefit.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.QuickManualEntry.Cols.FlexBenefit.Name, ID.Table.QuickManualEntry.Cols.FlexBenefit.ID, err))
	}
	if dto.SelfEmplTax, err = ToString(ID.Table.QuickManualEntry.Cols.SelfEmplTax.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.QuickManualEntry.Cols.SelfEmplTax.Name, ID.Table.QuickManualEntry.Cols.SelfEmplTax.ID, err))
	}
	if dto.IE6PercentTax, err = ToString(ID.Table.QuickManualEntry.Cols.IE6PercentTax.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.QuickManualEntry.Cols.IE6PercentTax.Name, ID.Table.QuickManualEntry.Cols.IE6PercentTax.ID, err))
	}

	if len(errc) > 0 {
		return QuickManualEntry{}, errc
	}

	return
}

// NewInvoiceEntriesPerType is DTO for New invoice entries per type table
type NewInvoiceEntriesPerType struct {
	Invoice   InvoiceLookup
	Type      EntryTypeLookup
	RUBAmount float64
	EURAmount float64
	Comment   string
}

func NewNewInvoiceEntriesPerType(row Valuer) (dto NewInvoiceEntriesPerType, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Invoice, err = ToInvoiceLookup(ID.Table.NewInvoiceEntriesPerType.Cols.Invoice.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.NewInvoiceEntriesPerType.Cols.Invoice.Name, ID.Table.NewInvoiceEntriesPerType.Cols.Invoice.ID, err))
	}
	if dto.Type, err = ToEntryTypeLookup(ID.Table.NewInvoiceEntriesPerType.Cols.Type.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.NewInvoiceEntriesPerType.Cols.Type.Name, ID.Table.NewInvoiceEntriesPerType.Cols.Type.ID, err))
	}
	if dto.RUBAmount, err = ToFloat64(ID.Table.NewInvoiceEntriesPerType.Cols.RUBAmount.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.NewInvoiceEntriesPerType.Cols.RUBAmount.Name, ID.Table.NewInvoiceEntriesPerType.Cols.RUBAmount.ID, err))
	}
	if dto.EURAmount, err = ToFloat64(ID.Table.NewInvoiceEntriesPerType.Cols.EURAmount.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.NewInvoiceEntriesPerType.Cols.EURAmount.Name, ID.Table.NewInvoiceEntriesPerType.Cols.EURAmount.ID, err))
	}
	if dto.Comment, err = ToString(ID.Table.NewInvoiceEntriesPerType.Cols.Comment.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.NewInvoiceEntriesPerType.Cols.Comment.Name, ID.Table.NewInvoiceEntriesPerType.Cols.Comment.ID, err))
	}

	if len(errc) > 0 {
		return NewInvoiceEntriesPerType{}, errc
	}

	return
}

// EntriesPerDateAndType is DTO for Entries per date and type table
type EntriesPerDateAndType struct {
	Invoice   InvoiceLookup
	Type      EntryTypeLookup
	RUBAmount float64
	EURAmount float64
	Comment   string
	Month     MonthsLookup
}

func NewEntriesPerDateAndType(row Valuer) (dto EntriesPerDateAndType, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Invoice, err = ToInvoiceLookup(ID.Table.EntriesPerDateAndType.Cols.Invoice.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EntriesPerDateAndType.Cols.Invoice.Name, ID.Table.EntriesPerDateAndType.Cols.Invoice.ID, err))
	}
	if dto.Type, err = ToEntryTypeLookup(ID.Table.EntriesPerDateAndType.Cols.Type.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EntriesPerDateAndType.Cols.Type.Name, ID.Table.EntriesPerDateAndType.Cols.Type.ID, err))
	}
	if dto.RUBAmount, err = ToFloat64(ID.Table.EntriesPerDateAndType.Cols.RUBAmount.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EntriesPerDateAndType.Cols.RUBAmount.Name, ID.Table.EntriesPerDateAndType.Cols.RUBAmount.ID, err))
	}
	if dto.EURAmount, err = ToFloat64(ID.Table.EntriesPerDateAndType.Cols.EURAmount.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EntriesPerDateAndType.Cols.EURAmount.Name, ID.Table.EntriesPerDateAndType.Cols.EURAmount.ID, err))
	}
	if dto.Comment, err = ToString(ID.Table.EntriesPerDateAndType.Cols.Comment.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EntriesPerDateAndType.Cols.Comment.Name, ID.Table.EntriesPerDateAndType.Cols.Comment.ID, err))
	}
	if dto.Month, err = ToMonthsLookup(ID.Table.EntriesPerDateAndType.Cols.Month.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EntriesPerDateAndType.Cols.Month.Name, ID.Table.EntriesPerDateAndType.Cols.Month.ID, err))
	}

	if len(errc) > 0 {
		return EntriesPerDateAndType{}, errc
	}

	return
}

// AddNewEmployee is DTO for Add new employee table
type AddNewEmployee struct {
	Name                 string
	LegalForm            string
	StartDate            time.Time
	EndDate              time.Time
	ContractDate         string
	ContractNumber       string
	Location             LocationLookup
	LegalEntity          LegalEntityLookup
	OpeningDateIP        time.Time
	BankDetails          BankDetailsLookup
	GeneralSD            string
	FinanceSD            string
	BankTariff           BankTariffsLookup
	ContractHourRate     float64
	Rounding             float64
	EnglishFullName      string
	SpecialPaymentPolicy bool
	WorkingNow           bool
	Valid                bool
	InvalidFields        string
}

func NewAddNewEmployee(row Valuer) (dto AddNewEmployee, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Name, err = ToString(ID.Table.AddNewEmployee.Cols.Name.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AddNewEmployee.Cols.Name.Name, ID.Table.AddNewEmployee.Cols.Name.ID, err))
	}
	if dto.LegalForm, err = ToString(ID.Table.AddNewEmployee.Cols.LegalForm.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AddNewEmployee.Cols.LegalForm.Name, ID.Table.AddNewEmployee.Cols.LegalForm.ID, err))
	}
	if dto.StartDate, err = ToDate(ID.Table.AddNewEmployee.Cols.StartDate.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AddNewEmployee.Cols.StartDate.Name, ID.Table.AddNewEmployee.Cols.StartDate.ID, err))
	}
	if dto.EndDate, err = ToDate(ID.Table.AddNewEmployee.Cols.EndDate.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AddNewEmployee.Cols.EndDate.Name, ID.Table.AddNewEmployee.Cols.EndDate.ID, err))
	}
	if dto.ContractDate, err = ToString(ID.Table.AddNewEmployee.Cols.ContractDate.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AddNewEmployee.Cols.ContractDate.Name, ID.Table.AddNewEmployee.Cols.ContractDate.ID, err))
	}
	if dto.ContractNumber, err = ToString(ID.Table.AddNewEmployee.Cols.ContractNumber.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AddNewEmployee.Cols.ContractNumber.Name, ID.Table.AddNewEmployee.Cols.ContractNumber.ID, err))
	}
	if dto.Location, err = ToLocationLookup(ID.Table.AddNewEmployee.Cols.Location.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AddNewEmployee.Cols.Location.Name, ID.Table.AddNewEmployee.Cols.Location.ID, err))
	}
	if dto.LegalEntity, err = ToLegalEntityLookup(ID.Table.AddNewEmployee.Cols.LegalEntity.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AddNewEmployee.Cols.LegalEntity.Name, ID.Table.AddNewEmployee.Cols.LegalEntity.ID, err))
	}
	if dto.OpeningDateIP, err = ToDate(ID.Table.AddNewEmployee.Cols.OpeningDateIP.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AddNewEmployee.Cols.OpeningDateIP.Name, ID.Table.AddNewEmployee.Cols.OpeningDateIP.ID, err))
	}
	if dto.BankDetails, err = ToBankDetailsLookup(ID.Table.AddNewEmployee.Cols.BankDetails.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AddNewEmployee.Cols.BankDetails.Name, ID.Table.AddNewEmployee.Cols.BankDetails.ID, err))
	}
	if dto.GeneralSD, err = ToString(ID.Table.AddNewEmployee.Cols.GeneralSD.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AddNewEmployee.Cols.GeneralSD.Name, ID.Table.AddNewEmployee.Cols.GeneralSD.ID, err))
	}
	if dto.FinanceSD, err = ToString(ID.Table.AddNewEmployee.Cols.FinanceSD.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AddNewEmployee.Cols.FinanceSD.Name, ID.Table.AddNewEmployee.Cols.FinanceSD.ID, err))
	}
	if dto.BankTariff, err = ToBankTariffsLookup(ID.Table.AddNewEmployee.Cols.BankTariff.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AddNewEmployee.Cols.BankTariff.Name, ID.Table.AddNewEmployee.Cols.BankTariff.ID, err))
	}
	if dto.ContractHourRate, err = ToFloat64(ID.Table.AddNewEmployee.Cols.ContractHourRate.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AddNewEmployee.Cols.ContractHourRate.Name, ID.Table.AddNewEmployee.Cols.ContractHourRate.ID, err))
	}
	if dto.Rounding, err = ToFloat64(ID.Table.AddNewEmployee.Cols.Rounding.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AddNewEmployee.Cols.Rounding.Name, ID.Table.AddNewEmployee.Cols.Rounding.ID, err))
	}
	if dto.EnglishFullName, err = ToString(ID.Table.AddNewEmployee.Cols.EnglishFullName.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AddNewEmployee.Cols.EnglishFullName.Name, ID.Table.AddNewEmployee.Cols.EnglishFullName.ID, err))
	}
	if dto.SpecialPaymentPolicy, err = ToBool(ID.Table.AddNewEmployee.Cols.SpecialPaymentPolicy.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AddNewEmployee.Cols.SpecialPaymentPolicy.Name, ID.Table.AddNewEmployee.Cols.SpecialPaymentPolicy.ID, err))
	}
	if dto.WorkingNow, err = ToBool(ID.Table.AddNewEmployee.Cols.WorkingNow.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AddNewEmployee.Cols.WorkingNow.Name, ID.Table.AddNewEmployee.Cols.WorkingNow.ID, err))
	}
	if dto.Valid, err = ToBool(ID.Table.AddNewEmployee.Cols.Valid.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AddNewEmployee.Cols.Valid.Name, ID.Table.AddNewEmployee.Cols.Valid.ID, err))
	}
	if dto.InvalidFields, err = ToString(ID.Table.AddNewEmployee.Cols.InvalidFields.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AddNewEmployee.Cols.InvalidFields.Name, ID.Table.AddNewEmployee.Cols.InvalidFields.ID, err))
	}

	if len(errc) > 0 {
		return AddNewEmployee{}, errc
	}

	return
}

// CurrentTemplateEntries is DTO for Current template entries table
type CurrentTemplateEntries struct {
	Employee  AllEmployeesLookup
	MonthFrom MonthsLookup
	MonthTo   MonthsLookup
	Type      EntryTypeLookup
	RUBAmount float64
	EURAmount float64
	Comment   string
}

func NewCurrentTemplateEntries(row Valuer) (dto CurrentTemplateEntries, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Employee, err = ToAllEmployeesLookup(ID.Table.CurrentTemplateEntries.Cols.Employee.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentTemplateEntries.Cols.Employee.Name, ID.Table.CurrentTemplateEntries.Cols.Employee.ID, err))
	}
	if dto.MonthFrom, err = ToMonthsLookup(ID.Table.CurrentTemplateEntries.Cols.MonthFrom.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentTemplateEntries.Cols.MonthFrom.Name, ID.Table.CurrentTemplateEntries.Cols.MonthFrom.ID, err))
	}
	if dto.MonthTo, err = ToMonthsLookup(ID.Table.CurrentTemplateEntries.Cols.MonthTo.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentTemplateEntries.Cols.MonthTo.Name, ID.Table.CurrentTemplateEntries.Cols.MonthTo.ID, err))
	}
	if dto.Type, err = ToEntryTypeLookup(ID.Table.CurrentTemplateEntries.Cols.Type.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentTemplateEntries.Cols.Type.Name, ID.Table.CurrentTemplateEntries.Cols.Type.ID, err))
	}
	if dto.RUBAmount, err = ToFloat64(ID.Table.CurrentTemplateEntries.Cols.RUBAmount.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentTemplateEntries.Cols.RUBAmount.Name, ID.Table.CurrentTemplateEntries.Cols.RUBAmount.ID, err))
	}
	if dto.EURAmount, err = ToFloat64(ID.Table.CurrentTemplateEntries.Cols.EURAmount.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentTemplateEntries.Cols.EURAmount.Name, ID.Table.CurrentTemplateEntries.Cols.EURAmount.ID, err))
	}
	if dto.Comment, err = ToString(ID.Table.CurrentTemplateEntries.Cols.Comment.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.CurrentTemplateEntries.Cols.Comment.Name, ID.Table.CurrentTemplateEntries.Cols.Comment.ID, err))
	}

	if len(errc) > 0 {
		return CurrentTemplateEntries{}, errc
	}

	return
}

// TemplateEntriesMonthsFiltering is DTO for Template entries months filtering table
type TemplateEntriesMonthsFiltering struct {
	Month                                                                                                             MonthsLookup
	FormatTypeButtonTextTypeSlateRootChildrenAlignmentLeftChildrenTextFrom202112IdCl0LineLevel0StyleParagraphTypeLine string
	FormatTypeButtonTextTypeSlateRootChildrenAlignmentLeftChildrenTextTo202112IdCl0LineLevel0StyleParagraphTypeLine   string
	FromValue                                                                                                         bool
	ToValue                                                                                                           bool
	Button                                                                                                            string
}

func NewTemplateEntriesMonthsFiltering(row Valuer) (dto TemplateEntriesMonthsFiltering, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Month, err = ToMonthsLookup(ID.Table.TemplateEntriesMonthsFiltering.Cols.Month.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TemplateEntriesMonthsFiltering.Cols.Month.Name, ID.Table.TemplateEntriesMonthsFiltering.Cols.Month.ID, err))
	}
	if dto.FormatTypeButtonTextTypeSlateRootChildrenAlignmentLeftChildrenTextFrom202112IdCl0LineLevel0StyleParagraphTypeLine, err = ToString(ID.Table.TemplateEntriesMonthsFiltering.Cols.FormatTypeButtonTextTypeSlateRootChildrenAlignmentLeftChildrenTextFrom202112IdCl0LineLevel0StyleParagraphTypeLine.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TemplateEntriesMonthsFiltering.Cols.FormatTypeButtonTextTypeSlateRootChildrenAlignmentLeftChildrenTextFrom202112IdCl0LineLevel0StyleParagraphTypeLine.Name, ID.Table.TemplateEntriesMonthsFiltering.Cols.FormatTypeButtonTextTypeSlateRootChildrenAlignmentLeftChildrenTextFrom202112IdCl0LineLevel0StyleParagraphTypeLine.ID, err))
	}
	if dto.FormatTypeButtonTextTypeSlateRootChildrenAlignmentLeftChildrenTextTo202112IdCl0LineLevel0StyleParagraphTypeLine, err = ToString(ID.Table.TemplateEntriesMonthsFiltering.Cols.FormatTypeButtonTextTypeSlateRootChildrenAlignmentLeftChildrenTextTo202112IdCl0LineLevel0StyleParagraphTypeLine.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TemplateEntriesMonthsFiltering.Cols.FormatTypeButtonTextTypeSlateRootChildrenAlignmentLeftChildrenTextTo202112IdCl0LineLevel0StyleParagraphTypeLine.Name, ID.Table.TemplateEntriesMonthsFiltering.Cols.FormatTypeButtonTextTypeSlateRootChildrenAlignmentLeftChildrenTextTo202112IdCl0LineLevel0StyleParagraphTypeLine.ID, err))
	}
	if dto.FromValue, err = ToBool(ID.Table.TemplateEntriesMonthsFiltering.Cols.FromValue.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TemplateEntriesMonthsFiltering.Cols.FromValue.Name, ID.Table.TemplateEntriesMonthsFiltering.Cols.FromValue.ID, err))
	}
	if dto.ToValue, err = ToBool(ID.Table.TemplateEntriesMonthsFiltering.Cols.ToValue.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TemplateEntriesMonthsFiltering.Cols.ToValue.Name, ID.Table.TemplateEntriesMonthsFiltering.Cols.ToValue.ID, err))
	}
	if dto.Button, err = ToString(ID.Table.TemplateEntriesMonthsFiltering.Cols.Button.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TemplateEntriesMonthsFiltering.Cols.Button.Name, ID.Table.TemplateEntriesMonthsFiltering.Cols.Button.ID, err))
	}

	if len(errc) > 0 {
		return TemplateEntriesMonthsFiltering{}, errc
	}

	return
}

// TemplateEntriesTypeFiltering is DTO for Template entries type filtering table
type TemplateEntriesTypeFiltering struct {
	Type          EntryTypeLookup
	FilteringType EntryTypeLookup
	OnlyBtn       string
	InclBtn       string
	ExclBtn       string
}

func NewTemplateEntriesTypeFiltering(row Valuer) (dto TemplateEntriesTypeFiltering, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Type, err = ToEntryTypeLookup(ID.Table.TemplateEntriesTypeFiltering.Cols.Type.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TemplateEntriesTypeFiltering.Cols.Type.Name, ID.Table.TemplateEntriesTypeFiltering.Cols.Type.ID, err))
	}
	if dto.FilteringType, err = ToEntryTypeLookup(ID.Table.TemplateEntriesTypeFiltering.Cols.FilteringType.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TemplateEntriesTypeFiltering.Cols.FilteringType.Name, ID.Table.TemplateEntriesTypeFiltering.Cols.FilteringType.ID, err))
	}
	if dto.OnlyBtn, err = ToString(ID.Table.TemplateEntriesTypeFiltering.Cols.OnlyBtn.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TemplateEntriesTypeFiltering.Cols.OnlyBtn.Name, ID.Table.TemplateEntriesTypeFiltering.Cols.OnlyBtn.ID, err))
	}
	if dto.InclBtn, err = ToString(ID.Table.TemplateEntriesTypeFiltering.Cols.InclBtn.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TemplateEntriesTypeFiltering.Cols.InclBtn.Name, ID.Table.TemplateEntriesTypeFiltering.Cols.InclBtn.ID, err))
	}
	if dto.ExclBtn, err = ToString(ID.Table.TemplateEntriesTypeFiltering.Cols.ExclBtn.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TemplateEntriesTypeFiltering.Cols.ExclBtn.Name, ID.Table.TemplateEntriesTypeFiltering.Cols.ExclBtn.ID, err))
	}

	if len(errc) > 0 {
		return TemplateEntriesTypeFiltering{}, errc
	}

	return
}

// EntriesMonthsFiltering is DTO for Entries months filtering table
type EntriesMonthsFiltering struct {
	Month                                                                                                             MonthsLookup
	FormatTypeButtonTextTypeSlateRootChildrenAlignmentLeftChildrenTextFrom202112IdCl0LineLevel0StyleParagraphTypeLine string
	FormatTypeButtonTextTypeSlateRootChildrenAlignmentLeftChildrenTextTo202112IdCl0LineLevel0StyleParagraphTypeLine   string
	FromValue                                                                                                         bool
	ToValue                                                                                                           bool
	Button                                                                                                            string
}

func NewEntriesMonthsFiltering(row Valuer) (dto EntriesMonthsFiltering, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Month, err = ToMonthsLookup(ID.Table.EntriesMonthsFiltering.Cols.Month.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EntriesMonthsFiltering.Cols.Month.Name, ID.Table.EntriesMonthsFiltering.Cols.Month.ID, err))
	}
	if dto.FormatTypeButtonTextTypeSlateRootChildrenAlignmentLeftChildrenTextFrom202112IdCl0LineLevel0StyleParagraphTypeLine, err = ToString(ID.Table.EntriesMonthsFiltering.Cols.FormatTypeButtonTextTypeSlateRootChildrenAlignmentLeftChildrenTextFrom202112IdCl0LineLevel0StyleParagraphTypeLine.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EntriesMonthsFiltering.Cols.FormatTypeButtonTextTypeSlateRootChildrenAlignmentLeftChildrenTextFrom202112IdCl0LineLevel0StyleParagraphTypeLine.Name, ID.Table.EntriesMonthsFiltering.Cols.FormatTypeButtonTextTypeSlateRootChildrenAlignmentLeftChildrenTextFrom202112IdCl0LineLevel0StyleParagraphTypeLine.ID, err))
	}
	if dto.FormatTypeButtonTextTypeSlateRootChildrenAlignmentLeftChildrenTextTo202112IdCl0LineLevel0StyleParagraphTypeLine, err = ToString(ID.Table.EntriesMonthsFiltering.Cols.FormatTypeButtonTextTypeSlateRootChildrenAlignmentLeftChildrenTextTo202112IdCl0LineLevel0StyleParagraphTypeLine.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EntriesMonthsFiltering.Cols.FormatTypeButtonTextTypeSlateRootChildrenAlignmentLeftChildrenTextTo202112IdCl0LineLevel0StyleParagraphTypeLine.Name, ID.Table.EntriesMonthsFiltering.Cols.FormatTypeButtonTextTypeSlateRootChildrenAlignmentLeftChildrenTextTo202112IdCl0LineLevel0StyleParagraphTypeLine.ID, err))
	}
	if dto.FromValue, err = ToBool(ID.Table.EntriesMonthsFiltering.Cols.FromValue.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EntriesMonthsFiltering.Cols.FromValue.Name, ID.Table.EntriesMonthsFiltering.Cols.FromValue.ID, err))
	}
	if dto.ToValue, err = ToBool(ID.Table.EntriesMonthsFiltering.Cols.ToValue.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EntriesMonthsFiltering.Cols.ToValue.Name, ID.Table.EntriesMonthsFiltering.Cols.ToValue.ID, err))
	}
	if dto.Button, err = ToString(ID.Table.EntriesMonthsFiltering.Cols.Button.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EntriesMonthsFiltering.Cols.Button.Name, ID.Table.EntriesMonthsFiltering.Cols.Button.ID, err))
	}

	if len(errc) > 0 {
		return EntriesMonthsFiltering{}, errc
	}

	return
}

// EntriesTypeFiltering is DTO for Entries type filtering table
type EntriesTypeFiltering struct {
	Type          EntryTypeLookup
	FilteringType EntryTypeLookup
	OnlyBtn       string
	InclBtn       string
	ExclBtn       string
}

func NewEntriesTypeFiltering(row Valuer) (dto EntriesTypeFiltering, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Type, err = ToEntryTypeLookup(ID.Table.EntriesTypeFiltering.Cols.Type.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EntriesTypeFiltering.Cols.Type.Name, ID.Table.EntriesTypeFiltering.Cols.Type.ID, err))
	}
	if dto.FilteringType, err = ToEntryTypeLookup(ID.Table.EntriesTypeFiltering.Cols.FilteringType.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EntriesTypeFiltering.Cols.FilteringType.Name, ID.Table.EntriesTypeFiltering.Cols.FilteringType.ID, err))
	}
	if dto.OnlyBtn, err = ToString(ID.Table.EntriesTypeFiltering.Cols.OnlyBtn.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EntriesTypeFiltering.Cols.OnlyBtn.Name, ID.Table.EntriesTypeFiltering.Cols.OnlyBtn.ID, err))
	}
	if dto.InclBtn, err = ToString(ID.Table.EntriesTypeFiltering.Cols.InclBtn.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EntriesTypeFiltering.Cols.InclBtn.Name, ID.Table.EntriesTypeFiltering.Cols.InclBtn.ID, err))
	}
	if dto.ExclBtn, err = ToString(ID.Table.EntriesTypeFiltering.Cols.ExclBtn.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.EntriesTypeFiltering.Cols.ExclBtn.Name, ID.Table.EntriesTypeFiltering.Cols.ExclBtn.ID, err))
	}

	if len(errc) > 0 {
		return EntriesTypeFiltering{}, errc
	}

	return
}

// FilteredEntries is DTO for Filtered Entries table
type FilteredEntries struct {
	Invoice   InvoiceLookup
	Type      EntryTypeLookup
	RUBAmount float64
	EURAmount float64
	Comment   string
}

func NewFilteredEntries(row Valuer) (dto FilteredEntries, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Invoice, err = ToInvoiceLookup(ID.Table.FilteredEntries.Cols.Invoice.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.FilteredEntries.Cols.Invoice.Name, ID.Table.FilteredEntries.Cols.Invoice.ID, err))
	}
	if dto.Type, err = ToEntryTypeLookup(ID.Table.FilteredEntries.Cols.Type.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.FilteredEntries.Cols.Type.Name, ID.Table.FilteredEntries.Cols.Type.ID, err))
	}
	if dto.RUBAmount, err = ToFloat64(ID.Table.FilteredEntries.Cols.RUBAmount.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.FilteredEntries.Cols.RUBAmount.Name, ID.Table.FilteredEntries.Cols.RUBAmount.ID, err))
	}
	if dto.EURAmount, err = ToFloat64(ID.Table.FilteredEntries.Cols.EURAmount.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.FilteredEntries.Cols.EURAmount.Name, ID.Table.FilteredEntries.Cols.EURAmount.ID, err))
	}
	if dto.Comment, err = ToString(ID.Table.FilteredEntries.Cols.Comment.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.FilteredEntries.Cols.Comment.Name, ID.Table.FilteredEntries.Cols.Comment.ID, err))
	}

	if len(errc) > 0 {
		return FilteredEntries{}, errc
	}

	return
}

// AddCompanyRate is DTO for Add company rate table
type AddCompanyRate struct {
	Month  MonthsLookup
	EURRUB float64
}

func NewAddCompanyRate(row Valuer) (dto AddCompanyRate, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Month, err = ToMonthsLookup(ID.Table.AddCompanyRate.Cols.Month.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AddCompanyRate.Cols.Month.Name, ID.Table.AddCompanyRate.Cols.Month.ID, err))
	}
	if dto.EURRUB, err = ToFloat64(ID.Table.AddCompanyRate.Cols.EURRUB.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.AddCompanyRate.Cols.EURRUB.Name, ID.Table.AddCompanyRate.Cols.EURRUB.ID, err))
	}

	if len(errc) > 0 {
		return AddCompanyRate{}, errc
	}

	return
}

// TESTTABLE is DTO for TEST TABLE table
type TESTTABLE struct {
	Name     float64
	Column2  []Attachment
	Column3  []Person
	Duration string
	Currency MonetaryAmount
	Email    string
	Slider   float64
	Percent  string
	Scale    uint8
	People   []Person
	Date     time.Time
	DateTime time.Time
	Time     time.Time
}

func NewTESTTABLE(row Valuer) (dto TESTTABLE, errs error) {
	var err error
	errc := NewErrorContainer()
	if dto.Name, err = ToFloat64(ID.Table.TESTTABLE.Cols.Name.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TESTTABLE.Cols.Name.Name, ID.Table.TESTTABLE.Cols.Name.ID, err))
	}
	if dto.Column2, err = ToAttachments(ID.Table.TESTTABLE.Cols.Column2.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TESTTABLE.Cols.Column2.Name, ID.Table.TESTTABLE.Cols.Column2.ID, err))
	}
	if dto.Column3, err = ToPersons(ID.Table.TESTTABLE.Cols.Column3.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TESTTABLE.Cols.Column3.Name, ID.Table.TESTTABLE.Cols.Column3.ID, err))
	}
	if dto.Duration, err = ToString(ID.Table.TESTTABLE.Cols.Duration.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TESTTABLE.Cols.Duration.Name, ID.Table.TESTTABLE.Cols.Duration.ID, err))
	}
	if dto.Currency, err = ToMonetaryAmount(ID.Table.TESTTABLE.Cols.Currency.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TESTTABLE.Cols.Currency.Name, ID.Table.TESTTABLE.Cols.Currency.ID, err))
	}
	if dto.Email, err = ToString(ID.Table.TESTTABLE.Cols.Email.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TESTTABLE.Cols.Email.Name, ID.Table.TESTTABLE.Cols.Email.ID, err))
	}
	if dto.Slider, err = ToFloat64(ID.Table.TESTTABLE.Cols.Slider.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TESTTABLE.Cols.Slider.Name, ID.Table.TESTTABLE.Cols.Slider.ID, err))
	}
	if dto.Percent, err = ToString(ID.Table.TESTTABLE.Cols.Percent.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TESTTABLE.Cols.Percent.Name, ID.Table.TESTTABLE.Cols.Percent.ID, err))
	}
	if dto.Scale, err = ToUint8(ID.Table.TESTTABLE.Cols.Scale.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TESTTABLE.Cols.Scale.Name, ID.Table.TESTTABLE.Cols.Scale.ID, err))
	}
	if dto.People, err = ToPersons(ID.Table.TESTTABLE.Cols.People.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TESTTABLE.Cols.People.Name, ID.Table.TESTTABLE.Cols.People.ID, err))
	}
	if dto.Date, err = ToDate(ID.Table.TESTTABLE.Cols.Date.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TESTTABLE.Cols.Date.Name, ID.Table.TESTTABLE.Cols.Date.ID, err))
	}
	if dto.DateTime, err = ToDateTime(ID.Table.TESTTABLE.Cols.DateTime.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TESTTABLE.Cols.DateTime.Name, ID.Table.TESTTABLE.Cols.DateTime.ID, err))
	}
	if dto.Time, err = ToTime(ID.Table.TESTTABLE.Cols.Time.ID, row); err != nil {
		errc.AddError(fmt.Errorf("field [%v] %v: %w", ID.Table.TESTTABLE.Cols.Time.Name, ID.Table.TESTTABLE.Cols.Time.ID, err))
	}

	if len(errc) > 0 {
		return TESTTABLE{}, errc
	}

	return
}

type LocationLookup struct {
	Values []LocationRowRef
}

// FirstRef returns a first referenced row metadata
func (l LocationLookup) FirstRef() (first LocationRowRef, found bool) {
	if len(l.Values) > 0 {
		return l.Values[0], true
	}

	return LocationRowRef{}, false
}

// FirstRefName returns a first referenced row's Display Column value
func (l LocationLookup) FirstRefName() string {
	if len(l.Values) > 0 {
		return l.Values[0].Name
	}

	return ""
}

// RefNames returns a slice of referenced rows' Display Columns values
func (l LocationLookup) RefNames() (names []string) {
	for _, v := range l.Values {
		names = append(names, v.Name)
	}

	return
}

// String returns a comma-separated Display Columns of referenced rows.
// This representation is similar to what is shown in the browser.
func (l LocationLookup) String() string {
	return strings.Join(l.RefNames(), ", ")
}

// First returns a pointer to a Location struct containing data of the first referenced row.
// It will return nil unless the lookup contains references and container of this LocationLookup was preloaded by the LoadRelations<Original Table> method
func (l LocationLookup) First() *Location {
	if len(l.Values) > 0 {
		return l.Values[0].Data
	}

	return nil
}

// FirstMaybe returns a Location struct containing data of the first referenced row.
// If the lookup doesn't contain any references or if reference data was not preloaded by the LoadRelations<Original Table> method it will return an empty structure with nil-values of it's fields
func (l LocationLookup) FirstMaybe() Location {
	if len(l.Values) > 0 {
		return *l.Values[0].Data
	}

	return Location{}
}

// MustFirst returns a Location struct containing data of the first referenced row.
// It will panic if the lookup doesn't contain any references or if reference data was not preloaded by the LoadRelations<Original Table> method
func (l LocationLookup) MustFirst() Location {
	if len(l.Values) > 0 && l.Values[0].Data != nil {
		return *l.Values[0].Data
	}

	panic("required Location value is not present in data row of LocationLookup, table [Location]")
}

// All returns all loaded data of the referenced rows if any
func (l LocationLookup) All() (data []Location) {
	for _, i := range l.Values {
		if i.Data != nil {
			data = append(data, *i.Data)
		}
	}

	return
}

// Hydrate fills this lookup values with the corresponding rows from the map[RowID]Location
func (l *LocationLookup) Hydrate(mapOf map[RowID]*Location) {
	for vi, v := range l.Values {
		if v.Data != nil {
			continue
		}
		if data, ok := mapOf[RowID(v.RowID)]; ok {
			l.Values[vi].Data = data
		}
	}
}

type LocationRowRef struct {
	Name  string
	RowID string
	Data  *Location
}

func ToLocationLookup(colID string, row Valuer) (values LocationLookup, err error) {
	rawv, ok := row.GetValue(colID)
	if !ok {
		return LocationLookup{}, fmt.Errorf("missing column %v in Location row", colID)
	}

	if strv, ok := rawv.(string); ok && strv == "" {
		return LocationLookup{}, nil
	}

	if slicev, ok := rawv.([]interface{}); ok {
		for i, interv := range slicev {
			sv, err := toStructuredValue(interv)
			if err != nil {
				return LocationLookup{}, fmt.Errorf("slice value #%v: %w", i, err)
			}
			values.Values = append(values.Values, LocationRowRef{
				Name:  sv.Name,
				RowID: sv.RowId,
			})
		}

		return
	}

	sv, err := toStructuredValue(rawv)
	if err != nil {
		return LocationLookup{}, err
	}

	values.Values = []LocationRowRef{
		{
			Name:  sv.Name,
			RowID: sv.RowId,
		},
	}

	return
}

type BankDetailsLookup struct {
	Values []BankDetailsRowRef
}

// FirstRef returns a first referenced row metadata
func (l BankDetailsLookup) FirstRef() (first BankDetailsRowRef, found bool) {
	if len(l.Values) > 0 {
		return l.Values[0], true
	}

	return BankDetailsRowRef{}, false
}

// FirstRefName returns a first referenced row's Display Column value
func (l BankDetailsLookup) FirstRefName() string {
	if len(l.Values) > 0 {
		return l.Values[0].Name
	}

	return ""
}

// RefNames returns a slice of referenced rows' Display Columns values
func (l BankDetailsLookup) RefNames() (names []string) {
	for _, v := range l.Values {
		names = append(names, v.Name)
	}

	return
}

// String returns a comma-separated Display Columns of referenced rows.
// This representation is similar to what is shown in the browser.
func (l BankDetailsLookup) String() string {
	return strings.Join(l.RefNames(), ", ")
}

// First returns a pointer to a BankDetails struct containing data of the first referenced row.
// It will return nil unless the lookup contains references and container of this BankDetailsLookup was preloaded by the LoadRelations<Original Table> method
func (l BankDetailsLookup) First() *BankDetails {
	if len(l.Values) > 0 {
		return l.Values[0].Data
	}

	return nil
}

// FirstMaybe returns a BankDetails struct containing data of the first referenced row.
// If the lookup doesn't contain any references or if reference data was not preloaded by the LoadRelations<Original Table> method it will return an empty structure with nil-values of it's fields
func (l BankDetailsLookup) FirstMaybe() BankDetails {
	if len(l.Values) > 0 {
		return *l.Values[0].Data
	}

	return BankDetails{}
}

// MustFirst returns a BankDetails struct containing data of the first referenced row.
// It will panic if the lookup doesn't contain any references or if reference data was not preloaded by the LoadRelations<Original Table> method
func (l BankDetailsLookup) MustFirst() BankDetails {
	if len(l.Values) > 0 && l.Values[0].Data != nil {
		return *l.Values[0].Data
	}

	panic("required BankDetails value is not present in data row of BankDetailsLookup, table [Bank details]")
}

// All returns all loaded data of the referenced rows if any
func (l BankDetailsLookup) All() (data []BankDetails) {
	for _, i := range l.Values {
		if i.Data != nil {
			data = append(data, *i.Data)
		}
	}

	return
}

// Hydrate fills this lookup values with the corresponding rows from the map[RowID]BankDetails
func (l *BankDetailsLookup) Hydrate(mapOf map[RowID]*BankDetails) {
	for vi, v := range l.Values {
		if v.Data != nil {
			continue
		}
		if data, ok := mapOf[RowID(v.RowID)]; ok {
			l.Values[vi].Data = data
		}
	}
}

type BankDetailsRowRef struct {
	Name  string
	RowID string
	Data  *BankDetails
}

func ToBankDetailsLookup(colID string, row Valuer) (values BankDetailsLookup, err error) {
	rawv, ok := row.GetValue(colID)
	if !ok {
		return BankDetailsLookup{}, fmt.Errorf("missing column %v in Bank details row", colID)
	}

	if strv, ok := rawv.(string); ok && strv == "" {
		return BankDetailsLookup{}, nil
	}

	if slicev, ok := rawv.([]interface{}); ok {
		for i, interv := range slicev {
			sv, err := toStructuredValue(interv)
			if err != nil {
				return BankDetailsLookup{}, fmt.Errorf("slice value #%v: %w", i, err)
			}
			values.Values = append(values.Values, BankDetailsRowRef{
				Name:  sv.Name,
				RowID: sv.RowId,
			})
		}

		return
	}

	sv, err := toStructuredValue(rawv)
	if err != nil {
		return BankDetailsLookup{}, err
	}

	values.Values = []BankDetailsRowRef{
		{
			Name:  sv.Name,
			RowID: sv.RowId,
		},
	}

	return
}

type EntriesLookup struct {
	Values []EntriesRowRef
}

// FirstRef returns a first referenced row metadata
func (l EntriesLookup) FirstRef() (first EntriesRowRef, found bool) {
	if len(l.Values) > 0 {
		return l.Values[0], true
	}

	return EntriesRowRef{}, false
}

// FirstRefName returns a first referenced row's Display Column value
func (l EntriesLookup) FirstRefName() string {
	if len(l.Values) > 0 {
		return l.Values[0].Name
	}

	return ""
}

// RefNames returns a slice of referenced rows' Display Columns values
func (l EntriesLookup) RefNames() (names []string) {
	for _, v := range l.Values {
		names = append(names, v.Name)
	}

	return
}

// String returns a comma-separated Display Columns of referenced rows.
// This representation is similar to what is shown in the browser.
func (l EntriesLookup) String() string {
	return strings.Join(l.RefNames(), ", ")
}

// First returns a pointer to a Entries struct containing data of the first referenced row.
// It will return nil unless the lookup contains references and container of this EntriesLookup was preloaded by the LoadRelations<Original Table> method
func (l EntriesLookup) First() *Entries {
	if len(l.Values) > 0 {
		return l.Values[0].Data
	}

	return nil
}

// FirstMaybe returns a Entries struct containing data of the first referenced row.
// If the lookup doesn't contain any references or if reference data was not preloaded by the LoadRelations<Original Table> method it will return an empty structure with nil-values of it's fields
func (l EntriesLookup) FirstMaybe() Entries {
	if len(l.Values) > 0 {
		return *l.Values[0].Data
	}

	return Entries{}
}

// MustFirst returns a Entries struct containing data of the first referenced row.
// It will panic if the lookup doesn't contain any references or if reference data was not preloaded by the LoadRelations<Original Table> method
func (l EntriesLookup) MustFirst() Entries {
	if len(l.Values) > 0 && l.Values[0].Data != nil {
		return *l.Values[0].Data
	}

	panic("required Entries value is not present in data row of EntriesLookup, table [Entries]")
}

// All returns all loaded data of the referenced rows if any
func (l EntriesLookup) All() (data []Entries) {
	for _, i := range l.Values {
		if i.Data != nil {
			data = append(data, *i.Data)
		}
	}

	return
}

// Hydrate fills this lookup values with the corresponding rows from the map[RowID]Entries
func (l *EntriesLookup) Hydrate(mapOf map[RowID]*Entries) {
	for vi, v := range l.Values {
		if v.Data != nil {
			continue
		}
		if data, ok := mapOf[RowID(v.RowID)]; ok {
			l.Values[vi].Data = data
		}
	}
}

type EntriesRowRef struct {
	Name  string
	RowID string
	Data  *Entries
}

func ToEntriesLookup(colID string, row Valuer) (values EntriesLookup, err error) {
	rawv, ok := row.GetValue(colID)
	if !ok {
		return EntriesLookup{}, fmt.Errorf("missing column %v in Entries row", colID)
	}

	if strv, ok := rawv.(string); ok && strv == "" {
		return EntriesLookup{}, nil
	}

	if slicev, ok := rawv.([]interface{}); ok {
		for i, interv := range slicev {
			sv, err := toStructuredValue(interv)
			if err != nil {
				return EntriesLookup{}, fmt.Errorf("slice value #%v: %w", i, err)
			}
			values.Values = append(values.Values, EntriesRowRef{
				Name:  sv.Name,
				RowID: sv.RowId,
			})
		}

		return
	}

	sv, err := toStructuredValue(rawv)
	if err != nil {
		return EntriesLookup{}, err
	}

	values.Values = []EntriesRowRef{
		{
			Name:  sv.Name,
			RowID: sv.RowId,
		},
	}

	return
}

type TemplateEntriesLookup struct {
	Values []TemplateEntriesRowRef
}

// FirstRef returns a first referenced row metadata
func (l TemplateEntriesLookup) FirstRef() (first TemplateEntriesRowRef, found bool) {
	if len(l.Values) > 0 {
		return l.Values[0], true
	}

	return TemplateEntriesRowRef{}, false
}

// FirstRefName returns a first referenced row's Display Column value
func (l TemplateEntriesLookup) FirstRefName() string {
	if len(l.Values) > 0 {
		return l.Values[0].Name
	}

	return ""
}

// RefNames returns a slice of referenced rows' Display Columns values
func (l TemplateEntriesLookup) RefNames() (names []string) {
	for _, v := range l.Values {
		names = append(names, v.Name)
	}

	return
}

// String returns a comma-separated Display Columns of referenced rows.
// This representation is similar to what is shown in the browser.
func (l TemplateEntriesLookup) String() string {
	return strings.Join(l.RefNames(), ", ")
}

// First returns a pointer to a TemplateEntries struct containing data of the first referenced row.
// It will return nil unless the lookup contains references and container of this TemplateEntriesLookup was preloaded by the LoadRelations<Original Table> method
func (l TemplateEntriesLookup) First() *TemplateEntries {
	if len(l.Values) > 0 {
		return l.Values[0].Data
	}

	return nil
}

// FirstMaybe returns a TemplateEntries struct containing data of the first referenced row.
// If the lookup doesn't contain any references or if reference data was not preloaded by the LoadRelations<Original Table> method it will return an empty structure with nil-values of it's fields
func (l TemplateEntriesLookup) FirstMaybe() TemplateEntries {
	if len(l.Values) > 0 {
		return *l.Values[0].Data
	}

	return TemplateEntries{}
}

// MustFirst returns a TemplateEntries struct containing data of the first referenced row.
// It will panic if the lookup doesn't contain any references or if reference data was not preloaded by the LoadRelations<Original Table> method
func (l TemplateEntriesLookup) MustFirst() TemplateEntries {
	if len(l.Values) > 0 && l.Values[0].Data != nil {
		return *l.Values[0].Data
	}

	panic("required TemplateEntries value is not present in data row of TemplateEntriesLookup, table [Template Entries]")
}

// All returns all loaded data of the referenced rows if any
func (l TemplateEntriesLookup) All() (data []TemplateEntries) {
	for _, i := range l.Values {
		if i.Data != nil {
			data = append(data, *i.Data)
		}
	}

	return
}

// Hydrate fills this lookup values with the corresponding rows from the map[RowID]TemplateEntries
func (l *TemplateEntriesLookup) Hydrate(mapOf map[RowID]*TemplateEntries) {
	for vi, v := range l.Values {
		if v.Data != nil {
			continue
		}
		if data, ok := mapOf[RowID(v.RowID)]; ok {
			l.Values[vi].Data = data
		}
	}
}

type TemplateEntriesRowRef struct {
	Name  string
	RowID string
	Data  *TemplateEntries
}

func ToTemplateEntriesLookup(colID string, row Valuer) (values TemplateEntriesLookup, err error) {
	rawv, ok := row.GetValue(colID)
	if !ok {
		return TemplateEntriesLookup{}, fmt.Errorf("missing column %v in Template Entries row", colID)
	}

	if strv, ok := rawv.(string); ok && strv == "" {
		return TemplateEntriesLookup{}, nil
	}

	if slicev, ok := rawv.([]interface{}); ok {
		for i, interv := range slicev {
			sv, err := toStructuredValue(interv)
			if err != nil {
				return TemplateEntriesLookup{}, fmt.Errorf("slice value #%v: %w", i, err)
			}
			values.Values = append(values.Values, TemplateEntriesRowRef{
				Name:  sv.Name,
				RowID: sv.RowId,
			})
		}

		return
	}

	sv, err := toStructuredValue(rawv)
	if err != nil {
		return TemplateEntriesLookup{}, err
	}

	values.Values = []TemplateEntriesRowRef{
		{
			Name:  sv.Name,
			RowID: sv.RowId,
		},
	}

	return
}

type BeneficiaryBankLookup struct {
	Values []BeneficiaryBankRowRef
}

// FirstRef returns a first referenced row metadata
func (l BeneficiaryBankLookup) FirstRef() (first BeneficiaryBankRowRef, found bool) {
	if len(l.Values) > 0 {
		return l.Values[0], true
	}

	return BeneficiaryBankRowRef{}, false
}

// FirstRefName returns a first referenced row's Display Column value
func (l BeneficiaryBankLookup) FirstRefName() string {
	if len(l.Values) > 0 {
		return l.Values[0].Name
	}

	return ""
}

// RefNames returns a slice of referenced rows' Display Columns values
func (l BeneficiaryBankLookup) RefNames() (names []string) {
	for _, v := range l.Values {
		names = append(names, v.Name)
	}

	return
}

// String returns a comma-separated Display Columns of referenced rows.
// This representation is similar to what is shown in the browser.
func (l BeneficiaryBankLookup) String() string {
	return strings.Join(l.RefNames(), ", ")
}

// First returns a pointer to a BeneficiaryBank struct containing data of the first referenced row.
// It will return nil unless the lookup contains references and container of this BeneficiaryBankLookup was preloaded by the LoadRelations<Original Table> method
func (l BeneficiaryBankLookup) First() *BeneficiaryBank {
	if len(l.Values) > 0 {
		return l.Values[0].Data
	}

	return nil
}

// FirstMaybe returns a BeneficiaryBank struct containing data of the first referenced row.
// If the lookup doesn't contain any references or if reference data was not preloaded by the LoadRelations<Original Table> method it will return an empty structure with nil-values of it's fields
func (l BeneficiaryBankLookup) FirstMaybe() BeneficiaryBank {
	if len(l.Values) > 0 {
		return *l.Values[0].Data
	}

	return BeneficiaryBank{}
}

// MustFirst returns a BeneficiaryBank struct containing data of the first referenced row.
// It will panic if the lookup doesn't contain any references or if reference data was not preloaded by the LoadRelations<Original Table> method
func (l BeneficiaryBankLookup) MustFirst() BeneficiaryBank {
	if len(l.Values) > 0 && l.Values[0].Data != nil {
		return *l.Values[0].Data
	}

	panic("required BeneficiaryBank value is not present in data row of BeneficiaryBankLookup, table [Beneficiary Bank]")
}

// All returns all loaded data of the referenced rows if any
func (l BeneficiaryBankLookup) All() (data []BeneficiaryBank) {
	for _, i := range l.Values {
		if i.Data != nil {
			data = append(data, *i.Data)
		}
	}

	return
}

// Hydrate fills this lookup values with the corresponding rows from the map[RowID]BeneficiaryBank
func (l *BeneficiaryBankLookup) Hydrate(mapOf map[RowID]*BeneficiaryBank) {
	for vi, v := range l.Values {
		if v.Data != nil {
			continue
		}
		if data, ok := mapOf[RowID(v.RowID)]; ok {
			l.Values[vi].Data = data
		}
	}
}

type BeneficiaryBankRowRef struct {
	Name  string
	RowID string
	Data  *BeneficiaryBank
}

func ToBeneficiaryBankLookup(colID string, row Valuer) (values BeneficiaryBankLookup, err error) {
	rawv, ok := row.GetValue(colID)
	if !ok {
		return BeneficiaryBankLookup{}, fmt.Errorf("missing column %v in Beneficiary Bank row", colID)
	}

	if strv, ok := rawv.(string); ok && strv == "" {
		return BeneficiaryBankLookup{}, nil
	}

	if slicev, ok := rawv.([]interface{}); ok {
		for i, interv := range slicev {
			sv, err := toStructuredValue(interv)
			if err != nil {
				return BeneficiaryBankLookup{}, fmt.Errorf("slice value #%v: %w", i, err)
			}
			values.Values = append(values.Values, BeneficiaryBankRowRef{
				Name:  sv.Name,
				RowID: sv.RowId,
			})
		}

		return
	}

	sv, err := toStructuredValue(rawv)
	if err != nil {
		return BeneficiaryBankLookup{}, err
	}

	values.Values = []BeneficiaryBankRowRef{
		{
			Name:  sv.Name,
			RowID: sv.RowId,
		},
	}

	return
}

type LegalEntityLookup struct {
	Values []LegalEntityRowRef
}

// FirstRef returns a first referenced row metadata
func (l LegalEntityLookup) FirstRef() (first LegalEntityRowRef, found bool) {
	if len(l.Values) > 0 {
		return l.Values[0], true
	}

	return LegalEntityRowRef{}, false
}

// FirstRefName returns a first referenced row's Display Column value
func (l LegalEntityLookup) FirstRefName() string {
	if len(l.Values) > 0 {
		return l.Values[0].Name
	}

	return ""
}

// RefNames returns a slice of referenced rows' Display Columns values
func (l LegalEntityLookup) RefNames() (names []string) {
	for _, v := range l.Values {
		names = append(names, v.Name)
	}

	return
}

// String returns a comma-separated Display Columns of referenced rows.
// This representation is similar to what is shown in the browser.
func (l LegalEntityLookup) String() string {
	return strings.Join(l.RefNames(), ", ")
}

// First returns a pointer to a LegalEntity struct containing data of the first referenced row.
// It will return nil unless the lookup contains references and container of this LegalEntityLookup was preloaded by the LoadRelations<Original Table> method
func (l LegalEntityLookup) First() *LegalEntity {
	if len(l.Values) > 0 {
		return l.Values[0].Data
	}

	return nil
}

// FirstMaybe returns a LegalEntity struct containing data of the first referenced row.
// If the lookup doesn't contain any references or if reference data was not preloaded by the LoadRelations<Original Table> method it will return an empty structure with nil-values of it's fields
func (l LegalEntityLookup) FirstMaybe() LegalEntity {
	if len(l.Values) > 0 {
		return *l.Values[0].Data
	}

	return LegalEntity{}
}

// MustFirst returns a LegalEntity struct containing data of the first referenced row.
// It will panic if the lookup doesn't contain any references or if reference data was not preloaded by the LoadRelations<Original Table> method
func (l LegalEntityLookup) MustFirst() LegalEntity {
	if len(l.Values) > 0 && l.Values[0].Data != nil {
		return *l.Values[0].Data
	}

	panic("required LegalEntity value is not present in data row of LegalEntityLookup, table [Legal entity]")
}

// All returns all loaded data of the referenced rows if any
func (l LegalEntityLookup) All() (data []LegalEntity) {
	for _, i := range l.Values {
		if i.Data != nil {
			data = append(data, *i.Data)
		}
	}

	return
}

// Hydrate fills this lookup values with the corresponding rows from the map[RowID]LegalEntity
func (l *LegalEntityLookup) Hydrate(mapOf map[RowID]*LegalEntity) {
	for vi, v := range l.Values {
		if v.Data != nil {
			continue
		}
		if data, ok := mapOf[RowID(v.RowID)]; ok {
			l.Values[vi].Data = data
		}
	}
}

type LegalEntityRowRef struct {
	Name  string
	RowID string
	Data  *LegalEntity
}

func ToLegalEntityLookup(colID string, row Valuer) (values LegalEntityLookup, err error) {
	rawv, ok := row.GetValue(colID)
	if !ok {
		return LegalEntityLookup{}, fmt.Errorf("missing column %v in Legal entity row", colID)
	}

	if strv, ok := rawv.(string); ok && strv == "" {
		return LegalEntityLookup{}, nil
	}

	if slicev, ok := rawv.([]interface{}); ok {
		for i, interv := range slicev {
			sv, err := toStructuredValue(interv)
			if err != nil {
				return LegalEntityLookup{}, fmt.Errorf("slice value #%v: %w", i, err)
			}
			values.Values = append(values.Values, LegalEntityRowRef{
				Name:  sv.Name,
				RowID: sv.RowId,
			})
		}

		return
	}

	sv, err := toStructuredValue(rawv)
	if err != nil {
		return LegalEntityLookup{}, err
	}

	values.Values = []LegalEntityRowRef{
		{
			Name:  sv.Name,
			RowID: sv.RowId,
		},
	}

	return
}

type MonthsLookup struct {
	Values []MonthsRowRef
}

// FirstRef returns a first referenced row metadata
func (l MonthsLookup) FirstRef() (first MonthsRowRef, found bool) {
	if len(l.Values) > 0 {
		return l.Values[0], true
	}

	return MonthsRowRef{}, false
}

// FirstRefName returns a first referenced row's Display Column value
func (l MonthsLookup) FirstRefName() string {
	if len(l.Values) > 0 {
		return l.Values[0].Name
	}

	return ""
}

// RefNames returns a slice of referenced rows' Display Columns values
func (l MonthsLookup) RefNames() (names []string) {
	for _, v := range l.Values {
		names = append(names, v.Name)
	}

	return
}

// String returns a comma-separated Display Columns of referenced rows.
// This representation is similar to what is shown in the browser.
func (l MonthsLookup) String() string {
	return strings.Join(l.RefNames(), ", ")
}

// First returns a pointer to a Months struct containing data of the first referenced row.
// It will return nil unless the lookup contains references and container of this MonthsLookup was preloaded by the LoadRelations<Original Table> method
func (l MonthsLookup) First() *Months {
	if len(l.Values) > 0 {
		return l.Values[0].Data
	}

	return nil
}

// FirstMaybe returns a Months struct containing data of the first referenced row.
// If the lookup doesn't contain any references or if reference data was not preloaded by the LoadRelations<Original Table> method it will return an empty structure with nil-values of it's fields
func (l MonthsLookup) FirstMaybe() Months {
	if len(l.Values) > 0 {
		return *l.Values[0].Data
	}

	return Months{}
}

// MustFirst returns a Months struct containing data of the first referenced row.
// It will panic if the lookup doesn't contain any references or if reference data was not preloaded by the LoadRelations<Original Table> method
func (l MonthsLookup) MustFirst() Months {
	if len(l.Values) > 0 && l.Values[0].Data != nil {
		return *l.Values[0].Data
	}

	panic("required Months value is not present in data row of MonthsLookup, table [Months]")
}

// All returns all loaded data of the referenced rows if any
func (l MonthsLookup) All() (data []Months) {
	for _, i := range l.Values {
		if i.Data != nil {
			data = append(data, *i.Data)
		}
	}

	return
}

// Hydrate fills this lookup values with the corresponding rows from the map[RowID]Months
func (l *MonthsLookup) Hydrate(mapOf map[RowID]*Months) {
	for vi, v := range l.Values {
		if v.Data != nil {
			continue
		}
		if data, ok := mapOf[RowID(v.RowID)]; ok {
			l.Values[vi].Data = data
		}
	}
}

type MonthsRowRef struct {
	Name  string
	RowID string
	Data  *Months
}

func ToMonthsLookup(colID string, row Valuer) (values MonthsLookup, err error) {
	rawv, ok := row.GetValue(colID)
	if !ok {
		return MonthsLookup{}, fmt.Errorf("missing column %v in Months row", colID)
	}

	if strv, ok := rawv.(string); ok && strv == "" {
		return MonthsLookup{}, nil
	}

	if slicev, ok := rawv.([]interface{}); ok {
		for i, interv := range slicev {
			sv, err := toStructuredValue(interv)
			if err != nil {
				return MonthsLookup{}, fmt.Errorf("slice value #%v: %w", i, err)
			}
			values.Values = append(values.Values, MonthsRowRef{
				Name:  sv.Name,
				RowID: sv.RowId,
			})
		}

		return
	}

	sv, err := toStructuredValue(rawv)
	if err != nil {
		return MonthsLookup{}, err
	}

	values.Values = []MonthsRowRef{
		{
			Name:  sv.Name,
			RowID: sv.RowId,
		},
	}

	return
}

type AllEmployeesLookup struct {
	Values []AllEmployeesRowRef
}

// FirstRef returns a first referenced row metadata
func (l AllEmployeesLookup) FirstRef() (first AllEmployeesRowRef, found bool) {
	if len(l.Values) > 0 {
		return l.Values[0], true
	}

	return AllEmployeesRowRef{}, false
}

// FirstRefName returns a first referenced row's Display Column value
func (l AllEmployeesLookup) FirstRefName() string {
	if len(l.Values) > 0 {
		return l.Values[0].Name
	}

	return ""
}

// RefNames returns a slice of referenced rows' Display Columns values
func (l AllEmployeesLookup) RefNames() (names []string) {
	for _, v := range l.Values {
		names = append(names, v.Name)
	}

	return
}

// String returns a comma-separated Display Columns of referenced rows.
// This representation is similar to what is shown in the browser.
func (l AllEmployeesLookup) String() string {
	return strings.Join(l.RefNames(), ", ")
}

// First returns a pointer to a AllEmployees struct containing data of the first referenced row.
// It will return nil unless the lookup contains references and container of this AllEmployeesLookup was preloaded by the LoadRelations<Original Table> method
func (l AllEmployeesLookup) First() *AllEmployees {
	if len(l.Values) > 0 {
		return l.Values[0].Data
	}

	return nil
}

// FirstMaybe returns a AllEmployees struct containing data of the first referenced row.
// If the lookup doesn't contain any references or if reference data was not preloaded by the LoadRelations<Original Table> method it will return an empty structure with nil-values of it's fields
func (l AllEmployeesLookup) FirstMaybe() AllEmployees {
	if len(l.Values) > 0 {
		return *l.Values[0].Data
	}

	return AllEmployees{}
}

// MustFirst returns a AllEmployees struct containing data of the first referenced row.
// It will panic if the lookup doesn't contain any references or if reference data was not preloaded by the LoadRelations<Original Table> method
func (l AllEmployeesLookup) MustFirst() AllEmployees {
	if len(l.Values) > 0 && l.Values[0].Data != nil {
		return *l.Values[0].Data
	}

	panic("required AllEmployees value is not present in data row of AllEmployeesLookup, table [All employees]")
}

// All returns all loaded data of the referenced rows if any
func (l AllEmployeesLookup) All() (data []AllEmployees) {
	for _, i := range l.Values {
		if i.Data != nil {
			data = append(data, *i.Data)
		}
	}

	return
}

// Hydrate fills this lookup values with the corresponding rows from the map[RowID]AllEmployees
func (l *AllEmployeesLookup) Hydrate(mapOf map[RowID]*AllEmployees) {
	for vi, v := range l.Values {
		if v.Data != nil {
			continue
		}
		if data, ok := mapOf[RowID(v.RowID)]; ok {
			l.Values[vi].Data = data
		}
	}
}

type AllEmployeesRowRef struct {
	Name  string
	RowID string
	Data  *AllEmployees
}

func ToAllEmployeesLookup(colID string, row Valuer) (values AllEmployeesLookup, err error) {
	rawv, ok := row.GetValue(colID)
	if !ok {
		return AllEmployeesLookup{}, fmt.Errorf("missing column %v in All employees row", colID)
	}

	if strv, ok := rawv.(string); ok && strv == "" {
		return AllEmployeesLookup{}, nil
	}

	if slicev, ok := rawv.([]interface{}); ok {
		for i, interv := range slicev {
			sv, err := toStructuredValue(interv)
			if err != nil {
				return AllEmployeesLookup{}, fmt.Errorf("slice value #%v: %w", i, err)
			}
			values.Values = append(values.Values, AllEmployeesRowRef{
				Name:  sv.Name,
				RowID: sv.RowId,
			})
		}

		return
	}

	sv, err := toStructuredValue(rawv)
	if err != nil {
		return AllEmployeesLookup{}, err
	}

	values.Values = []AllEmployeesRowRef{
		{
			Name:  sv.Name,
			RowID: sv.RowId,
		},
	}

	return
}

type EntryTypeLookup struct {
	Values []EntryTypeRowRef
}

// FirstRef returns a first referenced row metadata
func (l EntryTypeLookup) FirstRef() (first EntryTypeRowRef, found bool) {
	if len(l.Values) > 0 {
		return l.Values[0], true
	}

	return EntryTypeRowRef{}, false
}

// FirstRefName returns a first referenced row's Display Column value
func (l EntryTypeLookup) FirstRefName() string {
	if len(l.Values) > 0 {
		return l.Values[0].Name
	}

	return ""
}

// RefNames returns a slice of referenced rows' Display Columns values
func (l EntryTypeLookup) RefNames() (names []string) {
	for _, v := range l.Values {
		names = append(names, v.Name)
	}

	return
}

// String returns a comma-separated Display Columns of referenced rows.
// This representation is similar to what is shown in the browser.
func (l EntryTypeLookup) String() string {
	return strings.Join(l.RefNames(), ", ")
}

// First returns a pointer to a EntryType struct containing data of the first referenced row.
// It will return nil unless the lookup contains references and container of this EntryTypeLookup was preloaded by the LoadRelations<Original Table> method
func (l EntryTypeLookup) First() *EntryType {
	if len(l.Values) > 0 {
		return l.Values[0].Data
	}

	return nil
}

// FirstMaybe returns a EntryType struct containing data of the first referenced row.
// If the lookup doesn't contain any references or if reference data was not preloaded by the LoadRelations<Original Table> method it will return an empty structure with nil-values of it's fields
func (l EntryTypeLookup) FirstMaybe() EntryType {
	if len(l.Values) > 0 {
		return *l.Values[0].Data
	}

	return EntryType{}
}

// MustFirst returns a EntryType struct containing data of the first referenced row.
// It will panic if the lookup doesn't contain any references or if reference data was not preloaded by the LoadRelations<Original Table> method
func (l EntryTypeLookup) MustFirst() EntryType {
	if len(l.Values) > 0 && l.Values[0].Data != nil {
		return *l.Values[0].Data
	}

	panic("required EntryType value is not present in data row of EntryTypeLookup, table [Entry Type]")
}

// All returns all loaded data of the referenced rows if any
func (l EntryTypeLookup) All() (data []EntryType) {
	for _, i := range l.Values {
		if i.Data != nil {
			data = append(data, *i.Data)
		}
	}

	return
}

// Hydrate fills this lookup values with the corresponding rows from the map[RowID]EntryType
func (l *EntryTypeLookup) Hydrate(mapOf map[RowID]*EntryType) {
	for vi, v := range l.Values {
		if v.Data != nil {
			continue
		}
		if data, ok := mapOf[RowID(v.RowID)]; ok {
			l.Values[vi].Data = data
		}
	}
}

type EntryTypeRowRef struct {
	Name  string
	RowID string
	Data  *EntryType
}

func ToEntryTypeLookup(colID string, row Valuer) (values EntryTypeLookup, err error) {
	rawv, ok := row.GetValue(colID)
	if !ok {
		return EntryTypeLookup{}, fmt.Errorf("missing column %v in Entry Type row", colID)
	}

	if strv, ok := rawv.(string); ok && strv == "" {
		return EntryTypeLookup{}, nil
	}

	if slicev, ok := rawv.([]interface{}); ok {
		for i, interv := range slicev {
			sv, err := toStructuredValue(interv)
			if err != nil {
				return EntryTypeLookup{}, fmt.Errorf("slice value #%v: %w", i, err)
			}
			values.Values = append(values.Values, EntryTypeRowRef{
				Name:  sv.Name,
				RowID: sv.RowId,
			})
		}

		return
	}

	sv, err := toStructuredValue(rawv)
	if err != nil {
		return EntryTypeLookup{}, err
	}

	values.Values = []EntryTypeRowRef{
		{
			Name:  sv.Name,
			RowID: sv.RowId,
		},
	}

	return
}

type FullPayrollReportLookup struct {
	Values []FullPayrollReportRowRef
}

// FirstRef returns a first referenced row metadata
func (l FullPayrollReportLookup) FirstRef() (first FullPayrollReportRowRef, found bool) {
	if len(l.Values) > 0 {
		return l.Values[0], true
	}

	return FullPayrollReportRowRef{}, false
}

// FirstRefName returns a first referenced row's Display Column value
func (l FullPayrollReportLookup) FirstRefName() string {
	if len(l.Values) > 0 {
		return l.Values[0].Name
	}

	return ""
}

// RefNames returns a slice of referenced rows' Display Columns values
func (l FullPayrollReportLookup) RefNames() (names []string) {
	for _, v := range l.Values {
		names = append(names, v.Name)
	}

	return
}

// String returns a comma-separated Display Columns of referenced rows.
// This representation is similar to what is shown in the browser.
func (l FullPayrollReportLookup) String() string {
	return strings.Join(l.RefNames(), ", ")
}

// First returns a pointer to a FullPayrollReport struct containing data of the first referenced row.
// It will return nil unless the lookup contains references and container of this FullPayrollReportLookup was preloaded by the LoadRelations<Original Table> method
func (l FullPayrollReportLookup) First() *FullPayrollReport {
	if len(l.Values) > 0 {
		return l.Values[0].Data
	}

	return nil
}

// FirstMaybe returns a FullPayrollReport struct containing data of the first referenced row.
// If the lookup doesn't contain any references or if reference data was not preloaded by the LoadRelations<Original Table> method it will return an empty structure with nil-values of it's fields
func (l FullPayrollReportLookup) FirstMaybe() FullPayrollReport {
	if len(l.Values) > 0 {
		return *l.Values[0].Data
	}

	return FullPayrollReport{}
}

// MustFirst returns a FullPayrollReport struct containing data of the first referenced row.
// It will panic if the lookup doesn't contain any references or if reference data was not preloaded by the LoadRelations<Original Table> method
func (l FullPayrollReportLookup) MustFirst() FullPayrollReport {
	if len(l.Values) > 0 && l.Values[0].Data != nil {
		return *l.Values[0].Data
	}

	panic("required FullPayrollReport value is not present in data row of FullPayrollReportLookup, table [Full payroll report]")
}

// All returns all loaded data of the referenced rows if any
func (l FullPayrollReportLookup) All() (data []FullPayrollReport) {
	for _, i := range l.Values {
		if i.Data != nil {
			data = append(data, *i.Data)
		}
	}

	return
}

// Hydrate fills this lookup values with the corresponding rows from the map[RowID]FullPayrollReport
func (l *FullPayrollReportLookup) Hydrate(mapOf map[RowID]*FullPayrollReport) {
	for vi, v := range l.Values {
		if v.Data != nil {
			continue
		}
		if data, ok := mapOf[RowID(v.RowID)]; ok {
			l.Values[vi].Data = data
		}
	}
}

type FullPayrollReportRowRef struct {
	Name  string
	RowID string
	Data  *FullPayrollReport
}

func ToFullPayrollReportLookup(colID string, row Valuer) (values FullPayrollReportLookup, err error) {
	rawv, ok := row.GetValue(colID)
	if !ok {
		return FullPayrollReportLookup{}, fmt.Errorf("missing column %v in Full payroll report row", colID)
	}

	if strv, ok := rawv.(string); ok && strv == "" {
		return FullPayrollReportLookup{}, nil
	}

	if slicev, ok := rawv.([]interface{}); ok {
		for i, interv := range slicev {
			sv, err := toStructuredValue(interv)
			if err != nil {
				return FullPayrollReportLookup{}, fmt.Errorf("slice value #%v: %w", i, err)
			}
			values.Values = append(values.Values, FullPayrollReportRowRef{
				Name:  sv.Name,
				RowID: sv.RowId,
			})
		}

		return
	}

	sv, err := toStructuredValue(rawv)
	if err != nil {
		return FullPayrollReportLookup{}, err
	}

	values.Values = []FullPayrollReportRowRef{
		{
			Name:  sv.Name,
			RowID: sv.RowId,
		},
	}

	return
}

type TaxYearsLookup struct {
	Values []TaxYearsRowRef
}

// FirstRef returns a first referenced row metadata
func (l TaxYearsLookup) FirstRef() (first TaxYearsRowRef, found bool) {
	if len(l.Values) > 0 {
		return l.Values[0], true
	}

	return TaxYearsRowRef{}, false
}

// FirstRefName returns a first referenced row's Display Column value
func (l TaxYearsLookup) FirstRefName() string {
	if len(l.Values) > 0 {
		return l.Values[0].Name
	}

	return ""
}

// RefNames returns a slice of referenced rows' Display Columns values
func (l TaxYearsLookup) RefNames() (names []string) {
	for _, v := range l.Values {
		names = append(names, v.Name)
	}

	return
}

// String returns a comma-separated Display Columns of referenced rows.
// This representation is similar to what is shown in the browser.
func (l TaxYearsLookup) String() string {
	return strings.Join(l.RefNames(), ", ")
}

// First returns a pointer to a TaxYears struct containing data of the first referenced row.
// It will return nil unless the lookup contains references and container of this TaxYearsLookup was preloaded by the LoadRelations<Original Table> method
func (l TaxYearsLookup) First() *TaxYears {
	if len(l.Values) > 0 {
		return l.Values[0].Data
	}

	return nil
}

// FirstMaybe returns a TaxYears struct containing data of the first referenced row.
// If the lookup doesn't contain any references or if reference data was not preloaded by the LoadRelations<Original Table> method it will return an empty structure with nil-values of it's fields
func (l TaxYearsLookup) FirstMaybe() TaxYears {
	if len(l.Values) > 0 {
		return *l.Values[0].Data
	}

	return TaxYears{}
}

// MustFirst returns a TaxYears struct containing data of the first referenced row.
// It will panic if the lookup doesn't contain any references or if reference data was not preloaded by the LoadRelations<Original Table> method
func (l TaxYearsLookup) MustFirst() TaxYears {
	if len(l.Values) > 0 && l.Values[0].Data != nil {
		return *l.Values[0].Data
	}

	panic("required TaxYears value is not present in data row of TaxYearsLookup, table [Tax years]")
}

// All returns all loaded data of the referenced rows if any
func (l TaxYearsLookup) All() (data []TaxYears) {
	for _, i := range l.Values {
		if i.Data != nil {
			data = append(data, *i.Data)
		}
	}

	return
}

// Hydrate fills this lookup values with the corresponding rows from the map[RowID]TaxYears
func (l *TaxYearsLookup) Hydrate(mapOf map[RowID]*TaxYears) {
	for vi, v := range l.Values {
		if v.Data != nil {
			continue
		}
		if data, ok := mapOf[RowID(v.RowID)]; ok {
			l.Values[vi].Data = data
		}
	}
}

type TaxYearsRowRef struct {
	Name  string
	RowID string
	Data  *TaxYears
}

func ToTaxYearsLookup(colID string, row Valuer) (values TaxYearsLookup, err error) {
	rawv, ok := row.GetValue(colID)
	if !ok {
		return TaxYearsLookup{}, fmt.Errorf("missing column %v in Tax years row", colID)
	}

	if strv, ok := rawv.(string); ok && strv == "" {
		return TaxYearsLookup{}, nil
	}

	if slicev, ok := rawv.([]interface{}); ok {
		for i, interv := range slicev {
			sv, err := toStructuredValue(interv)
			if err != nil {
				return TaxYearsLookup{}, fmt.Errorf("slice value #%v: %w", i, err)
			}
			values.Values = append(values.Values, TaxYearsRowRef{
				Name:  sv.Name,
				RowID: sv.RowId,
			})
		}

		return
	}

	sv, err := toStructuredValue(rawv)
	if err != nil {
		return TaxYearsLookup{}, err
	}

	values.Values = []TaxYearsRowRef{
		{
			Name:  sv.Name,
			RowID: sv.RowId,
		},
	}

	return
}

type BankTariffsLookup struct {
	Values []BankTariffsRowRef
}

// FirstRef returns a first referenced row metadata
func (l BankTariffsLookup) FirstRef() (first BankTariffsRowRef, found bool) {
	if len(l.Values) > 0 {
		return l.Values[0], true
	}

	return BankTariffsRowRef{}, false
}

// FirstRefName returns a first referenced row's Display Column value
func (l BankTariffsLookup) FirstRefName() string {
	if len(l.Values) > 0 {
		return l.Values[0].Name
	}

	return ""
}

// RefNames returns a slice of referenced rows' Display Columns values
func (l BankTariffsLookup) RefNames() (names []string) {
	for _, v := range l.Values {
		names = append(names, v.Name)
	}

	return
}

// String returns a comma-separated Display Columns of referenced rows.
// This representation is similar to what is shown in the browser.
func (l BankTariffsLookup) String() string {
	return strings.Join(l.RefNames(), ", ")
}

// First returns a pointer to a BankTariffs struct containing data of the first referenced row.
// It will return nil unless the lookup contains references and container of this BankTariffsLookup was preloaded by the LoadRelations<Original Table> method
func (l BankTariffsLookup) First() *BankTariffs {
	if len(l.Values) > 0 {
		return l.Values[0].Data
	}

	return nil
}

// FirstMaybe returns a BankTariffs struct containing data of the first referenced row.
// If the lookup doesn't contain any references or if reference data was not preloaded by the LoadRelations<Original Table> method it will return an empty structure with nil-values of it's fields
func (l BankTariffsLookup) FirstMaybe() BankTariffs {
	if len(l.Values) > 0 {
		return *l.Values[0].Data
	}

	return BankTariffs{}
}

// MustFirst returns a BankTariffs struct containing data of the first referenced row.
// It will panic if the lookup doesn't contain any references or if reference data was not preloaded by the LoadRelations<Original Table> method
func (l BankTariffsLookup) MustFirst() BankTariffs {
	if len(l.Values) > 0 && l.Values[0].Data != nil {
		return *l.Values[0].Data
	}

	panic("required BankTariffs value is not present in data row of BankTariffsLookup, table [Bank tariffs]")
}

// All returns all loaded data of the referenced rows if any
func (l BankTariffsLookup) All() (data []BankTariffs) {
	for _, i := range l.Values {
		if i.Data != nil {
			data = append(data, *i.Data)
		}
	}

	return
}

// Hydrate fills this lookup values with the corresponding rows from the map[RowID]BankTariffs
func (l *BankTariffsLookup) Hydrate(mapOf map[RowID]*BankTariffs) {
	for vi, v := range l.Values {
		if v.Data != nil {
			continue
		}
		if data, ok := mapOf[RowID(v.RowID)]; ok {
			l.Values[vi].Data = data
		}
	}
}

type BankTariffsRowRef struct {
	Name  string
	RowID string
	Data  *BankTariffs
}

func ToBankTariffsLookup(colID string, row Valuer) (values BankTariffsLookup, err error) {
	rawv, ok := row.GetValue(colID)
	if !ok {
		return BankTariffsLookup{}, fmt.Errorf("missing column %v in Bank tariffs row", colID)
	}

	if strv, ok := rawv.(string); ok && strv == "" {
		return BankTariffsLookup{}, nil
	}

	if slicev, ok := rawv.([]interface{}); ok {
		for i, interv := range slicev {
			sv, err := toStructuredValue(interv)
			if err != nil {
				return BankTariffsLookup{}, fmt.Errorf("slice value #%v: %w", i, err)
			}
			values.Values = append(values.Values, BankTariffsRowRef{
				Name:  sv.Name,
				RowID: sv.RowId,
			})
		}

		return
	}

	sv, err := toStructuredValue(rawv)
	if err != nil {
		return BankTariffsLookup{}, err
	}

	values.Values = []BankTariffsRowRef{
		{
			Name:  sv.Name,
			RowID: sv.RowId,
		},
	}

	return
}

type InvoiceLookup struct {
	Values []InvoiceRowRef
}

// FirstRef returns a first referenced row metadata
func (l InvoiceLookup) FirstRef() (first InvoiceRowRef, found bool) {
	if len(l.Values) > 0 {
		return l.Values[0], true
	}

	return InvoiceRowRef{}, false
}

// FirstRefName returns a first referenced row's Display Column value
func (l InvoiceLookup) FirstRefName() string {
	if len(l.Values) > 0 {
		return l.Values[0].Name
	}

	return ""
}

// RefNames returns a slice of referenced rows' Display Columns values
func (l InvoiceLookup) RefNames() (names []string) {
	for _, v := range l.Values {
		names = append(names, v.Name)
	}

	return
}

// String returns a comma-separated Display Columns of referenced rows.
// This representation is similar to what is shown in the browser.
func (l InvoiceLookup) String() string {
	return strings.Join(l.RefNames(), ", ")
}

// First returns a pointer to a Invoice struct containing data of the first referenced row.
// It will return nil unless the lookup contains references and container of this InvoiceLookup was preloaded by the LoadRelations<Original Table> method
func (l InvoiceLookup) First() *Invoice {
	if len(l.Values) > 0 {
		return l.Values[0].Data
	}

	return nil
}

// FirstMaybe returns a Invoice struct containing data of the first referenced row.
// If the lookup doesn't contain any references or if reference data was not preloaded by the LoadRelations<Original Table> method it will return an empty structure with nil-values of it's fields
func (l InvoiceLookup) FirstMaybe() Invoice {
	if len(l.Values) > 0 {
		return *l.Values[0].Data
	}

	return Invoice{}
}

// MustFirst returns a Invoice struct containing data of the first referenced row.
// It will panic if the lookup doesn't contain any references or if reference data was not preloaded by the LoadRelations<Original Table> method
func (l InvoiceLookup) MustFirst() Invoice {
	if len(l.Values) > 0 && l.Values[0].Data != nil {
		return *l.Values[0].Data
	}

	panic("required Invoice value is not present in data row of InvoiceLookup, table [Invoice]")
}

// All returns all loaded data of the referenced rows if any
func (l InvoiceLookup) All() (data []Invoice) {
	for _, i := range l.Values {
		if i.Data != nil {
			data = append(data, *i.Data)
		}
	}

	return
}

// Hydrate fills this lookup values with the corresponding rows from the map[RowID]Invoice
func (l *InvoiceLookup) Hydrate(mapOf map[RowID]*Invoice) {
	for vi, v := range l.Values {
		if v.Data != nil {
			continue
		}
		if data, ok := mapOf[RowID(v.RowID)]; ok {
			l.Values[vi].Data = data
		}
	}
}

type InvoiceRowRef struct {
	Name  string
	RowID string
	Data  *Invoice
}

func ToInvoiceLookup(colID string, row Valuer) (values InvoiceLookup, err error) {
	rawv, ok := row.GetValue(colID)
	if !ok {
		return InvoiceLookup{}, fmt.Errorf("missing column %v in Invoice row", colID)
	}

	if strv, ok := rawv.(string); ok && strv == "" {
		return InvoiceLookup{}, nil
	}

	if slicev, ok := rawv.([]interface{}); ok {
		for i, interv := range slicev {
			sv, err := toStructuredValue(interv)
			if err != nil {
				return InvoiceLookup{}, fmt.Errorf("slice value #%v: %w", i, err)
			}
			values.Values = append(values.Values, InvoiceRowRef{
				Name:  sv.Name,
				RowID: sv.RowId,
			})
		}

		return
	}

	sv, err := toStructuredValue(rawv)
	if err != nil {
		return InvoiceLookup{}, err
	}

	values.Values = []InvoiceRowRef{
		{
			Name:  sv.Name,
			RowID: sv.RowId,
		},
	}

	return
}

type EmployeePatentsLookup struct {
	Values []EmployeePatentsRowRef
}

// FirstRef returns a first referenced row metadata
func (l EmployeePatentsLookup) FirstRef() (first EmployeePatentsRowRef, found bool) {
	if len(l.Values) > 0 {
		return l.Values[0], true
	}

	return EmployeePatentsRowRef{}, false
}

// FirstRefName returns a first referenced row's Display Column value
func (l EmployeePatentsLookup) FirstRefName() string {
	if len(l.Values) > 0 {
		return l.Values[0].Name
	}

	return ""
}

// RefNames returns a slice of referenced rows' Display Columns values
func (l EmployeePatentsLookup) RefNames() (names []string) {
	for _, v := range l.Values {
		names = append(names, v.Name)
	}

	return
}

// String returns a comma-separated Display Columns of referenced rows.
// This representation is similar to what is shown in the browser.
func (l EmployeePatentsLookup) String() string {
	return strings.Join(l.RefNames(), ", ")
}

// First returns a pointer to a EmployeePatents struct containing data of the first referenced row.
// It will return nil unless the lookup contains references and container of this EmployeePatentsLookup was preloaded by the LoadRelations<Original Table> method
func (l EmployeePatentsLookup) First() *EmployeePatents {
	if len(l.Values) > 0 {
		return l.Values[0].Data
	}

	return nil
}

// FirstMaybe returns a EmployeePatents struct containing data of the first referenced row.
// If the lookup doesn't contain any references or if reference data was not preloaded by the LoadRelations<Original Table> method it will return an empty structure with nil-values of it's fields
func (l EmployeePatentsLookup) FirstMaybe() EmployeePatents {
	if len(l.Values) > 0 {
		return *l.Values[0].Data
	}

	return EmployeePatents{}
}

// MustFirst returns a EmployeePatents struct containing data of the first referenced row.
// It will panic if the lookup doesn't contain any references or if reference data was not preloaded by the LoadRelations<Original Table> method
func (l EmployeePatentsLookup) MustFirst() EmployeePatents {
	if len(l.Values) > 0 && l.Values[0].Data != nil {
		return *l.Values[0].Data
	}

	panic("required EmployeePatents value is not present in data row of EmployeePatentsLookup, table [Employee Patents]")
}

// All returns all loaded data of the referenced rows if any
func (l EmployeePatentsLookup) All() (data []EmployeePatents) {
	for _, i := range l.Values {
		if i.Data != nil {
			data = append(data, *i.Data)
		}
	}

	return
}

// Hydrate fills this lookup values with the corresponding rows from the map[RowID]EmployeePatents
func (l *EmployeePatentsLookup) Hydrate(mapOf map[RowID]*EmployeePatents) {
	for vi, v := range l.Values {
		if v.Data != nil {
			continue
		}
		if data, ok := mapOf[RowID(v.RowID)]; ok {
			l.Values[vi].Data = data
		}
	}
}

type EmployeePatentsRowRef struct {
	Name  string
	RowID string
	Data  *EmployeePatents
}

func ToEmployeePatentsLookup(colID string, row Valuer) (values EmployeePatentsLookup, err error) {
	rawv, ok := row.GetValue(colID)
	if !ok {
		return EmployeePatentsLookup{}, fmt.Errorf("missing column %v in Employee Patents row", colID)
	}

	if strv, ok := rawv.(string); ok && strv == "" {
		return EmployeePatentsLookup{}, nil
	}

	if slicev, ok := rawv.([]interface{}); ok {
		for i, interv := range slicev {
			sv, err := toStructuredValue(interv)
			if err != nil {
				return EmployeePatentsLookup{}, fmt.Errorf("slice value #%v: %w", i, err)
			}
			values.Values = append(values.Values, EmployeePatentsRowRef{
				Name:  sv.Name,
				RowID: sv.RowId,
			})
		}

		return
	}

	sv, err := toStructuredValue(rawv)
	if err != nil {
		return EmployeePatentsLookup{}, err
	}

	values.Values = []EmployeePatentsRowRef{
		{
			Name:  sv.Name,
			RowID: sv.RowId,
		},
	}

	return
}

type PerDayPoliciesLookup struct {
	Values []PerDayPoliciesRowRef
}

// FirstRef returns a first referenced row metadata
func (l PerDayPoliciesLookup) FirstRef() (first PerDayPoliciesRowRef, found bool) {
	if len(l.Values) > 0 {
		return l.Values[0], true
	}

	return PerDayPoliciesRowRef{}, false
}

// FirstRefName returns a first referenced row's Display Column value
func (l PerDayPoliciesLookup) FirstRefName() string {
	if len(l.Values) > 0 {
		return l.Values[0].Name
	}

	return ""
}

// RefNames returns a slice of referenced rows' Display Columns values
func (l PerDayPoliciesLookup) RefNames() (names []string) {
	for _, v := range l.Values {
		names = append(names, v.Name)
	}

	return
}

// String returns a comma-separated Display Columns of referenced rows.
// This representation is similar to what is shown in the browser.
func (l PerDayPoliciesLookup) String() string {
	return strings.Join(l.RefNames(), ", ")
}

// First returns a pointer to a PerDayPolicies struct containing data of the first referenced row.
// It will return nil unless the lookup contains references and container of this PerDayPoliciesLookup was preloaded by the LoadRelations<Original Table> method
func (l PerDayPoliciesLookup) First() *PerDayPolicies {
	if len(l.Values) > 0 {
		return l.Values[0].Data
	}

	return nil
}

// FirstMaybe returns a PerDayPolicies struct containing data of the first referenced row.
// If the lookup doesn't contain any references or if reference data was not preloaded by the LoadRelations<Original Table> method it will return an empty structure with nil-values of it's fields
func (l PerDayPoliciesLookup) FirstMaybe() PerDayPolicies {
	if len(l.Values) > 0 {
		return *l.Values[0].Data
	}

	return PerDayPolicies{}
}

// MustFirst returns a PerDayPolicies struct containing data of the first referenced row.
// It will panic if the lookup doesn't contain any references or if reference data was not preloaded by the LoadRelations<Original Table> method
func (l PerDayPoliciesLookup) MustFirst() PerDayPolicies {
	if len(l.Values) > 0 && l.Values[0].Data != nil {
		return *l.Values[0].Data
	}

	panic("required PerDayPolicies value is not present in data row of PerDayPoliciesLookup, table [Per Day Policies]")
}

// All returns all loaded data of the referenced rows if any
func (l PerDayPoliciesLookup) All() (data []PerDayPolicies) {
	for _, i := range l.Values {
		if i.Data != nil {
			data = append(data, *i.Data)
		}
	}

	return
}

// Hydrate fills this lookup values with the corresponding rows from the map[RowID]PerDayPolicies
func (l *PerDayPoliciesLookup) Hydrate(mapOf map[RowID]*PerDayPolicies) {
	for vi, v := range l.Values {
		if v.Data != nil {
			continue
		}
		if data, ok := mapOf[RowID(v.RowID)]; ok {
			l.Values[vi].Data = data
		}
	}
}

type PerDayPoliciesRowRef struct {
	Name  string
	RowID string
	Data  *PerDayPolicies
}

func ToPerDayPoliciesLookup(colID string, row Valuer) (values PerDayPoliciesLookup, err error) {
	rawv, ok := row.GetValue(colID)
	if !ok {
		return PerDayPoliciesLookup{}, fmt.Errorf("missing column %v in Per Day Policies row", colID)
	}

	if strv, ok := rawv.(string); ok && strv == "" {
		return PerDayPoliciesLookup{}, nil
	}

	if slicev, ok := rawv.([]interface{}); ok {
		for i, interv := range slicev {
			sv, err := toStructuredValue(interv)
			if err != nil {
				return PerDayPoliciesLookup{}, fmt.Errorf("slice value #%v: %w", i, err)
			}
			values.Values = append(values.Values, PerDayPoliciesRowRef{
				Name:  sv.Name,
				RowID: sv.RowId,
			})
		}

		return
	}

	sv, err := toStructuredValue(rawv)
	if err != nil {
		return PerDayPoliciesLookup{}, err
	}

	values.Values = []PerDayPoliciesRowRef{
		{
			Name:  sv.Name,
			RowID: sv.RowId,
		},
	}

	return
}

//endregion

//region Document

var tokenMiddleware = func(token string) codaapi.RequestEditorFn {
	return func(ctx context.Context, req *http.Request) error {
		req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", token))
		return nil
	}
}

func NewDefaultClient(server, token string, clientOpts ...codaapi.ClientOption) (codaapi.ClientWithResponsesInterface, error) {
	clientOpts = append(clientOpts, codaapi.WithRequestEditorFn(tokenMiddleware(token)))

	return codaapi.NewClientWithResponses(server, clientOpts...)
}

func NewCodaDocument(server, token, docID string, clientOpts ...codaapi.ClientOption) (*CodaDocument, error) {
	client, err := NewDefaultClient(server, token, clientOpts...)
	if err != nil {
		return nil, err
	}

	return &CodaDocument{
		docID:          docID,
		client:         client,
		relationsCache: &sync.Map{},
	}, nil
}

type CodaDocument struct {
	docID          string
	client         codaapi.ClientWithResponsesInterface
	relationsCache *sync.Map // Used for deep loading to share loaded sub-entities
}

func (d *CodaDocument) ListAllRows(ctx context.Context, tableID string, extraParams ...codaapi.ListRowsParam) (list []codaapi.Row, err error) {
	valueFormat := codaapi.ValueFormatRich
	var pageToken codaapi.PageToken

	params := codaapi.ListRowsParams{}
	for _, p := range extraParams {
		p(&params)
	}
	params.ValueFormat = &valueFormat
	params.PageToken = &pageToken

	for {
		resp, err := d.client.ListRowsWithResponse(
			ctx,
			codaapi.DocId(d.docID),
			codaapi.TableIdOrName(tableID),
			&params,
		)
		if err != nil {
			return nil, err
		}

		if resp.StatusCode() != 200 || resp.JSON200 == nil {
			return nil, fmt.Errorf("response status %v, body: %s", resp.StatusCode(), resp.Body)
		}

		for _, row := range resp.JSON200.Items {
			list = append(list, row)
		}

		if resp.JSON200.NextPageToken == nil {
			return list, nil
		}

		pageToken = codaapi.PageToken(*resp.JSON200.NextPageToken)
	}
}

//endregion

//region Methods for shallow data fetching (without loading relations)

type RowID string

func (d *CodaDocument) ListAllEmployees(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []AllEmployees, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.AllEmployees.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewAllEmployees(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create AllEmployees from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfAllEmployees(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*AllEmployees, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.AllEmployees.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*AllEmployees, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewAllEmployees(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create AllEmployees from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListInvoice(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []Invoice, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.Invoice.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewInvoice(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create Invoice from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfInvoice(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*Invoice, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.Invoice.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*Invoice, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewInvoice(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create Invoice from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListMonths(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []Months, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.Months.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewMonths(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create Months from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfMonths(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*Months, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.Months.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*Months, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewMonths(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create Months from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListEntries(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []Entries, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.Entries.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewEntries(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create Entries from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfEntries(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*Entries, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.Entries.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*Entries, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewEntries(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create Entries from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListWorkingEmployees(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []WorkingEmployees, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.WorkingEmployees.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewWorkingEmployees(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create WorkingEmployees from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfWorkingEmployees(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*WorkingEmployees, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.WorkingEmployees.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*WorkingEmployees, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewWorkingEmployees(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create WorkingEmployees from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListWorkingEmployeesNames(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []WorkingEmployeesNames, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.WorkingEmployeesNames.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewWorkingEmployeesNames(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create WorkingEmployeesNames from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfWorkingEmployeesNames(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*WorkingEmployeesNames, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.WorkingEmployeesNames.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*WorkingEmployeesNames, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewWorkingEmployeesNames(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create WorkingEmployeesNames from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListInvoicesOverview(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []InvoicesOverview, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.InvoicesOverview.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewInvoicesOverview(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create InvoicesOverview from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfInvoicesOverview(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*InvoicesOverview, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.InvoicesOverview.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*InvoicesOverview, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewInvoicesOverview(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create InvoicesOverview from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListPatentCompensation(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []PatentCompensation, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.PatentCompensation.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewPatentCompensation(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create PatentCompensation from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfPatentCompensation(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*PatentCompensation, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.PatentCompensation.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*PatentCompensation, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewPatentCompensation(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create PatentCompensation from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListEntryType(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []EntryType, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.EntryType.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewEntryType(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create EntryType from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfEntryType(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*EntryType, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.EntryType.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*EntryType, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewEntryType(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create EntryType from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListPatentsOverview(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []PatentsOverview, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.PatentsOverview.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewPatentsOverview(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create PatentsOverview from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfPatentsOverview(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*PatentsOverview, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.PatentsOverview.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*PatentsOverview, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewPatentsOverview(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create PatentsOverview from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListLegalEntity(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []LegalEntity, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.LegalEntity.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewLegalEntity(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create LegalEntity from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfLegalEntity(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*LegalEntity, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.LegalEntity.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*LegalEntity, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewLegalEntity(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create LegalEntity from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListSalariesReport(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []SalariesReport, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.SalariesReport.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewSalariesReport(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create SalariesReport from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfSalariesReport(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*SalariesReport, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.SalariesReport.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*SalariesReport, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewSalariesReport(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create SalariesReport from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListTaxYears(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []TaxYears, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.TaxYears.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewTaxYears(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create TaxYears from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfTaxYears(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*TaxYears, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.TaxYears.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*TaxYears, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewTaxYears(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create TaxYears from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListEmployeePatents(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []EmployeePatents, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.EmployeePatents.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewEmployeePatents(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create EmployeePatents from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfEmployeePatents(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*EmployeePatents, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.EmployeePatents.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*EmployeePatents, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewEmployeePatents(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create EmployeePatents from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListFullPayrollReport(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []FullPayrollReport, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.FullPayrollReport.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewFullPayrollReport(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create FullPayrollReport from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfFullPayrollReport(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*FullPayrollReport, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.FullPayrollReport.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*FullPayrollReport, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewFullPayrollReport(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create FullPayrollReport from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListEmptyActualRates(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []EmptyActualRates, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.EmptyActualRates.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewEmptyActualRates(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create EmptyActualRates from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfEmptyActualRates(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*EmptyActualRates, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.EmptyActualRates.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*EmptyActualRates, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewEmptyActualRates(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create EmptyActualRates from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListCorrectionsByType(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []CorrectionsByType, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.CorrectionsByType.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewCorrectionsByType(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create CorrectionsByType from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfCorrectionsByType(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*CorrectionsByType, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.CorrectionsByType.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*CorrectionsByType, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewCorrectionsByType(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create CorrectionsByType from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListPayrollReportToAdd(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []PayrollReportToAdd, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.PayrollReportToAdd.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewPayrollReportToAdd(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create PayrollReportToAdd from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfPayrollReportToAdd(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*PayrollReportToAdd, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.PayrollReportToAdd.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*PayrollReportToAdd, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewPayrollReportToAdd(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create PayrollReportToAdd from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListBankTariffs(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []BankTariffs, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.BankTariffs.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewBankTariffs(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create BankTariffs from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfBankTariffs(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*BankTariffs, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.BankTariffs.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*BankTariffs, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewBankTariffs(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create BankTariffs from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListPHCorrections(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []PHCorrections, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.PHCorrections.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewPHCorrections(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create PHCorrections from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfPHCorrections(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*PHCorrections, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.PHCorrections.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*PHCorrections, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewPHCorrections(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create PHCorrections from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListPHMonthlyReport(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []PHMonthlyReport, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.PHMonthlyReport.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewPHMonthlyReport(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create PHMonthlyReport from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfPHMonthlyReport(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*PHMonthlyReport, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.PHMonthlyReport.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*PHMonthlyReport, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewPHMonthlyReport(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create PHMonthlyReport from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListLocation(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []Location, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.Location.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewLocation(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create Location from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfLocation(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*Location, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.Location.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*Location, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewLocation(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create Location from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListCompanyRates(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []CompanyRates, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.CompanyRates.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewCompanyRates(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create CompanyRates from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfCompanyRates(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*CompanyRates, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.CompanyRates.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*CompanyRates, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewCompanyRates(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create CompanyRates from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListSummaryForCurrentPeriod3(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []SummaryForCurrentPeriod3, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.SummaryForCurrentPeriod3.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewSummaryForCurrentPeriod3(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create SummaryForCurrentPeriod3 from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfSummaryForCurrentPeriod3(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*SummaryForCurrentPeriod3, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.SummaryForCurrentPeriod3.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*SummaryForCurrentPeriod3, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewSummaryForCurrentPeriod3(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create SummaryForCurrentPeriod3 from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListCurrentPayrollV2(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []CurrentPayrollV2, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.CurrentPayrollV2.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewCurrentPayrollV2(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create CurrentPayrollV2 from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfCurrentPayrollV2(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*CurrentPayrollV2, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.CurrentPayrollV2.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*CurrentPayrollV2, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewCurrentPayrollV2(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create CurrentPayrollV2 from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListHeadcountPerLocation(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []HeadcountPerLocation, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.HeadcountPerLocation.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewHeadcountPerLocation(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create HeadcountPerLocation from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfHeadcountPerLocation(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*HeadcountPerLocation, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.HeadcountPerLocation.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*HeadcountPerLocation, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewHeadcountPerLocation(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create HeadcountPerLocation from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListSuspiciousRates(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []SuspiciousRates, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.SuspiciousRates.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewSuspiciousRates(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create SuspiciousRates from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfSuspiciousRates(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*SuspiciousRates, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.SuspiciousRates.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*SuspiciousRates, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewSuspiciousRates(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create SuspiciousRates from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListWorkDays(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []WorkDays, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.WorkDays.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewWorkDays(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create WorkDays from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfWorkDays(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*WorkDays, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.WorkDays.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*WorkDays, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewWorkDays(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create WorkDays from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListCorrectionsByEmployee(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []CorrectionsByEmployee, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.CorrectionsByEmployee.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewCorrectionsByEmployee(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create CorrectionsByEmployee from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfCorrectionsByEmployee(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*CorrectionsByEmployee, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.CorrectionsByEmployee.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*CorrectionsByEmployee, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewCorrectionsByEmployee(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create CorrectionsByEmployee from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListEnterCompanyRatesForSelectedMonth(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []EnterCompanyRatesForSelectedMonth, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.EnterCompanyRatesForSelectedMonth.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewEnterCompanyRatesForSelectedMonth(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create EnterCompanyRatesForSelectedMonth from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfEnterCompanyRatesForSelectedMonth(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*EnterCompanyRatesForSelectedMonth, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.EnterCompanyRatesForSelectedMonth.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*EnterCompanyRatesForSelectedMonth, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewEnterCompanyRatesForSelectedMonth(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create EnterCompanyRatesForSelectedMonth from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListTemplateEntries(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []TemplateEntries, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.TemplateEntries.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewTemplateEntries(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create TemplateEntries from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfTemplateEntries(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*TemplateEntries, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.TemplateEntries.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*TemplateEntries, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewTemplateEntries(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create TemplateEntries from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListAllEmployeesNames(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []AllEmployeesNames, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.AllEmployeesNames.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewAllEmployeesNames(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create AllEmployeesNames from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfAllEmployeesNames(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*AllEmployeesNames, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.AllEmployeesNames.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*AllEmployeesNames, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewAllEmployeesNames(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create AllEmployeesNames from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListBankDetails(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []BankDetails, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.BankDetails.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewBankDetails(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create BankDetails from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfBankDetails(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*BankDetails, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.BankDetails.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*BankDetails, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewBankDetails(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create BankDetails from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListBeneficiaryBank(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []BeneficiaryBank, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.BeneficiaryBank.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewBeneficiaryBank(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create BeneficiaryBank from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfBeneficiaryBank(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*BeneficiaryBank, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.BeneficiaryBank.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*BeneficiaryBank, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewBeneficiaryBank(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create BeneficiaryBank from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListPayrollSchedule(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []PayrollSchedule, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.PayrollSchedule.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewPayrollSchedule(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create PayrollSchedule from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfPayrollSchedule(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*PayrollSchedule, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.PayrollSchedule.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*PayrollSchedule, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewPayrollSchedule(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create PayrollSchedule from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListPensionFundFixed(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []PensionFundFixed, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.PensionFundFixed.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewPensionFundFixed(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create PensionFundFixed from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfPensionFundFixed(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*PensionFundFixed, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.PensionFundFixed.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*PensionFundFixed, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewPensionFundFixed(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create PensionFundFixed from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListSocialInsurance(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []SocialInsurance, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.SocialInsurance.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewSocialInsurance(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create SocialInsurance from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfSocialInsurance(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*SocialInsurance, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.SocialInsurance.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*SocialInsurance, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewSocialInsurance(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create SocialInsurance from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListPensionFundPercent(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []PensionFundPercent, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.PensionFundPercent.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewPensionFundPercent(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create PensionFundPercent from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfPensionFundPercent(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*PensionFundPercent, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.PensionFundPercent.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*PensionFundPercent, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewPensionFundPercent(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create PensionFundPercent from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListPerDayCalculations(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []PerDayCalculations, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.PerDayCalculations.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewPerDayCalculations(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create PerDayCalculations from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfPerDayCalculations(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*PerDayCalculations, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.PerDayCalculations.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*PerDayCalculations, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewPerDayCalculations(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create PerDayCalculations from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListPerDayPolicies(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []PerDayPolicies, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.PerDayPolicies.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewPerDayPolicies(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create PerDayPolicies from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfPerDayPolicies(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*PerDayPolicies, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.PerDayPolicies.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*PerDayPolicies, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewPerDayPolicies(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create PerDayPolicies from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListSalaries(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []Salaries, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.Salaries.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewSalaries(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create Salaries from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfSalaries(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*Salaries, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.Salaries.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*Salaries, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewSalaries(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create Salaries from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListPayableEmployees(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []PayableEmployees, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.PayableEmployees.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewPayableEmployees(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create PayableEmployees from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfPayableEmployees(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*PayableEmployees, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.PayableEmployees.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*PayableEmployees, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewPayableEmployees(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create PayableEmployees from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListQuickManualEntry(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []QuickManualEntry, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.QuickManualEntry.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewQuickManualEntry(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create QuickManualEntry from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfQuickManualEntry(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*QuickManualEntry, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.QuickManualEntry.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*QuickManualEntry, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewQuickManualEntry(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create QuickManualEntry from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListNewInvoiceEntriesPerType(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []NewInvoiceEntriesPerType, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.NewInvoiceEntriesPerType.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewNewInvoiceEntriesPerType(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create NewInvoiceEntriesPerType from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfNewInvoiceEntriesPerType(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*NewInvoiceEntriesPerType, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.NewInvoiceEntriesPerType.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*NewInvoiceEntriesPerType, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewNewInvoiceEntriesPerType(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create NewInvoiceEntriesPerType from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListEntriesPerDateAndType(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []EntriesPerDateAndType, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.EntriesPerDateAndType.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewEntriesPerDateAndType(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create EntriesPerDateAndType from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfEntriesPerDateAndType(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*EntriesPerDateAndType, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.EntriesPerDateAndType.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*EntriesPerDateAndType, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewEntriesPerDateAndType(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create EntriesPerDateAndType from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListAddNewEmployee(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []AddNewEmployee, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.AddNewEmployee.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewAddNewEmployee(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create AddNewEmployee from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfAddNewEmployee(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*AddNewEmployee, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.AddNewEmployee.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*AddNewEmployee, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewAddNewEmployee(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create AddNewEmployee from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListCurrentTemplateEntries(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []CurrentTemplateEntries, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.CurrentTemplateEntries.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewCurrentTemplateEntries(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create CurrentTemplateEntries from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfCurrentTemplateEntries(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*CurrentTemplateEntries, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.CurrentTemplateEntries.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*CurrentTemplateEntries, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewCurrentTemplateEntries(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create CurrentTemplateEntries from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListTemplateEntriesMonthsFiltering(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []TemplateEntriesMonthsFiltering, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.TemplateEntriesMonthsFiltering.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewTemplateEntriesMonthsFiltering(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create TemplateEntriesMonthsFiltering from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfTemplateEntriesMonthsFiltering(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*TemplateEntriesMonthsFiltering, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.TemplateEntriesMonthsFiltering.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*TemplateEntriesMonthsFiltering, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewTemplateEntriesMonthsFiltering(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create TemplateEntriesMonthsFiltering from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListTemplateEntriesTypeFiltering(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []TemplateEntriesTypeFiltering, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.TemplateEntriesTypeFiltering.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewTemplateEntriesTypeFiltering(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create TemplateEntriesTypeFiltering from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfTemplateEntriesTypeFiltering(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*TemplateEntriesTypeFiltering, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.TemplateEntriesTypeFiltering.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*TemplateEntriesTypeFiltering, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewTemplateEntriesTypeFiltering(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create TemplateEntriesTypeFiltering from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListEntriesMonthsFiltering(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []EntriesMonthsFiltering, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.EntriesMonthsFiltering.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewEntriesMonthsFiltering(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create EntriesMonthsFiltering from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfEntriesMonthsFiltering(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*EntriesMonthsFiltering, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.EntriesMonthsFiltering.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*EntriesMonthsFiltering, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewEntriesMonthsFiltering(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create EntriesMonthsFiltering from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListEntriesTypeFiltering(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []EntriesTypeFiltering, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.EntriesTypeFiltering.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewEntriesTypeFiltering(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create EntriesTypeFiltering from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfEntriesTypeFiltering(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*EntriesTypeFiltering, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.EntriesTypeFiltering.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*EntriesTypeFiltering, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewEntriesTypeFiltering(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create EntriesTypeFiltering from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListFilteredEntries(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []FilteredEntries, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.FilteredEntries.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewFilteredEntries(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create FilteredEntries from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfFilteredEntries(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*FilteredEntries, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.FilteredEntries.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*FilteredEntries, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewFilteredEntries(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create FilteredEntries from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListAddCompanyRate(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []AddCompanyRate, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.AddCompanyRate.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewAddCompanyRate(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create AddCompanyRate from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfAddCompanyRate(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*AddCompanyRate, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.AddCompanyRate.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*AddCompanyRate, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewAddCompanyRate(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create AddCompanyRate from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

func (d *CodaDocument) ListTESTTABLE(ctx context.Context, extraParams ...codaapi.ListRowsParam) (list []TESTTABLE, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.TESTTABLE.ID, extraParams...)
	if err != nil {
		return
	}

	for idx, row := range rows {
		item, err := NewTESTTABLE(&row)
		if err != nil {
			return nil, fmt.Errorf("failed to create TESTTABLE from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		list = append(list, item)
	}

	return
}

func (d *CodaDocument) MapOfTESTTABLE(ctx context.Context, extraParams ...codaapi.ListRowsParam) (m map[RowID]*TESTTABLE, maporder []RowID, err error) {
	rows, err := d.ListAllRows(ctx, ID.Table.TESTTABLE.ID, extraParams...)
	if err != nil {
		return
	}

	m = make(map[RowID]*TESTTABLE, len(rows))
	maporder = make([]RowID, 0, len(rows))

	for idx, row := range rows {
		item, err := NewTESTTABLE(&row)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to create TESTTABLE from row %d (%v): %w", idx, row.BrowserLink, err)
		}
		maporder = append(maporder, RowID(row.Id))
		m[RowID(row.Id)] = &item
	}

	return
}

//endregion

//region Methods for deep data fetching (with loading relations)

// Tables enumeration is used for specification of the tables to deep load
type Tables struct {
	LoadRelationsRecursive         bool // Special flag denoting that LoadRelations must load call LoadRelations on relations recursively
	AllEmployees                   bool // All employees
	Invoice                        bool // Invoice
	Months                         bool // Months
	Entries                        bool // Entries
	PatentCompensation             bool // Patent compensation
	EntryType                      bool // Entry Type
	LegalEntity                    bool // Legal entity
	TaxYears                       bool // Tax years
	EmployeePatents                bool // Employee Patents
	FullPayrollReport              bool // Full payroll report
	BankTariffs                    bool // Bank tariffs
	PHMonthlyReport                bool // PH Monthly Report
	Location                       bool // Location
	CompanyRates                   bool // Company rates
	SummaryForCurrentPeriod3       bool // Summary for current period 3
	HeadcountPerLocation           bool // Headcount per location
	WorkDays                       bool // Work days
	TemplateEntries                bool // Template Entries
	BankDetails                    bool // Bank details
	BeneficiaryBank                bool // Beneficiary Bank
	PayrollSchedule                bool // Payroll Schedule
	PensionFundFixed               bool // Pension Fund fixed
	SocialInsurance                bool // Social Insurance
	PensionFundPercent             bool // Pension fund percent
	PerDayCalculations             bool // Per Day Calculations
	PerDayPolicies                 bool // Per Day Policies
	PayableEmployees               bool // Payable employees
	TemplateEntriesMonthsFiltering bool // Template entries months filtering
	TemplateEntriesTypeFiltering   bool // Template entries type filtering
	EntriesMonthsFiltering         bool // Entries months filtering
	EntriesTypeFiltering           bool // Entries type filtering
	TESTTABLE                      bool // TEST TABLE
}

// LoadRelationsAllEmployees loads data into lookup fields of the AllEmployees struct
func (doc *CodaDocument) LoadRelationsAllEmployees(ctx context.Context, shallow map[RowID]*AllEmployees, rels Tables) (err error) {
	var wg sync.WaitGroup

	// In recursive mode we put self to the cache to avoid nested calls to LoadRelationsAllEmployees
	// Unfortunately no guarantee that `shallow` won't spoil the cache unless it contains all possible rows
	if rels.LoadRelationsRecursive {
		doc.relationsCache.Store("AllEmployees", shallow)
	}

	var _bankDetailsMap map[RowID]*BankDetails
	var _legalEntityMap map[RowID]*LegalEntity
	var _locationMap map[RowID]*Location
	var _bankTariffsMap map[RowID]*BankTariffs

	func() {
		if !rels.BankDetails {
			return
		}

		if _bankDetailsInter, ok := doc.relationsCache.Load("BankDetails"); ok {
			if _bankDetailsMap, ok = _bankDetailsInter.(map[RowID]*BankDetails); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_bankDetailsMap, _, err = doc.MapOfBankDetails(ctx)
			doc.relationsCache.Store("BankDetails", _bankDetailsMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsBankDetails(ctx, _bankDetailsMap, rels)
			}
		}()
	}()
	func() {
		if !rels.LegalEntity {
			return
		}

		if _legalEntityInter, ok := doc.relationsCache.Load("LegalEntity"); ok {
			if _legalEntityMap, ok = _legalEntityInter.(map[RowID]*LegalEntity); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_legalEntityMap, _, err = doc.MapOfLegalEntity(ctx)
			doc.relationsCache.Store("LegalEntity", _legalEntityMap)
		}()
	}()
	func() {
		if !rels.Location {
			return
		}

		if _locationInter, ok := doc.relationsCache.Load("Location"); ok {
			if _locationMap, ok = _locationInter.(map[RowID]*Location); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_locationMap, _, err = doc.MapOfLocation(ctx)
			doc.relationsCache.Store("Location", _locationMap)
		}()
	}()
	func() {
		if !rels.BankTariffs {
			return
		}

		if _bankTariffsInter, ok := doc.relationsCache.Load("BankTariffs"); ok {
			if _bankTariffsMap, ok = _bankTariffsInter.(map[RowID]*BankTariffs); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_bankTariffsMap, _, err = doc.MapOfBankTariffs(ctx)
			doc.relationsCache.Store("BankTariffs", _bankTariffsMap)
		}()
	}()

	wg.Wait()

	if err != nil {
		return err
	}

	for ii, _ := range shallow {
		if rels.LegalEntity {
			shallow[ii].LegalEntity.Hydrate(_legalEntityMap)
		}
		if rels.Location {
			shallow[ii].Location.Hydrate(_locationMap)
		}
		if rels.BankTariffs {
			shallow[ii].BankTariff.Hydrate(_bankTariffsMap)
		}
		if rels.BankDetails {
			shallow[ii].BankDetails.Hydrate(_bankDetailsMap)
		}
	}

	return nil
}

// LoadRelationsInvoice loads data into lookup fields of the Invoice struct
func (doc *CodaDocument) LoadRelationsInvoice(ctx context.Context, shallow map[RowID]*Invoice, rels Tables) (err error) {
	var wg sync.WaitGroup

	// In recursive mode we put self to the cache to avoid nested calls to LoadRelationsInvoice
	// Unfortunately no guarantee that `shallow` won't spoil the cache unless it contains all possible rows
	if rels.LoadRelationsRecursive {
		doc.relationsCache.Store("Invoice", shallow)
	}

	var _monthsMap map[RowID]*Months
	var _allEmployeesMap map[RowID]*AllEmployees
	var _invoiceMap map[RowID]*Invoice
	var _entriesMap map[RowID]*Entries
	var _templateEntriesMap map[RowID]*TemplateEntries
	var _bankDetailsMap map[RowID]*BankDetails
	var _legalEntityMap map[RowID]*LegalEntity

	func() {
		if !rels.Entries {
			return
		}

		if _entriesInter, ok := doc.relationsCache.Load("Entries"); ok {
			if _entriesMap, ok = _entriesInter.(map[RowID]*Entries); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_entriesMap, _, err = doc.MapOfEntries(ctx)
			doc.relationsCache.Store("Entries", _entriesMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsEntries(ctx, _entriesMap, rels)
			}
		}()
	}()
	func() {
		if !rels.TemplateEntries {
			return
		}

		if _templateEntriesInter, ok := doc.relationsCache.Load("TemplateEntries"); ok {
			if _templateEntriesMap, ok = _templateEntriesInter.(map[RowID]*TemplateEntries); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_templateEntriesMap, _, err = doc.MapOfTemplateEntries(ctx)
			doc.relationsCache.Store("TemplateEntries", _templateEntriesMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsTemplateEntries(ctx, _templateEntriesMap, rels)
			}
		}()
	}()
	func() {
		if !rels.BankDetails {
			return
		}

		if _bankDetailsInter, ok := doc.relationsCache.Load("BankDetails"); ok {
			if _bankDetailsMap, ok = _bankDetailsInter.(map[RowID]*BankDetails); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_bankDetailsMap, _, err = doc.MapOfBankDetails(ctx)
			doc.relationsCache.Store("BankDetails", _bankDetailsMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsBankDetails(ctx, _bankDetailsMap, rels)
			}
		}()
	}()
	func() {
		if !rels.LegalEntity {
			return
		}

		if _legalEntityInter, ok := doc.relationsCache.Load("LegalEntity"); ok {
			if _legalEntityMap, ok = _legalEntityInter.(map[RowID]*LegalEntity); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_legalEntityMap, _, err = doc.MapOfLegalEntity(ctx)
			doc.relationsCache.Store("LegalEntity", _legalEntityMap)
		}()
	}()
	func() {
		if !rels.Months {
			return
		}

		if _monthsInter, ok := doc.relationsCache.Load("Months"); ok {
			if _monthsMap, ok = _monthsInter.(map[RowID]*Months); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_monthsMap, _, err = doc.MapOfMonths(ctx)
			doc.relationsCache.Store("Months", _monthsMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsMonths(ctx, _monthsMap, rels)
			}
		}()
	}()
	func() {
		if !rels.AllEmployees {
			return
		}

		if _allEmployeesInter, ok := doc.relationsCache.Load("AllEmployees"); ok {
			if _allEmployeesMap, ok = _allEmployeesInter.(map[RowID]*AllEmployees); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_allEmployeesMap, _, err = doc.MapOfAllEmployees(ctx)
			doc.relationsCache.Store("AllEmployees", _allEmployeesMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsAllEmployees(ctx, _allEmployeesMap, rels)
			}
		}()
	}()
	func() {
		if !rels.Invoice {
			return
		}

		if _invoiceInter, ok := doc.relationsCache.Load("Invoice"); ok {
			if _invoiceMap, ok = _invoiceInter.(map[RowID]*Invoice); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_invoiceMap, _, err = doc.MapOfInvoice(ctx)
			doc.relationsCache.Store("Invoice", _invoiceMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsInvoice(ctx, _invoiceMap, rels)
			}
		}()
	}()

	wg.Wait()

	if err != nil {
		return err
	}

	for ii, _ := range shallow {
		if rels.Months {
			shallow[ii].Month.Hydrate(_monthsMap)
		}
		if rels.AllEmployees {
			shallow[ii].Employee.Hydrate(_allEmployeesMap)
		}
		if rels.Invoice {
			shallow[ii].PreviousInvoice.Hydrate(_invoiceMap)
		}
		if rels.Entries {
			shallow[ii].InvoiceEntries.Hydrate(_entriesMap)
		}
		if rels.TemplateEntries {
			shallow[ii].TemplatesRefs.Hydrate(_templateEntriesMap)
		}
		if rels.BankDetails {
			shallow[ii].RecipientDetails.Hydrate(_bankDetailsMap)
		}
		if rels.LegalEntity {
			shallow[ii].SenderDetails.Hydrate(_legalEntityMap)
		}
	}

	return nil
}

// LoadRelationsMonths loads data into lookup fields of the Months struct
func (doc *CodaDocument) LoadRelationsMonths(ctx context.Context, shallow map[RowID]*Months, rels Tables) (err error) {
	var wg sync.WaitGroup

	// In recursive mode we put self to the cache to avoid nested calls to LoadRelationsMonths
	// Unfortunately no guarantee that `shallow` won't spoil the cache unless it contains all possible rows
	if rels.LoadRelationsRecursive {
		doc.relationsCache.Store("Months", shallow)
	}

	var _monthsMap map[RowID]*Months

	func() {
		if !rels.Months {
			return
		}

		if _monthsInter, ok := doc.relationsCache.Load("Months"); ok {
			if _monthsMap, ok = _monthsInter.(map[RowID]*Months); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_monthsMap, _, err = doc.MapOfMonths(ctx)
			doc.relationsCache.Store("Months", _monthsMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsMonths(ctx, _monthsMap, rels)
			}
		}()
	}()

	wg.Wait()

	if err != nil {
		return err
	}

	for ii, _ := range shallow {
		if rels.Months {
			shallow[ii].PreviousMonthLink.Hydrate(_monthsMap)
		}
	}

	return nil
}

// LoadRelationsEntries loads data into lookup fields of the Entries struct
func (doc *CodaDocument) LoadRelationsEntries(ctx context.Context, shallow map[RowID]*Entries, rels Tables) (err error) {
	var wg sync.WaitGroup

	// In recursive mode we put self to the cache to avoid nested calls to LoadRelationsEntries
	// Unfortunately no guarantee that `shallow` won't spoil the cache unless it contains all possible rows
	if rels.LoadRelationsRecursive {
		doc.relationsCache.Store("Entries", shallow)
	}

	var _invoiceMap map[RowID]*Invoice
	var _entryTypeMap map[RowID]*EntryType
	var _monthsMap map[RowID]*Months

	func() {
		if !rels.Invoice {
			return
		}

		if _invoiceInter, ok := doc.relationsCache.Load("Invoice"); ok {
			if _invoiceMap, ok = _invoiceInter.(map[RowID]*Invoice); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_invoiceMap, _, err = doc.MapOfInvoice(ctx)
			doc.relationsCache.Store("Invoice", _invoiceMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsInvoice(ctx, _invoiceMap, rels)
			}
		}()
	}()
	func() {
		if !rels.EntryType {
			return
		}

		if _entryTypeInter, ok := doc.relationsCache.Load("EntryType"); ok {
			if _entryTypeMap, ok = _entryTypeInter.(map[RowID]*EntryType); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_entryTypeMap, _, err = doc.MapOfEntryType(ctx)
			doc.relationsCache.Store("EntryType", _entryTypeMap)
		}()
	}()
	func() {
		if !rels.Months {
			return
		}

		if _monthsInter, ok := doc.relationsCache.Load("Months"); ok {
			if _monthsMap, ok = _monthsInter.(map[RowID]*Months); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_monthsMap, _, err = doc.MapOfMonths(ctx)
			doc.relationsCache.Store("Months", _monthsMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsMonths(ctx, _monthsMap, rels)
			}
		}()
	}()

	wg.Wait()

	if err != nil {
		return err
	}

	for ii, _ := range shallow {
		if rels.Invoice {
			shallow[ii].Invoice.Hydrate(_invoiceMap)
		}
		if rels.EntryType {
			shallow[ii].Type.Hydrate(_entryTypeMap)
		}
		if rels.Months {
			shallow[ii].Month.Hydrate(_monthsMap)
		}
	}

	return nil
}

// LoadRelationsPatentCompensation loads data into lookup fields of the PatentCompensation struct
func (doc *CodaDocument) LoadRelationsPatentCompensation(ctx context.Context, shallow map[RowID]*PatentCompensation, rels Tables) (err error) {
	var wg sync.WaitGroup

	// In recursive mode we put self to the cache to avoid nested calls to LoadRelationsPatentCompensation
	// Unfortunately no guarantee that `shallow` won't spoil the cache unless it contains all possible rows
	if rels.LoadRelationsRecursive {
		doc.relationsCache.Store("PatentCompensation", shallow)
	}

	var _invoiceMap map[RowID]*Invoice
	var _employeePatentsMap map[RowID]*EmployeePatents

	func() {
		if !rels.EmployeePatents {
			return
		}

		if _employeePatentsInter, ok := doc.relationsCache.Load("EmployeePatents"); ok {
			if _employeePatentsMap, ok = _employeePatentsInter.(map[RowID]*EmployeePatents); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_employeePatentsMap, _, err = doc.MapOfEmployeePatents(ctx)
			doc.relationsCache.Store("EmployeePatents", _employeePatentsMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsEmployeePatents(ctx, _employeePatentsMap, rels)
			}
		}()
	}()
	func() {
		if !rels.Invoice {
			return
		}

		if _invoiceInter, ok := doc.relationsCache.Load("Invoice"); ok {
			if _invoiceMap, ok = _invoiceInter.(map[RowID]*Invoice); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_invoiceMap, _, err = doc.MapOfInvoice(ctx)
			doc.relationsCache.Store("Invoice", _invoiceMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsInvoice(ctx, _invoiceMap, rels)
			}
		}()
	}()

	wg.Wait()

	if err != nil {
		return err
	}

	for ii, _ := range shallow {
		if rels.Invoice {
			shallow[ii].PaymentInvoice.Hydrate(_invoiceMap)
		}
		if rels.EmployeePatents {
			shallow[ii].EmployeePatentRef.Hydrate(_employeePatentsMap)
		}
	}

	return nil
}

// LoadRelationsEmployeePatents loads data into lookup fields of the EmployeePatents struct
func (doc *CodaDocument) LoadRelationsEmployeePatents(ctx context.Context, shallow map[RowID]*EmployeePatents, rels Tables) (err error) {
	var wg sync.WaitGroup

	// In recursive mode we put self to the cache to avoid nested calls to LoadRelationsEmployeePatents
	// Unfortunately no guarantee that `shallow` won't spoil the cache unless it contains all possible rows
	if rels.LoadRelationsRecursive {
		doc.relationsCache.Store("EmployeePatents", shallow)
	}

	var _allEmployeesMap map[RowID]*AllEmployees
	var _taxYearsMap map[RowID]*TaxYears

	func() {
		if !rels.AllEmployees {
			return
		}

		if _allEmployeesInter, ok := doc.relationsCache.Load("AllEmployees"); ok {
			if _allEmployeesMap, ok = _allEmployeesInter.(map[RowID]*AllEmployees); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_allEmployeesMap, _, err = doc.MapOfAllEmployees(ctx)
			doc.relationsCache.Store("AllEmployees", _allEmployeesMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsAllEmployees(ctx, _allEmployeesMap, rels)
			}
		}()
	}()
	func() {
		if !rels.TaxYears {
			return
		}

		if _taxYearsInter, ok := doc.relationsCache.Load("TaxYears"); ok {
			if _taxYearsMap, ok = _taxYearsInter.(map[RowID]*TaxYears); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_taxYearsMap, _, err = doc.MapOfTaxYears(ctx)
			doc.relationsCache.Store("TaxYears", _taxYearsMap)
		}()
	}()

	wg.Wait()

	if err != nil {
		return err
	}

	for ii, _ := range shallow {
		if rels.AllEmployees {
			shallow[ii].Employee.Hydrate(_allEmployeesMap)
		}
		if rels.TaxYears {
			shallow[ii].Year.Hydrate(_taxYearsMap)
		}
	}

	return nil
}

// LoadRelationsFullPayrollReport loads data into lookup fields of the FullPayrollReport struct
func (doc *CodaDocument) LoadRelationsFullPayrollReport(ctx context.Context, shallow map[RowID]*FullPayrollReport, rels Tables) (err error) {
	var wg sync.WaitGroup

	// In recursive mode we put self to the cache to avoid nested calls to LoadRelationsFullPayrollReport
	// Unfortunately no guarantee that `shallow` won't spoil the cache unless it contains all possible rows
	if rels.LoadRelationsRecursive {
		doc.relationsCache.Store("FullPayrollReport", shallow)
	}

	var _invoiceMap map[RowID]*Invoice
	var _entriesMap map[RowID]*Entries
	var _locationMap map[RowID]*Location

	func() {
		if !rels.Entries {
			return
		}

		if _entriesInter, ok := doc.relationsCache.Load("Entries"); ok {
			if _entriesMap, ok = _entriesInter.(map[RowID]*Entries); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_entriesMap, _, err = doc.MapOfEntries(ctx)
			doc.relationsCache.Store("Entries", _entriesMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsEntries(ctx, _entriesMap, rels)
			}
		}()
	}()
	func() {
		if !rels.Location {
			return
		}

		if _locationInter, ok := doc.relationsCache.Load("Location"); ok {
			if _locationMap, ok = _locationInter.(map[RowID]*Location); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_locationMap, _, err = doc.MapOfLocation(ctx)
			doc.relationsCache.Store("Location", _locationMap)
		}()
	}()
	func() {
		if !rels.Invoice {
			return
		}

		if _invoiceInter, ok := doc.relationsCache.Load("Invoice"); ok {
			if _invoiceMap, ok = _invoiceInter.(map[RowID]*Invoice); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_invoiceMap, _, err = doc.MapOfInvoice(ctx)
			doc.relationsCache.Store("Invoice", _invoiceMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsInvoice(ctx, _invoiceMap, rels)
			}
		}()
	}()

	wg.Wait()

	if err != nil {
		return err
	}

	for ii, _ := range shallow {
		if rels.Location {
			shallow[ii].Location.Hydrate(_locationMap)
		}
		if rels.Invoice {
			shallow[ii].InvoiceRef.Hydrate(_invoiceMap)
		}
		if rels.Entries {
			shallow[ii].OvertimesRefs.Hydrate(_entriesMap)
			shallow[ii].PublicHolidaysRefs.Hydrate(_entriesMap)
			shallow[ii].RestCorrectionRefs.Hydrate(_entriesMap)
			shallow[ii].StartDayRefs.Hydrate(_entriesMap)
			shallow[ii].SalaryChangesRefs.Hydrate(_entriesMap)
			shallow[ii].QuitCompensationsRefs.Hydrate(_entriesMap)
			shallow[ii].PaidAnnualLeavesRefs.Hydrate(_entriesMap)
		}
	}

	return nil
}

// LoadRelationsPHMonthlyReport loads data into lookup fields of the PHMonthlyReport struct
func (doc *CodaDocument) LoadRelationsPHMonthlyReport(ctx context.Context, shallow map[RowID]*PHMonthlyReport, rels Tables) (err error) {
	var wg sync.WaitGroup

	// In recursive mode we put self to the cache to avoid nested calls to LoadRelationsPHMonthlyReport
	// Unfortunately no guarantee that `shallow` won't spoil the cache unless it contains all possible rows
	if rels.LoadRelationsRecursive {
		doc.relationsCache.Store("PHMonthlyReport", shallow)
	}

	var _monthsMap map[RowID]*Months

	func() {
		if !rels.Months {
			return
		}

		if _monthsInter, ok := doc.relationsCache.Load("Months"); ok {
			if _monthsMap, ok = _monthsInter.(map[RowID]*Months); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_monthsMap, _, err = doc.MapOfMonths(ctx)
			doc.relationsCache.Store("Months", _monthsMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsMonths(ctx, _monthsMap, rels)
			}
		}()
	}()

	wg.Wait()

	if err != nil {
		return err
	}

	for ii, _ := range shallow {
		if rels.Months {
			shallow[ii].Month.Hydrate(_monthsMap)
		}
	}

	return nil
}

// LoadRelationsCompanyRates loads data into lookup fields of the CompanyRates struct
func (doc *CodaDocument) LoadRelationsCompanyRates(ctx context.Context, shallow map[RowID]*CompanyRates, rels Tables) (err error) {
	var wg sync.WaitGroup

	// In recursive mode we put self to the cache to avoid nested calls to LoadRelationsCompanyRates
	// Unfortunately no guarantee that `shallow` won't spoil the cache unless it contains all possible rows
	if rels.LoadRelationsRecursive {
		doc.relationsCache.Store("CompanyRates", shallow)
	}

	var _monthsMap map[RowID]*Months

	func() {
		if !rels.Months {
			return
		}

		if _monthsInter, ok := doc.relationsCache.Load("Months"); ok {
			if _monthsMap, ok = _monthsInter.(map[RowID]*Months); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_monthsMap, _, err = doc.MapOfMonths(ctx)
			doc.relationsCache.Store("Months", _monthsMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsMonths(ctx, _monthsMap, rels)
			}
		}()
	}()

	wg.Wait()

	if err != nil {
		return err
	}

	for ii, _ := range shallow {
		if rels.Months {
			shallow[ii].Month.Hydrate(_monthsMap)
		}
	}

	return nil
}

// LoadRelationsSummaryForCurrentPeriod3 loads data into lookup fields of the SummaryForCurrentPeriod3 struct
func (doc *CodaDocument) LoadRelationsSummaryForCurrentPeriod3(ctx context.Context, shallow map[RowID]*SummaryForCurrentPeriod3, rels Tables) (err error) {
	var wg sync.WaitGroup

	// In recursive mode we put self to the cache to avoid nested calls to LoadRelationsSummaryForCurrentPeriod3
	// Unfortunately no guarantee that `shallow` won't spoil the cache unless it contains all possible rows
	if rels.LoadRelationsRecursive {
		doc.relationsCache.Store("SummaryForCurrentPeriod3", shallow)
	}

	var _locationMap map[RowID]*Location
	var _fullPayrollReportMap map[RowID]*FullPayrollReport

	func() {
		if !rels.Location {
			return
		}

		if _locationInter, ok := doc.relationsCache.Load("Location"); ok {
			if _locationMap, ok = _locationInter.(map[RowID]*Location); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_locationMap, _, err = doc.MapOfLocation(ctx)
			doc.relationsCache.Store("Location", _locationMap)
		}()
	}()
	func() {
		if !rels.FullPayrollReport {
			return
		}

		if _fullPayrollReportInter, ok := doc.relationsCache.Load("FullPayrollReport"); ok {
			if _fullPayrollReportMap, ok = _fullPayrollReportInter.(map[RowID]*FullPayrollReport); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_fullPayrollReportMap, _, err = doc.MapOfFullPayrollReport(ctx)
			doc.relationsCache.Store("FullPayrollReport", _fullPayrollReportMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsFullPayrollReport(ctx, _fullPayrollReportMap, rels)
			}
		}()
	}()

	wg.Wait()

	if err != nil {
		return err
	}

	for ii, _ := range shallow {
		if rels.Location {
			shallow[ii].Location.Hydrate(_locationMap)
		}
		if rels.FullPayrollReport {
			shallow[ii].LocationRefs.Hydrate(_fullPayrollReportMap)
		}
	}

	return nil
}

// LoadRelationsHeadcountPerLocation loads data into lookup fields of the HeadcountPerLocation struct
func (doc *CodaDocument) LoadRelationsHeadcountPerLocation(ctx context.Context, shallow map[RowID]*HeadcountPerLocation, rels Tables) (err error) {
	var wg sync.WaitGroup

	// In recursive mode we put self to the cache to avoid nested calls to LoadRelationsHeadcountPerLocation
	// Unfortunately no guarantee that `shallow` won't spoil the cache unless it contains all possible rows
	if rels.LoadRelationsRecursive {
		doc.relationsCache.Store("HeadcountPerLocation", shallow)
	}

	var _locationMap map[RowID]*Location

	func() {
		if !rels.Location {
			return
		}

		if _locationInter, ok := doc.relationsCache.Load("Location"); ok {
			if _locationMap, ok = _locationInter.(map[RowID]*Location); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_locationMap, _, err = doc.MapOfLocation(ctx)
			doc.relationsCache.Store("Location", _locationMap)
		}()
	}()

	wg.Wait()

	if err != nil {
		return err
	}

	for ii, _ := range shallow {
		if rels.Location {
			shallow[ii].Location.Hydrate(_locationMap)
		}
	}

	return nil
}

// LoadRelationsWorkDays loads data into lookup fields of the WorkDays struct
func (doc *CodaDocument) LoadRelationsWorkDays(ctx context.Context, shallow map[RowID]*WorkDays, rels Tables) (err error) {
	var wg sync.WaitGroup

	// In recursive mode we put self to the cache to avoid nested calls to LoadRelationsWorkDays
	// Unfortunately no guarantee that `shallow` won't spoil the cache unless it contains all possible rows
	if rels.LoadRelationsRecursive {
		doc.relationsCache.Store("WorkDays", shallow)
	}

	var _monthsMap map[RowID]*Months
	var _locationMap map[RowID]*Location

	func() {
		if !rels.Months {
			return
		}

		if _monthsInter, ok := doc.relationsCache.Load("Months"); ok {
			if _monthsMap, ok = _monthsInter.(map[RowID]*Months); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_monthsMap, _, err = doc.MapOfMonths(ctx)
			doc.relationsCache.Store("Months", _monthsMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsMonths(ctx, _monthsMap, rels)
			}
		}()
	}()
	func() {
		if !rels.Location {
			return
		}

		if _locationInter, ok := doc.relationsCache.Load("Location"); ok {
			if _locationMap, ok = _locationInter.(map[RowID]*Location); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_locationMap, _, err = doc.MapOfLocation(ctx)
			doc.relationsCache.Store("Location", _locationMap)
		}()
	}()

	wg.Wait()

	if err != nil {
		return err
	}

	for ii, _ := range shallow {
		if rels.Months {
			shallow[ii].Month.Hydrate(_monthsMap)
		}
		if rels.Location {
			shallow[ii].Location.Hydrate(_locationMap)
		}
	}

	return nil
}

// LoadRelationsTemplateEntries loads data into lookup fields of the TemplateEntries struct
func (doc *CodaDocument) LoadRelationsTemplateEntries(ctx context.Context, shallow map[RowID]*TemplateEntries, rels Tables) (err error) {
	var wg sync.WaitGroup

	// In recursive mode we put self to the cache to avoid nested calls to LoadRelationsTemplateEntries
	// Unfortunately no guarantee that `shallow` won't spoil the cache unless it contains all possible rows
	if rels.LoadRelationsRecursive {
		doc.relationsCache.Store("TemplateEntries", shallow)
	}

	var _allEmployeesMap map[RowID]*AllEmployees
	var _monthsMap map[RowID]*Months
	var _entryTypeMap map[RowID]*EntryType

	func() {
		if !rels.AllEmployees {
			return
		}

		if _allEmployeesInter, ok := doc.relationsCache.Load("AllEmployees"); ok {
			if _allEmployeesMap, ok = _allEmployeesInter.(map[RowID]*AllEmployees); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_allEmployeesMap, _, err = doc.MapOfAllEmployees(ctx)
			doc.relationsCache.Store("AllEmployees", _allEmployeesMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsAllEmployees(ctx, _allEmployeesMap, rels)
			}
		}()
	}()
	func() {
		if !rels.Months {
			return
		}

		if _monthsInter, ok := doc.relationsCache.Load("Months"); ok {
			if _monthsMap, ok = _monthsInter.(map[RowID]*Months); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_monthsMap, _, err = doc.MapOfMonths(ctx)
			doc.relationsCache.Store("Months", _monthsMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsMonths(ctx, _monthsMap, rels)
			}
		}()
	}()
	func() {
		if !rels.EntryType {
			return
		}

		if _entryTypeInter, ok := doc.relationsCache.Load("EntryType"); ok {
			if _entryTypeMap, ok = _entryTypeInter.(map[RowID]*EntryType); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_entryTypeMap, _, err = doc.MapOfEntryType(ctx)
			doc.relationsCache.Store("EntryType", _entryTypeMap)
		}()
	}()

	wg.Wait()

	if err != nil {
		return err
	}

	for ii, _ := range shallow {
		if rels.AllEmployees {
			shallow[ii].Employee.Hydrate(_allEmployeesMap)
		}
		if rels.Months {
			shallow[ii].MonthFrom.Hydrate(_monthsMap)
			shallow[ii].MonthTo.Hydrate(_monthsMap)
		}
		if rels.EntryType {
			shallow[ii].Type.Hydrate(_entryTypeMap)
		}
	}

	return nil
}

// LoadRelationsBankDetails loads data into lookup fields of the BankDetails struct
func (doc *CodaDocument) LoadRelationsBankDetails(ctx context.Context, shallow map[RowID]*BankDetails, rels Tables) (err error) {
	var wg sync.WaitGroup

	// In recursive mode we put self to the cache to avoid nested calls to LoadRelationsBankDetails
	// Unfortunately no guarantee that `shallow` won't spoil the cache unless it contains all possible rows
	if rels.LoadRelationsRecursive {
		doc.relationsCache.Store("BankDetails", shallow)
	}

	var _allEmployeesMap map[RowID]*AllEmployees
	var _beneficiaryBankMap map[RowID]*BeneficiaryBank
	var _monthsMap map[RowID]*Months

	func() {
		if !rels.AllEmployees {
			return
		}

		if _allEmployeesInter, ok := doc.relationsCache.Load("AllEmployees"); ok {
			if _allEmployeesMap, ok = _allEmployeesInter.(map[RowID]*AllEmployees); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_allEmployeesMap, _, err = doc.MapOfAllEmployees(ctx)
			doc.relationsCache.Store("AllEmployees", _allEmployeesMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsAllEmployees(ctx, _allEmployeesMap, rels)
			}
		}()
	}()
	func() {
		if !rels.BeneficiaryBank {
			return
		}

		if _beneficiaryBankInter, ok := doc.relationsCache.Load("BeneficiaryBank"); ok {
			if _beneficiaryBankMap, ok = _beneficiaryBankInter.(map[RowID]*BeneficiaryBank); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_beneficiaryBankMap, _, err = doc.MapOfBeneficiaryBank(ctx)
			doc.relationsCache.Store("BeneficiaryBank", _beneficiaryBankMap)
		}()
	}()
	func() {
		if !rels.Months {
			return
		}

		if _monthsInter, ok := doc.relationsCache.Load("Months"); ok {
			if _monthsMap, ok = _monthsInter.(map[RowID]*Months); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_monthsMap, _, err = doc.MapOfMonths(ctx)
			doc.relationsCache.Store("Months", _monthsMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsMonths(ctx, _monthsMap, rels)
			}
		}()
	}()

	wg.Wait()

	if err != nil {
		return err
	}

	for ii, _ := range shallow {
		if rels.AllEmployees {
			shallow[ii].Employee.Hydrate(_allEmployeesMap)
		}
		if rels.BeneficiaryBank {
			shallow[ii].BeneficiaryBank.Hydrate(_beneficiaryBankMap)
		}
		if rels.Months {
			shallow[ii].MonthFrom.Hydrate(_monthsMap)
			shallow[ii].MonthTo.Hydrate(_monthsMap)
		}
	}

	return nil
}

// LoadRelationsPayrollSchedule loads data into lookup fields of the PayrollSchedule struct
func (doc *CodaDocument) LoadRelationsPayrollSchedule(ctx context.Context, shallow map[RowID]*PayrollSchedule, rels Tables) (err error) {
	var wg sync.WaitGroup

	// In recursive mode we put self to the cache to avoid nested calls to LoadRelationsPayrollSchedule
	// Unfortunately no guarantee that `shallow` won't spoil the cache unless it contains all possible rows
	if rels.LoadRelationsRecursive {
		doc.relationsCache.Store("PayrollSchedule", shallow)
	}

	var _monthsMap map[RowID]*Months

	func() {
		if !rels.Months {
			return
		}

		if _monthsInter, ok := doc.relationsCache.Load("Months"); ok {
			if _monthsMap, ok = _monthsInter.(map[RowID]*Months); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_monthsMap, _, err = doc.MapOfMonths(ctx)
			doc.relationsCache.Store("Months", _monthsMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsMonths(ctx, _monthsMap, rels)
			}
		}()
	}()

	wg.Wait()

	if err != nil {
		return err
	}

	for ii, _ := range shallow {
		if rels.Months {
			shallow[ii].Month.Hydrate(_monthsMap)
		}
	}

	return nil
}

// LoadRelationsPensionFundFixed loads data into lookup fields of the PensionFundFixed struct
func (doc *CodaDocument) LoadRelationsPensionFundFixed(ctx context.Context, shallow map[RowID]*PensionFundFixed, rels Tables) (err error) {
	var wg sync.WaitGroup

	// In recursive mode we put self to the cache to avoid nested calls to LoadRelationsPensionFundFixed
	// Unfortunately no guarantee that `shallow` won't spoil the cache unless it contains all possible rows
	if rels.LoadRelationsRecursive {
		doc.relationsCache.Store("PensionFundFixed", shallow)
	}

	var _invoiceMap map[RowID]*Invoice
	var _taxYearsMap map[RowID]*TaxYears

	func() {
		if !rels.Invoice {
			return
		}

		if _invoiceInter, ok := doc.relationsCache.Load("Invoice"); ok {
			if _invoiceMap, ok = _invoiceInter.(map[RowID]*Invoice); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_invoiceMap, _, err = doc.MapOfInvoice(ctx)
			doc.relationsCache.Store("Invoice", _invoiceMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsInvoice(ctx, _invoiceMap, rels)
			}
		}()
	}()
	func() {
		if !rels.TaxYears {
			return
		}

		if _taxYearsInter, ok := doc.relationsCache.Load("TaxYears"); ok {
			if _taxYearsMap, ok = _taxYearsInter.(map[RowID]*TaxYears); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_taxYearsMap, _, err = doc.MapOfTaxYears(ctx)
			doc.relationsCache.Store("TaxYears", _taxYearsMap)
		}()
	}()

	wg.Wait()

	if err != nil {
		return err
	}

	for ii, _ := range shallow {
		if rels.Invoice {
			shallow[ii].Invoice.Hydrate(_invoiceMap)
		}
		if rels.TaxYears {
			shallow[ii].Year.Hydrate(_taxYearsMap)
		}
	}

	return nil
}

// LoadRelationsSocialInsurance loads data into lookup fields of the SocialInsurance struct
func (doc *CodaDocument) LoadRelationsSocialInsurance(ctx context.Context, shallow map[RowID]*SocialInsurance, rels Tables) (err error) {
	var wg sync.WaitGroup

	// In recursive mode we put self to the cache to avoid nested calls to LoadRelationsSocialInsurance
	// Unfortunately no guarantee that `shallow` won't spoil the cache unless it contains all possible rows
	if rels.LoadRelationsRecursive {
		doc.relationsCache.Store("SocialInsurance", shallow)
	}

	var _invoiceMap map[RowID]*Invoice
	var _taxYearsMap map[RowID]*TaxYears

	func() {
		if !rels.Invoice {
			return
		}

		if _invoiceInter, ok := doc.relationsCache.Load("Invoice"); ok {
			if _invoiceMap, ok = _invoiceInter.(map[RowID]*Invoice); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_invoiceMap, _, err = doc.MapOfInvoice(ctx)
			doc.relationsCache.Store("Invoice", _invoiceMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsInvoice(ctx, _invoiceMap, rels)
			}
		}()
	}()
	func() {
		if !rels.TaxYears {
			return
		}

		if _taxYearsInter, ok := doc.relationsCache.Load("TaxYears"); ok {
			if _taxYearsMap, ok = _taxYearsInter.(map[RowID]*TaxYears); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_taxYearsMap, _, err = doc.MapOfTaxYears(ctx)
			doc.relationsCache.Store("TaxYears", _taxYearsMap)
		}()
	}()

	wg.Wait()

	if err != nil {
		return err
	}

	for ii, _ := range shallow {
		if rels.Invoice {
			shallow[ii].Invoice.Hydrate(_invoiceMap)
		}
		if rels.TaxYears {
			shallow[ii].Year.Hydrate(_taxYearsMap)
		}
	}

	return nil
}

// LoadRelationsPensionFundPercent loads data into lookup fields of the PensionFundPercent struct
func (doc *CodaDocument) LoadRelationsPensionFundPercent(ctx context.Context, shallow map[RowID]*PensionFundPercent, rels Tables) (err error) {
	var wg sync.WaitGroup

	// In recursive mode we put self to the cache to avoid nested calls to LoadRelationsPensionFundPercent
	// Unfortunately no guarantee that `shallow` won't spoil the cache unless it contains all possible rows
	if rels.LoadRelationsRecursive {
		doc.relationsCache.Store("PensionFundPercent", shallow)
	}

	var _taxYearsMap map[RowID]*TaxYears
	var _invoiceMap map[RowID]*Invoice

	func() {
		if !rels.Invoice {
			return
		}

		if _invoiceInter, ok := doc.relationsCache.Load("Invoice"); ok {
			if _invoiceMap, ok = _invoiceInter.(map[RowID]*Invoice); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_invoiceMap, _, err = doc.MapOfInvoice(ctx)
			doc.relationsCache.Store("Invoice", _invoiceMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsInvoice(ctx, _invoiceMap, rels)
			}
		}()
	}()
	func() {
		if !rels.TaxYears {
			return
		}

		if _taxYearsInter, ok := doc.relationsCache.Load("TaxYears"); ok {
			if _taxYearsMap, ok = _taxYearsInter.(map[RowID]*TaxYears); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_taxYearsMap, _, err = doc.MapOfTaxYears(ctx)
			doc.relationsCache.Store("TaxYears", _taxYearsMap)
		}()
	}()

	wg.Wait()

	if err != nil {
		return err
	}

	for ii, _ := range shallow {
		if rels.TaxYears {
			shallow[ii].Year.Hydrate(_taxYearsMap)
		}
		if rels.Invoice {
			shallow[ii].Invoice.Hydrate(_invoiceMap)
		}
	}

	return nil
}

// LoadRelationsPerDayCalculations loads data into lookup fields of the PerDayCalculations struct
func (doc *CodaDocument) LoadRelationsPerDayCalculations(ctx context.Context, shallow map[RowID]*PerDayCalculations, rels Tables) (err error) {
	var wg sync.WaitGroup

	// In recursive mode we put self to the cache to avoid nested calls to LoadRelationsPerDayCalculations
	// Unfortunately no guarantee that `shallow` won't spoil the cache unless it contains all possible rows
	if rels.LoadRelationsRecursive {
		doc.relationsCache.Store("PerDayCalculations", shallow)
	}

	var _perDayPoliciesMap map[RowID]*PerDayPolicies
	var _invoiceMap map[RowID]*Invoice
	var _monthsMap map[RowID]*Months
	var _entriesMap map[RowID]*Entries

	func() {
		if !rels.Entries {
			return
		}

		if _entriesInter, ok := doc.relationsCache.Load("Entries"); ok {
			if _entriesMap, ok = _entriesInter.(map[RowID]*Entries); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_entriesMap, _, err = doc.MapOfEntries(ctx)
			doc.relationsCache.Store("Entries", _entriesMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsEntries(ctx, _entriesMap, rels)
			}
		}()
	}()
	func() {
		if !rels.PerDayPolicies {
			return
		}

		if _perDayPoliciesInter, ok := doc.relationsCache.Load("PerDayPolicies"); ok {
			if _perDayPoliciesMap, ok = _perDayPoliciesInter.(map[RowID]*PerDayPolicies); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_perDayPoliciesMap, _, err = doc.MapOfPerDayPolicies(ctx)
			doc.relationsCache.Store("PerDayPolicies", _perDayPoliciesMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsPerDayPolicies(ctx, _perDayPoliciesMap, rels)
			}
		}()
	}()
	func() {
		if !rels.Invoice {
			return
		}

		if _invoiceInter, ok := doc.relationsCache.Load("Invoice"); ok {
			if _invoiceMap, ok = _invoiceInter.(map[RowID]*Invoice); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_invoiceMap, _, err = doc.MapOfInvoice(ctx)
			doc.relationsCache.Store("Invoice", _invoiceMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsInvoice(ctx, _invoiceMap, rels)
			}
		}()
	}()
	func() {
		if !rels.Months {
			return
		}

		if _monthsInter, ok := doc.relationsCache.Load("Months"); ok {
			if _monthsMap, ok = _monthsInter.(map[RowID]*Months); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_monthsMap, _, err = doc.MapOfMonths(ctx)
			doc.relationsCache.Store("Months", _monthsMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsMonths(ctx, _monthsMap, rels)
			}
		}()
	}()

	wg.Wait()

	if err != nil {
		return err
	}

	for ii, _ := range shallow {
		if rels.PerDayPolicies {
			shallow[ii].Type.Hydrate(_perDayPoliciesMap)
		}
		if rels.Invoice {
			shallow[ii].PaymentInvoice.Hydrate(_invoiceMap)
			shallow[ii].CalculationInvoice.Hydrate(_invoiceMap)
		}
		if rels.Months {
			shallow[ii].SalaryPeriod.Hydrate(_monthsMap)
			shallow[ii].WorkPeriod.Hydrate(_monthsMap)
		}
		if rels.Entries {
			shallow[ii].Salary.Hydrate(_entriesMap)
		}
	}

	return nil
}

// LoadRelationsPerDayPolicies loads data into lookup fields of the PerDayPolicies struct
func (doc *CodaDocument) LoadRelationsPerDayPolicies(ctx context.Context, shallow map[RowID]*PerDayPolicies, rels Tables) (err error) {
	var wg sync.WaitGroup

	// In recursive mode we put self to the cache to avoid nested calls to LoadRelationsPerDayPolicies
	// Unfortunately no guarantee that `shallow` won't spoil the cache unless it contains all possible rows
	if rels.LoadRelationsRecursive {
		doc.relationsCache.Store("PerDayPolicies", shallow)
	}

	var _entryTypeMap map[RowID]*EntryType

	func() {
		if !rels.EntryType {
			return
		}

		if _entryTypeInter, ok := doc.relationsCache.Load("EntryType"); ok {
			if _entryTypeMap, ok = _entryTypeInter.(map[RowID]*EntryType); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_entryTypeMap, _, err = doc.MapOfEntryType(ctx)
			doc.relationsCache.Store("EntryType", _entryTypeMap)
		}()
	}()

	wg.Wait()

	if err != nil {
		return err
	}

	for ii, _ := range shallow {
		if rels.EntryType {
			shallow[ii].EntryType.Hydrate(_entryTypeMap)
		}
	}

	return nil
}

// LoadRelationsPayableEmployees loads data into lookup fields of the PayableEmployees struct
func (doc *CodaDocument) LoadRelationsPayableEmployees(ctx context.Context, shallow map[RowID]*PayableEmployees, rels Tables) (err error) {
	var wg sync.WaitGroup

	// In recursive mode we put self to the cache to avoid nested calls to LoadRelationsPayableEmployees
	// Unfortunately no guarantee that `shallow` won't spoil the cache unless it contains all possible rows
	if rels.LoadRelationsRecursive {
		doc.relationsCache.Store("PayableEmployees", shallow)
	}

	var _allEmployeesMap map[RowID]*AllEmployees
	var _invoiceMap map[RowID]*Invoice
	var _entriesMap map[RowID]*Entries

	func() {
		if !rels.AllEmployees {
			return
		}

		if _allEmployeesInter, ok := doc.relationsCache.Load("AllEmployees"); ok {
			if _allEmployeesMap, ok = _allEmployeesInter.(map[RowID]*AllEmployees); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_allEmployeesMap, _, err = doc.MapOfAllEmployees(ctx)
			doc.relationsCache.Store("AllEmployees", _allEmployeesMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsAllEmployees(ctx, _allEmployeesMap, rels)
			}
		}()
	}()
	func() {
		if !rels.Invoice {
			return
		}

		if _invoiceInter, ok := doc.relationsCache.Load("Invoice"); ok {
			if _invoiceMap, ok = _invoiceInter.(map[RowID]*Invoice); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_invoiceMap, _, err = doc.MapOfInvoice(ctx)
			doc.relationsCache.Store("Invoice", _invoiceMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsInvoice(ctx, _invoiceMap, rels)
			}
		}()
	}()
	func() {
		if !rels.Entries {
			return
		}

		if _entriesInter, ok := doc.relationsCache.Load("Entries"); ok {
			if _entriesMap, ok = _entriesInter.(map[RowID]*Entries); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_entriesMap, _, err = doc.MapOfEntries(ctx)
			doc.relationsCache.Store("Entries", _entriesMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsEntries(ctx, _entriesMap, rels)
			}
		}()
	}()

	wg.Wait()

	if err != nil {
		return err
	}

	for ii, _ := range shallow {
		if rels.AllEmployees {
			shallow[ii].Employee.Hydrate(_allEmployeesMap)
		}
		if rels.Invoice {
			shallow[ii].TargetInvoice.Hydrate(_invoiceMap)
		}
		if rels.Entries {
			shallow[ii].ManualEntries.Hydrate(_entriesMap)
		}
	}

	return nil
}

// LoadRelationsTemplateEntriesMonthsFiltering loads data into lookup fields of the TemplateEntriesMonthsFiltering struct
func (doc *CodaDocument) LoadRelationsTemplateEntriesMonthsFiltering(ctx context.Context, shallow map[RowID]*TemplateEntriesMonthsFiltering, rels Tables) (err error) {
	var wg sync.WaitGroup

	// In recursive mode we put self to the cache to avoid nested calls to LoadRelationsTemplateEntriesMonthsFiltering
	// Unfortunately no guarantee that `shallow` won't spoil the cache unless it contains all possible rows
	if rels.LoadRelationsRecursive {
		doc.relationsCache.Store("TemplateEntriesMonthsFiltering", shallow)
	}

	var _monthsMap map[RowID]*Months

	func() {
		if !rels.Months {
			return
		}

		if _monthsInter, ok := doc.relationsCache.Load("Months"); ok {
			if _monthsMap, ok = _monthsInter.(map[RowID]*Months); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_monthsMap, _, err = doc.MapOfMonths(ctx)
			doc.relationsCache.Store("Months", _monthsMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsMonths(ctx, _monthsMap, rels)
			}
		}()
	}()

	wg.Wait()

	if err != nil {
		return err
	}

	for ii, _ := range shallow {
		if rels.Months {
			shallow[ii].Month.Hydrate(_monthsMap)
		}
	}

	return nil
}

// LoadRelationsTemplateEntriesTypeFiltering loads data into lookup fields of the TemplateEntriesTypeFiltering struct
func (doc *CodaDocument) LoadRelationsTemplateEntriesTypeFiltering(ctx context.Context, shallow map[RowID]*TemplateEntriesTypeFiltering, rels Tables) (err error) {
	var wg sync.WaitGroup

	// In recursive mode we put self to the cache to avoid nested calls to LoadRelationsTemplateEntriesTypeFiltering
	// Unfortunately no guarantee that `shallow` won't spoil the cache unless it contains all possible rows
	if rels.LoadRelationsRecursive {
		doc.relationsCache.Store("TemplateEntriesTypeFiltering", shallow)
	}

	var _entryTypeMap map[RowID]*EntryType

	func() {
		if !rels.EntryType {
			return
		}

		if _entryTypeInter, ok := doc.relationsCache.Load("EntryType"); ok {
			if _entryTypeMap, ok = _entryTypeInter.(map[RowID]*EntryType); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_entryTypeMap, _, err = doc.MapOfEntryType(ctx)
			doc.relationsCache.Store("EntryType", _entryTypeMap)
		}()
	}()

	wg.Wait()

	if err != nil {
		return err
	}

	for ii, _ := range shallow {
		if rels.EntryType {
			shallow[ii].Type.Hydrate(_entryTypeMap)
			shallow[ii].FilteringType.Hydrate(_entryTypeMap)
		}
	}

	return nil
}

// LoadRelationsEntriesMonthsFiltering loads data into lookup fields of the EntriesMonthsFiltering struct
func (doc *CodaDocument) LoadRelationsEntriesMonthsFiltering(ctx context.Context, shallow map[RowID]*EntriesMonthsFiltering, rels Tables) (err error) {
	var wg sync.WaitGroup

	// In recursive mode we put self to the cache to avoid nested calls to LoadRelationsEntriesMonthsFiltering
	// Unfortunately no guarantee that `shallow` won't spoil the cache unless it contains all possible rows
	if rels.LoadRelationsRecursive {
		doc.relationsCache.Store("EntriesMonthsFiltering", shallow)
	}

	var _monthsMap map[RowID]*Months

	func() {
		if !rels.Months {
			return
		}

		if _monthsInter, ok := doc.relationsCache.Load("Months"); ok {
			if _monthsMap, ok = _monthsInter.(map[RowID]*Months); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_monthsMap, _, err = doc.MapOfMonths(ctx)
			doc.relationsCache.Store("Months", _monthsMap)
			if rels.LoadRelationsRecursive {
				doc.LoadRelationsMonths(ctx, _monthsMap, rels)
			}
		}()
	}()

	wg.Wait()

	if err != nil {
		return err
	}

	for ii, _ := range shallow {
		if rels.Months {
			shallow[ii].Month.Hydrate(_monthsMap)
		}
	}

	return nil
}

// LoadRelationsEntriesTypeFiltering loads data into lookup fields of the EntriesTypeFiltering struct
func (doc *CodaDocument) LoadRelationsEntriesTypeFiltering(ctx context.Context, shallow map[RowID]*EntriesTypeFiltering, rels Tables) (err error) {
	var wg sync.WaitGroup

	// In recursive mode we put self to the cache to avoid nested calls to LoadRelationsEntriesTypeFiltering
	// Unfortunately no guarantee that `shallow` won't spoil the cache unless it contains all possible rows
	if rels.LoadRelationsRecursive {
		doc.relationsCache.Store("EntriesTypeFiltering", shallow)
	}

	var _entryTypeMap map[RowID]*EntryType

	func() {
		if !rels.EntryType {
			return
		}

		if _entryTypeInter, ok := doc.relationsCache.Load("EntryType"); ok {
			if _entryTypeMap, ok = _entryTypeInter.(map[RowID]*EntryType); ok {
				return
			}
		}

		wg.Add(1)
		go func() {
			defer wg.Done()

			_entryTypeMap, _, err = doc.MapOfEntryType(ctx)
			doc.relationsCache.Store("EntryType", _entryTypeMap)
		}()
	}()

	wg.Wait()

	if err != nil {
		return err
	}

	for ii, _ := range shallow {
		if rels.EntryType {
			shallow[ii].Type.Hydrate(_entryTypeMap)
			shallow[ii].FilteringType.Hydrate(_entryTypeMap)
		}
	}

	return nil
}

//endregion
